<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>Scrapy 框架(七)之settings配置文件</title>
      <link href="/post/cf3226c9.html"/>
      <url>/post/cf3226c9.html</url>
      <content type="html"><![CDATA[<p>Scrapy设置(settings)提供了定制Scrapy组件的方法。可以控制包括核心(core)，插件(extension)，pipeline及spider组件。比如 设置Json Pipeliine、LOG_LEVEL等。</p><p>参考文档：<a href="http://scrapy-chs.readthedocs.io/zh_CN/1.0/topics/settings.html#topics-settings-ref" target="_blank" rel="noopener">http://scrapy-chs.readthedocs.io/zh_CN/1.0/topics/settings.html#topics-settings-ref</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 默认: 'scrapybot',当您使用 startproject 命令创建项目时其也被自动赋值。</span></span><br><span class="line">BOT_NAME = <span class="string">'mySpider'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 爬虫应用路径</span></span><br><span class="line">SPIDER_MODULES = [<span class="string">'mySpider.spiders'</span>]</span><br><span class="line">NEWSPIDER_MODULE = <span class="string">'mySpider.spiders'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 客户端 user-agent请求头</span></span><br><span class="line"><span class="comment"># USER_AGENT = 'mySpider (+http://www.yourdomain.com)'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 禁止爬虫配置</span></span><br><span class="line">ROBOTSTXT_OBEY = <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 并发请求数</span></span><br><span class="line"><span class="comment"># CONCURRENT_REQUESTS = 32</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 延迟下载秒数</span></span><br><span class="line"><span class="comment"># DOWNLOAD_DELAY = 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 单域名访问并发数，并且延迟下次秒数也应用在每个域名</span></span><br><span class="line"><span class="comment"># CONCURRENT_REQUESTS_PER_DOMAIN = 16</span></span><br><span class="line"><span class="comment"># 单IP访问并发数，如果有值则忽略：CONCURRENT_REQUESTS_PER_DOMAIN，并且延迟下次秒数也应用在每个IP</span></span><br><span class="line"><span class="comment"># CONCURRENT_REQUESTS_PER_IP = 16</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 是否支持cookie，cookiejar进行操作cookie</span></span><br><span class="line"><span class="comment"># COOKIES_ENABLED = True</span></span><br><span class="line"><span class="comment"># COOKIES_DEBUG = True</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Telnet用于查看当前爬虫的信息，操作爬虫等...</span></span><br><span class="line"><span class="comment"># 使用telnet ip port ，然后通过命令操作</span></span><br><span class="line"><span class="comment"># TELNETCONSOLE_ENABLED = True</span></span><br><span class="line"><span class="comment"># TELNETCONSOLE_HOST = '127.0.0.1'</span></span><br><span class="line"><span class="comment"># TELNETCONSOLE_PORT = [6023,]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 默认请求头</span></span><br><span class="line"><span class="comment"># DEFAULT_REQUEST_HEADERS = &#123;</span></span><br><span class="line"><span class="comment">#   'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',</span></span><br><span class="line"><span class="comment">#   'Accept-Language': 'en',</span></span><br><span class="line"><span class="comment"># &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 爬虫中间件</span></span><br><span class="line"><span class="comment"># SPIDER_MIDDLEWARES = &#123;</span></span><br><span class="line"><span class="comment">#    'mySpider.middlewares.MyspiderSpiderMiddleware': 543,</span></span><br><span class="line"><span class="comment"># &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载中间件</span></span><br><span class="line"><span class="comment"># DOWNLOADER_MIDDLEWARES = &#123;</span></span><br><span class="line"><span class="comment">#    'mySpider.middlewares.MyspiderDownloaderMiddleware': 543,</span></span><br><span class="line"><span class="comment"># &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 自定义扩展，基于信号进行调用</span></span><br><span class="line"><span class="comment"># EXTENSIONS = &#123;</span></span><br><span class="line"><span class="comment">#    'scrapy.extensions.telnet.TelnetConsole': None,</span></span><br><span class="line"><span class="comment"># &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义pipeline处理请求</span></span><br><span class="line"><span class="comment"># ITEM_PIPELINES = &#123;</span></span><br><span class="line"><span class="comment">#     'mySpider.pipelines.MyspiderPipeline': 300,</span></span><br><span class="line"><span class="comment"># &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 爬虫允许的最大深度，可以通过meta查看当前深度；0表示无深度</span></span><br><span class="line"><span class="comment"># DEPTH_LIMIT = 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 爬取时，0表示深度优先Lifo(默认)；1表示广度优先FiFo</span></span><br><span class="line"><span class="comment"># 后进先出，深度优先</span></span><br><span class="line"><span class="comment"># DEPTH_PRIORITY = 0</span></span><br><span class="line"><span class="comment"># SCHEDULER_DISK_QUEUE = 'scrapy.squeue.PickleLifoDiskQueue'</span></span><br><span class="line"><span class="comment"># SCHEDULER_MEMORY_QUEUE = 'scrapy.squeue.LifoMemoryQueue'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 先进先出，广度优先</span></span><br><span class="line"><span class="comment"># DEPTH_PRIORITY = 1</span></span><br><span class="line"><span class="comment"># SCHEDULER_DISK_QUEUE = 'scrapy.squeue.PickleFifoDiskQueue'</span></span><br><span class="line"><span class="comment"># SCHEDULER_MEMORY_QUEUE = 'scrapy.squeue.FifoMemoryQueue'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 调度器队列</span></span><br><span class="line"><span class="comment"># SCHEDULER = 'scrapy.core.scheduler.Scheduler'</span></span><br><span class="line"><span class="comment"># from scrapy.core.scheduler import Scheduler</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 访问URL去重</span></span><br><span class="line"><span class="comment"># DUPEFILTER_CLASS = 'step8_king.duplication.RepeatUrl'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 开始自动限速</span></span><br><span class="line"><span class="comment"># AUTOTHROTTLE_ENABLED = True</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始下载延迟</span></span><br><span class="line"><span class="comment"># AUTOTHROTTLE_START_DELAY = 5</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 最大下载延迟</span></span><br><span class="line"><span class="comment"># AUTOTHROTTLE_MAX_DELAY = 60</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 平均每秒并发数</span></span><br><span class="line"><span class="comment"># AUTOTHROTTLE_TARGET_CONCURRENCY = 1.0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 是否显示</span></span><br><span class="line"><span class="comment"># AUTOTHROTTLE_DEBUG = False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 是否启用缓存策略</span></span><br><span class="line"><span class="comment"># HTTPCACHE_ENABLED = True</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 缓存策略：所有请求均缓存，下次在请求直接访问原来的缓存即可</span></span><br><span class="line"><span class="comment"># HTTPCACHE_POLICY = "scrapy.extensions.httpcache.DummyPolicy"</span></span><br><span class="line"><span class="comment"># 缓存策略：根据Http响应头：Cache-Control、Last-Modified 等进行缓存的策略</span></span><br><span class="line"><span class="comment"># HTTPCACHE_POLICY = "scrapy.extensions.httpcache.RFC2616Policy"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 缓存超时时间</span></span><br><span class="line"><span class="comment"># HTTPCACHE_EXPIRATION_SECS = 0</span></span><br><span class="line"><span class="comment"># 缓存保存路径</span></span><br><span class="line"><span class="comment"># HTTPCACHE_DIR = 'httpcache'</span></span><br><span class="line"><span class="comment"># 缓存忽略的Http状态码</span></span><br><span class="line"><span class="comment"># HTTPCACHE_IGNORE_HTTP_CODES = []</span></span><br><span class="line"><span class="comment"># 缓存存储的插件</span></span><br><span class="line"><span class="comment"># HTTPCACHE_STORAGE = 'scrapy.extensions.httpcache.FilesystemCacheStorage'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ...</span></span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 爬虫 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 爬虫 </tag>
            
            <tag> Scrapy </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Scrapy 框架(六)之Spider Middleware</title>
      <link href="/post/c8ce4f9f.html"/>
      <url>/post/c8ce4f9f.html</url>
      <content type="html"><![CDATA[<h3 id="Spider-Middleware"><a href="#Spider-Middleware" class="headerlink" title="Spider Middleware"></a>Spider Middleware</h3><p>Spider Middleware是介入到Scrapy 的 Spider 处理机制的钩子框架，当Downloader 生成 Response 之后，Response 会被发送给 Spider，在发送给 Spider 之前，Response会首先经过 Spider Middleware 处理，当 Spider处理生成 Item 和 Request 之后，Item 和Request 还会经过 Spider Middleware 的处理。</p><p>Spider Middleware有下面几个作用：</p><ul><li>可以在 Downloader 生成的 Response 发送给 Spider 之前，也就是在 Response 发送给 Spider之前对 Response 进行处理</li><li>可以在 Spider 生成的 Request 发送给 Schedule 之前，也就是在 Request 发送给 Schedule 之前对 Request进行处理</li><li>可以在 Spider 生成的 Item 发送给 Item Pipeline 之前，也就是在 Item 发送给 Item Pipeline 之前对 Item 进行处理</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SpiderMiddleware</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_spider_input</span><span class="params">(self,response, spider)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        下载完成，执行，然后交给parse处理</span></span><br><span class="line"><span class="string">        :param response: </span></span><br><span class="line"><span class="string">        :param spider: </span></span><br><span class="line"><span class="string">        :return: </span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_spider_output</span><span class="params">(self,response, result, spider)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        spider处理完成，返回时调用</span></span><br><span class="line"><span class="string">        :param response:</span></span><br><span class="line"><span class="string">        :param result:</span></span><br><span class="line"><span class="string">        :param spider:</span></span><br><span class="line"><span class="string">        :return: 必须返回包含 Request 或 Item 对象的可迭代对象(iterable)</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_spider_exception</span><span class="params">(self,response, exception, spider)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        异常调用</span></span><br><span class="line"><span class="string">        :param response:</span></span><br><span class="line"><span class="string">        :param exception:</span></span><br><span class="line"><span class="string">        :param spider:</span></span><br><span class="line"><span class="string">        :return: None,继续交给后续中间件处理异常；含 Response 或 Item 的可迭代对象(iterable)，交给调度器或pipeline</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_start_requests</span><span class="params">(self,start_requests, spider)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        爬虫启动时调用</span></span><br><span class="line"><span class="string">        :param start_requests:</span></span><br><span class="line"><span class="string">        :param spider:</span></span><br><span class="line"><span class="string">        :return: 包含 Request 对象的可迭代对象</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> start_requests</span><br></pre></td></tr></table></figure><h4 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明"></a>使用说明</h4><p>其实 Scrapy 已经提供了许多的 Spider Middleware ，它们在default_settings.py文件中被SPIDER_MIDDLEWARES_BASE变量所定义。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">SPIDER_MIDDLEWARES_BASE = &#123;</span><br><span class="line">    <span class="comment"># Engine side</span></span><br><span class="line">    <span class="string">'scrapy.spidermiddlewares.httperror.HttpErrorMiddleware'</span>: <span class="number">50</span>,</span><br><span class="line">    <span class="string">'scrapy.spidermiddlewares.offsite.OffsiteMiddleware'</span>: <span class="number">500</span>,</span><br><span class="line">    <span class="string">'scrapy.spidermiddlewares.referer.RefererMiddleware'</span>: <span class="number">700</span>,</span><br><span class="line">    <span class="string">'scrapy.spidermiddlewares.urllength.UrlLengthMiddleware'</span>: <span class="number">800</span>,</span><br><span class="line">    <span class="string">'scrapy.spidermiddlewares.depth.DepthMiddleware'</span>: <span class="number">900</span>,</span><br><span class="line">    <span class="comment"># Spider side</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和 Downloader Middleware 一样，Spider Middleware 首先加入到SPIDER_MIDDLEWARES设置中，该设置会和 Scrapy 中的SPIDER_MIDDLEWARES_BASE 定义的 Spider Middleware 合并，然后根据键值得数字优先排序，得到一个有序列表。需要注意的是<strong>越小代表越靠近Scrapy引擎，数字越大越靠近Spider</strong></p><h4 id="核心方法"><a href="#核心方法" class="headerlink" title="核心方法"></a>核心方法</h4><p>每个Spider Middleware 是一个定义了以下一个或多个方法的Python类 ，核的方法有下面四个：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">process_spider_input(self,response, spider)</span><br><span class="line">process_spider_output(self,response, result, spider)</span><br><span class="line">process_spider_exception(self,response, exception, spider)</span><br><span class="line">process_start_requests(self,start_requests, spider)</span><br></pre></td></tr></table></figure><h5 id="process-spider-input-self-response-spider"><a href="#process-spider-input-self-response-spider" class="headerlink" title="process_spider_input(self,response, spider)"></a>process_spider_input(self,response, spider)</h5><ul><li>当 Response 被 Spider Middleware 处理时被调用</li><li>process_spider_input()方法返回 None 或者抛出一个异常<ul><li>如果返回None，Scrapy 将会继续处理该 Response，调用所有其他的 Spider Middleware，直到 Spider处理该 Response。</li><li>如果抛出一个异常， Scrapy 将不会调用任何其他 Spider Middleware 的process_spider_input()方法，而调用 Request 的 errback() 方法，errback 的输出将会被重新输入到中间件中，使用process_spider_output()方法来处理，当其抛出异常时则调用process_spider_exception()方法来处理</li></ul></li><li>参数：<ul><li><code>response (Response 对象)</code> – 被处理的 Response</li><li><code>spider (Spider 对象)</code> – 该Response 对应的 Spider</li></ul></li></ul><h5 id="process-spider-output-self-response-result-spider"><a href="#process-spider-output-self-response-result-spider" class="headerlink" title="process_spider_output(self,response, result, spider)"></a>process_spider_output(self,response, result, spider)</h5><ul><li>当 Spider 处理 Response 返回结果时被调用</li><li>process_spider_output()方法必须返回以下其中一个：包含Request 或者 Item 对象的可迭代对象</li><li>参数：<ul><li><code>response (Response 对象)</code> – 生成该输出的 Response</li><li><code>result（包含Request或Item对象的可迭代对象）</code> – Spider 返回的结果</li><li><code>spider (Spider 对象)</code> – 其结果对应的 Spider</li></ul></li></ul><h5 id="process-spider-exception-self-response-exception-spider"><a href="#process-spider-exception-self-response-exception-spider" class="headerlink" title="process_spider_exception(self,response, exception, spider)"></a>process_spider_exception(self,response, exception, spider)</h5><ul><li>当 Spider 或 Spider Middleware 的 process_spider_input()方法抛出异常时被调用</li><li>process_spider_exception()方法必须返回以下其中一种：None、包含 Response 或 Item对象的可迭代对象<ul><li>如果返回None，Scrapy 将继续处理该异常，调用其他 Spider Middleware 中的process_spider_exception()方法，直到所有 Spider Middleware 都被调用。</li><li>如果返回时一个可迭代对象，那么其他 Spider Middleware 的process_spider_exception()方法不会被调用，而是调用process_spider_output()方法</li></ul></li><li>参数：<ul><li><code>response (Response 对象)</code> – 异常被抛出时被处理的 Response</li><li><code>exception（Exception对象）</code> – 被抛出的异常</li><li><code>spider (Spider 对象)</code> – 抛出该异常的 Spider</li></ul></li></ul><h5 id="process-start-requests-self-start-requests-spider"><a href="#process-start-requests-self-start-requests-spider" class="headerlink" title="process_start_requests(self,start_requests, spider)"></a>process_start_requests(self,start_requests, spider)</h5><ul><li>当爬虫启动时调用</li><li>process_start_requests()方法必须返回包含Request 对象的可迭代对象</li><li>参数：<ul><li><code>start_requests (包含Request的可迭代对象)</code> – Start Requests</li><li><code>spider (Spider 对象)</code> – Start Requests 所属 Spider</li></ul></li></ul>]]></content>
      
      <categories>
          
          <category> 爬虫 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 爬虫 </tag>
            
            <tag> Scrapy </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Scrapy 框架(五)之Downloader Middleware</title>
      <link href="/post/f1fb118c.html"/>
      <url>/post/f1fb118c.html</url>
      <content type="html"><![CDATA[<h3 id="Downloader-Middleware"><a href="#Downloader-Middleware" class="headerlink" title="Downloader Middleware"></a>Downloader Middleware</h3><p>Downloader Middleware就是下载中间件，下载中间件是处于引擎(crawler.engine)和下载器(crawler.engine.download())之间的一层组件，可以有多个下载中间件被加载运行。</p><ol><li>当引擎传递请求给下载器的过程中，下载中间件可以对请求进行处理 （例如增加http header信息，增加proxy信息等）；</li><li>在下载器完成http请求，传递响应给引擎的过程中， 下载中间件可以对响应进行处理（例如进行gzip的解压等）</li></ol><p>Downloader Middleware的功能十分强大，修改User-Agent、处理重定向、设置代理、失败重试、设置Cookies等功能都需要借助它来实现。</p><h4 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明"></a>使用说明</h4><p>其实Scrapy已经提供许多Downloader Middleware，比如负责失败重试、自动重定向等功能的Middleware，它们在default_settings.py文件中被DOWNLOADER_MIDDLEWARES_BASE变量所定义。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">DOWNLOADER_MIDDLEWARES_BASE = &#123;</span><br><span class="line">    <span class="comment"># Engine side</span></span><br><span class="line">    <span class="string">'scrapy.downloadermiddlewares.robotstxt.RobotsTxtMiddleware'</span>: <span class="number">100</span>,</span><br><span class="line">    <span class="string">'scrapy.downloadermiddlewares.httpauth.HttpAuthMiddleware'</span>: <span class="number">300</span>,</span><br><span class="line">    <span class="string">'scrapy.downloadermiddlewares.downloadtimeout.DownloadTimeoutMiddleware'</span>: <span class="number">350</span>,</span><br><span class="line">    <span class="string">'scrapy.downloadermiddlewares.defaultheaders.DefaultHeadersMiddleware'</span>: <span class="number">400</span>,</span><br><span class="line">    <span class="string">'scrapy.downloadermiddlewares.useragent.UserAgentMiddleware'</span>: <span class="number">500</span>,</span><br><span class="line">    <span class="string">'scrapy.downloadermiddlewares.retry.RetryMiddleware'</span>: <span class="number">550</span>,</span><br><span class="line">    <span class="string">'scrapy.downloadermiddlewares.ajaxcrawl.AjaxCrawlMiddleware'</span>: <span class="number">560</span>,</span><br><span class="line">    <span class="string">'scrapy.downloadermiddlewares.redirect.MetaRefreshMiddleware'</span>: <span class="number">580</span>,</span><br><span class="line">    <span class="string">'scrapy.downloadermiddlewares.httpcompression.HttpCompressionMiddleware'</span>: <span class="number">590</span>,</span><br><span class="line">    <span class="string">'scrapy.downloadermiddlewares.redirect.RedirectMiddleware'</span>: <span class="number">600</span>,</span><br><span class="line">    <span class="string">'scrapy.downloadermiddlewares.cookies.CookiesMiddleware'</span>: <span class="number">700</span>,</span><br><span class="line">    <span class="string">'scrapy.downloadermiddlewares.httpproxy.HttpProxyMiddleware'</span>: <span class="number">750</span>,</span><br><span class="line">    <span class="string">'scrapy.downloadermiddlewares.stats.DownloaderStats'</span>: <span class="number">850</span>,</span><br><span class="line">    <span class="string">'scrapy.downloadermiddlewares.httpcache.HttpCacheMiddleware'</span>: <span class="number">900</span>,</span><br><span class="line">    <span class="comment"># Downloader side</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是这个字典当中的键值是代表了调用的优先级，越小代表越靠近Scrapy引擎，数字越大越靠近Downloader，<strong>越小越先调用</strong>。</p><p>如果我们自己定义下载中间件要添加到项目中，要激活下载器中间件组件，将其加入到 DOWNLOADER_MIDDLEWARES 设置中。 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DOWNLOADER_MIDDLEWARES = &#123;</span><br><span class="line">   <span class="string">'mySpider.middlewares.MyspiderDownloaderMiddleware'</span>: <span class="number">543</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="核心方法"><a href="#核心方法" class="headerlink" title="核心方法"></a>核心方法</h4><p>每个中间件组件是一个定义了以下一个或多个方法的Python类 ，核的方法有下面三个：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">process_request(request, spider)</span><br><span class="line">process_response(request, response, spider)</span><br><span class="line">process_exception(request, exception, spider)</span><br></pre></td></tr></table></figure><h5 id="process-request-self-request-spider"><a href="#process-request-self-request-spider" class="headerlink" title="process_request(self, request, spider)"></a>process_request(self, request, spider)</h5><ul><li>当每个request通过下载中间件时，该方法被调用。</li><li>process_request() 必须返回以下其中之一：一个 None 、一个 Response 对象、一个 Request 对象或 raise IgnoreRequest:<ul><li>如果其返回 None ，Scrapy将继续处理该request，执行其他的中间件的相应方法，直到合适的下载器处理函数(download handler)被调用， 该request被执行(其response被下载)。</li><li>如果其返回 Response 对象，Scrapy将不会调用 任何 其他的 process_request() 或 process_exception() 方法，或相应地下载函数； 其将返回该response。 已安装的中间件的 process_response() 方法则会在每个response返回时被调用。</li><li>如果其返回 Request 对象，Scrapy则停止调用 process_request方法并重新调度返回的request。当新返回的request被执行后， 相应地中间件链将会根据下载的response被调用。</li><li>如果其raise一个 IgnoreRequest 异常，则安装的下载中间件的 process_exception() 方法会被调用。如果没有任何一个方法处理该异常， 则request的errback(Request.errback)方法会被调用。如果没有代码处理抛出的异常， 则该异常被忽略且不记录(不同于其他异常那样)。</li></ul></li><li>参数:<ul><li><code>request (Request 对象)</code> – 处理的request</li><li><code>spider (Spider 对象)</code> – 该request对应的spider</li></ul></li></ul><h5 id="process-response-self-request-response-spider"><a href="#process-response-self-request-response-spider" class="headerlink" title="process_response(self, request, response, spider)"></a>process_response(self, request, response, spider)</h5><ul><li><p>当下载器完成http请求，传递响应给引擎的时候调用</p></li><li><p>process_request() 必须返回以下其中之一: 返回一个 Response 对象、 返回一个 Request 对象或raise一个 IgnoreRequest 异常。</p><ul><li>如果其返回一个 Response (可以与传入的response相同，也可以是全新的对象)， 该response会被在链中的其他中间件的 process_response() 方法处理。</li><li>如果其返回一个 Request 对象，则中间件链停止， 返回的request会被重新调度下载。处理类似于 process_request() 返回request所做的那样。</li><li>如果其抛出一个 IgnoreRequest 异常，则调用request的errback(Request.errback)。 如果没有代码处理抛出的异常，则该异常被忽略且不记录(不同于其他异常那样)。</li></ul></li><li>参数:<ul><li><code>request (Request 对象)</code> – response所对应的request</li><li><code>response (Response 对象)</code> – 被处理的response</li><li><code>spider (Spider 对象)</code> – response所对应的spider</li></ul></li></ul><h5 id="process-exception-self-request-exception-spider"><a href="#process-exception-self-request-exception-spider" class="headerlink" title="process_exception(self, request, exception, spider)"></a>process_exception(self, request, exception, spider)</h5><ul><li>当Downloader或process_request()方法抛出异常时被调用</li><li>process_exception() 必须返回以下其中之一：None、Response对象、Request对象。<ul><li>如果返回None时，更低优先级的Downloader Middleware的process_exception()方法会被继续调用，直到所有的方法都被调用完毕。</li><li>如果返回为Response对象时，更低优先级的Downloader Middleware的process_exception()方法不再被继续调用，每个Downloader Middleware的 process_response()方法转而被依次调用。</li><li>如果返回为Request对象时，更低优先级的Downloader Middleware的process_exception()方法不再被继续调用，该 Request 对象会重新放到调度队列里面等待被调度，它相当于一个全新的 Request 。</li></ul></li></ul><h4 id="使用案例"><a href="#使用案例" class="headerlink" title="使用案例"></a>使用案例</h4><p>Scrapy代理IP、Uesr-Agent的切换都是通过<code>DOWNLOADER_MIDDLEWARES</code>进行控制，我们在<code>settings.py</code>同级目录下创建<code>middlewares.py</code>文件，包装所有请求 。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> fake_useragent <span class="keyword">import</span> UserAgent  <span class="comment"># 导入浏览器用户代理模块</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProxyMiddleware</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, proxy_url)</span>:</span></span><br><span class="line">        self.logger = logging.getLogger(__name__)</span><br><span class="line">        self.proxy_url = proxy_url</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_random_proxy</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            response = requests.get(self.proxy_url)</span><br><span class="line">            <span class="keyword">if</span> response.status_code == <span class="number">200</span>:</span><br><span class="line">                proxy = response.text</span><br><span class="line">                <span class="keyword">return</span> proxy</span><br><span class="line">        <span class="keyword">except</span> requests.ConnectionError:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_request</span><span class="params">(self, request, spider)</span>:</span></span><br><span class="line">        <span class="comment"># proxy = self.get_random_proxy()</span></span><br><span class="line">        proxy = <span class="string">'223.19.41.6:8197'</span></span><br><span class="line">        <span class="keyword">if</span> proxy:</span><br><span class="line">            uri = <span class="string">'https://&#123;proxy&#125;'</span>.format(proxy=proxy)</span><br><span class="line">            self.logger.debug(<span class="string">'使用代理 '</span> + proxy)</span><br><span class="line">            request.meta[<span class="string">'proxy'</span>] = uri</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">from_crawler</span><span class="params">(cls, crawler)</span>:</span></span><br><span class="line">        settings = crawler.settings</span><br><span class="line">        <span class="keyword">return</span> cls(</span><br><span class="line">            proxy_url=settings.get(<span class="string">'PROXY_URL'</span>)  <span class="comment"># PROXY_URL在settings中配置的代理池地址</span></span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RandomUserAgentMiddleware</span><span class="params">(object)</span>:</span>  <span class="comment"># 自定义浏览器代理中间件</span></span><br><span class="line">    <span class="comment"># 随机更换Requests请求头信息的User-Agent浏览器用户代理</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, crawler)</span>:</span></span><br><span class="line">        <span class="comment"># 获取上一级父类基类的，__init__方法里的对象封装值</span></span><br><span class="line">        super(RandomUserAgentMiddleware, self).__init__()</span><br><span class="line">        <span class="comment"># 实例化浏览器用户代理模块类</span></span><br><span class="line">        self.ua = UserAgent()</span><br><span class="line">        <span class="comment"># 获取settings.py配置文件里的RANDOM_UA_TYPE配置的浏览器类型，</span></span><br><span class="line">        <span class="comment"># 如果没有，默认random，随机获取各种浏览器类型</span></span><br><span class="line">        self.ua_type = crawler.settings.get(<span class="string">'RANDOM_UA_TYPE'</span>, <span class="string">'random'</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod  # 函数上面用上装饰符@classmethod，函数里有一个必写形式参数cls用来接收当前类名称</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">from_crawler</span><span class="params">(cls, crawler)</span>:</span>  <span class="comment"># 重载from_crawler方法</span></span><br><span class="line">        <span class="keyword">return</span> cls(crawler)  <span class="comment"># 将crawler爬虫返回给类</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_request</span><span class="params">(self, request, spider)</span>:</span>  <span class="comment"># 重载process_request方法</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">get_ua</span><span class="params">()</span>:</span>  <span class="comment"># 自定义函数，返回浏览器代理对象里指定类型的浏览器信息</span></span><br><span class="line">            <span class="keyword">return</span> getattr(self.ua, self.ua_type)</span><br><span class="line">        request.headers.setdefault(<span class="string">'User-Agent'</span>, get_ua())  <span class="comment"># 将浏览器代理信息添加到Requests请求</span></span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 爬虫 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 爬虫 </tag>
            
            <tag> Scrapy </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Scrapy 框架(四)之Spider</title>
      <link href="/post/1cfe1288.html"/>
      <url>/post/1cfe1288.html</url>
      <content type="html"><![CDATA[<h3 id="Spider"><a href="#Spider" class="headerlink" title="Spider"></a>Spider</h3><p>Spider类定义了如何爬取某个(或某些)网站。包括了爬取的动作(例如:是否跟进链接)以及如何从网页的内容中提取结构化数据(爬取item)。 换句话说，Spider就是您定义爬取的动作及分析某个网页(或者是有些网页)的地方。</p><p><code>class scrapy.Spider</code>是最基本的类，所有编写的爬虫必须继承这个类。</p><p>主要用到的函数及调用顺序为：</p><p><code>__init__()</code> : 初始化爬虫名字和start_urls列表</p><p><code>start_requests() 调用make_requests_from url()</code>:生成Requests对象交给Scrapy下载并返回response</p><p><code>parse()</code> : 解析response，并返回Item或Requests（需指定回调函数）。Item传给Item pipline持久化 ， 而Requests交由Scrapy下载，并由指定的回调函数处理（默认parse())，一直进行循环，直到处理完所有的数据为止。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 所有爬虫的基类，用户定义的爬虫必须从这个类继承</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Spider</span><span class="params">(object_ref)</span>:</span></span><br><span class="line">    <span class="comment"># 定义spider名字的字符串(string)。spider的名字定义了Scrapy如何定位(并初始化)spider，所以其必须是唯一的。</span></span><br><span class="line">    <span class="comment"># name是spider最重要的属性，而且是必须的。</span></span><br><span class="line">    <span class="comment"># 一般做法是以该网站(domain)(加或不加 后缀 )来命名spider。 例如，如果spider爬取 mywebsite.com ，该spider通常会被命名为 mywebsite</span></span><br><span class="line">    name = <span class="keyword">None</span></span><br><span class="line">    custom_settings = <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 初始化，提取爬虫名字，start_ruls</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name=None, **kwargs)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> name <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">            self.name = name</span><br><span class="line">        <span class="keyword">elif</span> <span class="keyword">not</span> getattr(self, <span class="string">'name'</span>, <span class="keyword">None</span>):</span><br><span class="line">            <span class="comment"># 如果爬虫没有名字，中断后续操作则报错</span></span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">"%s must have a name"</span> % type(self).__name__)</span><br><span class="line">        <span class="comment"># python 对象或类型通过内置成员__dict__来存储成员信息</span></span><br><span class="line">        self.__dict__.update(kwargs)</span><br><span class="line">        <span class="comment"># URL列表。当没有指定的URL时，spider将从该列表中开始进行爬取。 因此，第一个被获取到的页面的URL将是该列表之一。 后续的URL将会从获取到的数据中提取。</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> hasattr(self, <span class="string">'start_urls'</span>):</span><br><span class="line">            self.start_urls = []</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">logger</span><span class="params">(self)</span>:</span></span><br><span class="line">        logger = logging.getLogger(self.name)</span><br><span class="line">        <span class="keyword">return</span> logging.LoggerAdapter(logger, &#123;<span class="string">'spider'</span>: self&#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 打印Scrapy执行后的log信息</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">log</span><span class="params">(self, message, level=logging.DEBUG, **kw)</span>:</span></span><br><span class="line">        self.logger.log(level, message, **kw)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">from_crawler</span><span class="params">(cls, crawler, *args, **kwargs)</span>:</span></span><br><span class="line">        spider = cls(*args, **kwargs)</span><br><span class="line">        spider._set_crawler(crawler)</span><br><span class="line">        <span class="keyword">return</span> spider</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 判断对象object的属性是否存在，不存在做断言处理</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set_crawler</span><span class="params">(self, crawler)</span>:</span></span><br><span class="line">        warnings.warn(<span class="string">"set_crawler is deprecated, instantiate and bound the "</span></span><br><span class="line">                      <span class="string">"spider to this crawler with from_crawler method "</span></span><br><span class="line">                      <span class="string">"instead."</span>,</span><br><span class="line">                      category=ScrapyDeprecationWarning, stacklevel=<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">assert</span> <span class="keyword">not</span> hasattr(self, <span class="string">'crawler'</span>), <span class="string">"Spider already bounded to a "</span> \</span><br><span class="line">                                             <span class="string">"crawler"</span></span><br><span class="line">        self._set_crawler(crawler)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_set_crawler</span><span class="params">(self, crawler)</span>:</span></span><br><span class="line">        self.crawler = crawler</span><br><span class="line">        self.settings = crawler.settings</span><br><span class="line">        crawler.signals.connect(self.close, signals.spider_closed)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 该方法将读取start_urls内的地址，并为每一个地址生成一个Request对象，交给Scrapy下载并返回Response</span></span><br><span class="line">    <span class="comment"># 该方法仅调用一次</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">start_requests</span><span class="params">(self)</span>:</span></span><br><span class="line">        cls = self.__class__</span><br><span class="line">        <span class="keyword">if</span> method_is_overridden(cls, Spider, <span class="string">'make_requests_from_url'</span>):</span><br><span class="line">            warnings.warn(</span><br><span class="line">                <span class="string">"Spider.make_requests_from_url method is deprecated; it "</span></span><br><span class="line">                <span class="string">"won't be called in future Scrapy releases. Please "</span></span><br><span class="line">                <span class="string">"override Spider.start_requests method instead (see %s.%s)."</span> % (</span><br><span class="line">                    cls.__module__, cls.__name__</span><br><span class="line">                ),</span><br><span class="line">            )</span><br><span class="line">            <span class="keyword">for</span> url <span class="keyword">in</span> self.start_urls:</span><br><span class="line">                <span class="keyword">yield</span> self.make_requests_from_url(url)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">for</span> url <span class="keyword">in</span> self.start_urls:</span><br><span class="line">                <span class="keyword">yield</span> Request(url, dont_filter=<span class="keyword">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># start_requests()中调用，实际生成Request的函数。</span></span><br><span class="line">    <span class="comment"># Request对象默认的回调函数为parse()，提交的方式为get</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">make_requests_from_url</span><span class="params">(self, url)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> Request(url, dont_filter=<span class="keyword">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 默认的Request对象回调函数，处理返回的response。</span></span><br><span class="line">    <span class="comment"># 生成Item或者Request对象。用户必须实现这个类</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse</span><span class="params">(self, response)</span>:</span></span><br><span class="line">        <span class="keyword">raise</span> NotImplementedError(<span class="string">'&#123;&#125;.parse callback is not defined'</span>.format(self.__class__.__name__))</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">update_settings</span><span class="params">(cls, settings)</span>:</span></span><br><span class="line">        settings.setdict(cls.custom_settings <span class="keyword">or</span> &#123;&#125;, priority=<span class="string">'spider'</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">handles_request</span><span class="params">(cls, request)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> url_is_from_spider(request.url, cls)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">close</span><span class="params">(spider, reason)</span>:</span></span><br><span class="line">        closed = getattr(spider, <span class="string">'closed'</span>, <span class="keyword">None</span>)</span><br><span class="line">        <span class="keyword">if</span> callable(closed):</span><br><span class="line">            <span class="keyword">return</span> closed(reason)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"&lt;%s %r at 0x%0x&gt;"</span> % (type(self).__name__, self.name, id(self))</span><br><span class="line"></span><br><span class="line">    __repr__ = __str__</span><br></pre></td></tr></table></figure><h4 id="主要属性和方法"><a href="#主要属性和方法" class="headerlink" title="主要属性和方法"></a>主要属性和方法</h4><ul><li>name：爬虫名称，是定义 Spider 名字的字符串，Spider的名字定义了Scrapy如何定位(并初始化)Spider，所以其必须是唯一的。</li><li>allowed_domains：允许爬取的域名，是可选配置，不在此范围的链接不会被跟进爬取。</li><li>start_urls：是起始URL列表，当我们没有实现start_requests()方法时，默认会从这个列表开始抓取。</li><li>custom_settings：是一个字典，是专属于本 Spider 的配置，此设置会覆盖项目全局的设置。此设置必须在初始化前被更新，必须定义成类变量。</li><li>crawler：它是由 from_crawler()方法设置的，代表的是本 Spider 类对应的 Crawler 对象。Crawler对象包含了很多项目组件，利用它我们可以获取项目的一些配置信息，如最常见的获取项目的设置信息，即Settings</li><li>settings：一个Settings对象，利用它我们可以直接获取项目的全局设置变量。除了基础属性，Spider还有一些常用的方法。</li><li>start_requests()：此方法用于生成初始请求，它必须返回一个可迭代对象。此方法会默认使用start_urls里面的URL来构造Request，而且Request是GET请求方式。如果我们想在启动时以POST方式访问某个站点，可以直接重写这个方法，发送POST请求时使用FormRequest</li><li>parse()：当请求url返回网页没有指定回调函数时，默认的Request对象回调函数。用来处理网页返回的Response，处理返回结果，并从中提取出想要的数据和下一步的请求，然后返回。该方法需要返回一个包含Request或Item的可迭代对象。 </li><li>closed()：当Spider关闭时，该方法会被调用，在这里一般会定义释放资源的一些操作或其他收尾操作。</li></ul><h3 id="实例：腾讯招聘网自动翻页采集"><a href="#实例：腾讯招聘网自动翻页采集" class="headerlink" title="实例：腾讯招聘网自动翻页采集"></a>实例：腾讯招聘网自动翻页采集</h3><ul><li>创建一个新的爬虫：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scrapy genspider tencent &apos;tencent.com&apos;</span><br></pre></td></tr></table></figure><ul><li>编写items.py</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TencentItem</span><span class="params">(scrapy.Item)</span>:</span></span><br><span class="line">    name = scrapy.Field()</span><br><span class="line">    detailLink = scrapy.Field()</span><br><span class="line">    positionInfo = scrapy.Field()</span><br><span class="line">    peopleNumber = scrapy.Field()</span><br><span class="line">    workLocation = scrapy.Field()</span><br><span class="line">    publishTime = scrapy.Field()</span><br></pre></td></tr></table></figure><ul><li>编写tencent.py</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> scrapy</span><br><span class="line"><span class="keyword">from</span> scrapy <span class="keyword">import</span> Selector</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> mySpider.items <span class="keyword">import</span> TencentItem</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TencentSpider</span><span class="params">(scrapy.Spider)</span>:</span></span><br><span class="line">    name = <span class="string">'tencent'</span></span><br><span class="line">    allowed_domains = [<span class="string">'hr.tencent.com'</span>]</span><br><span class="line">    start_urls = [</span><br><span class="line">        <span class="string">'http://hr.tencent.com/position.php?&amp;start=0#a'</span></span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse</span><span class="params">(self, response)</span>:</span></span><br><span class="line">        res = Selector(response)</span><br><span class="line">        <span class="keyword">for</span> each <span class="keyword">in</span> res.xpath(<span class="string">'//*[@class="even"]'</span>):</span><br><span class="line">            item = MyspiderItem()</span><br><span class="line">            name = each.xpath(<span class="string">'./td[1]/a/text()'</span>).extract_first()</span><br><span class="line">            detailLink = each.xpath(<span class="string">'./td[1]/a/@href'</span>).extract_first()</span><br><span class="line">            positionInfo = each.xpath(<span class="string">'./td[2]/text()'</span>).extract_first()</span><br><span class="line">            peopleNumber = each.xpath(<span class="string">'./td[3]/text()'</span>).extract_first()</span><br><span class="line">            workLocation = each.xpath(<span class="string">'./td[4]/text()'</span>).extract_first()</span><br><span class="line">            publishTime = each.xpath(<span class="string">'./td[5]/text()'</span>).extract_first()</span><br><span class="line"></span><br><span class="line">            item[<span class="string">'name'</span>] = name</span><br><span class="line">            item[<span class="string">'detailLink'</span>] = detailLink</span><br><span class="line">            item[<span class="string">'positionInfo'</span>] = positionInfo</span><br><span class="line">            item[<span class="string">'peopleNumber'</span>] = peopleNumber</span><br><span class="line">            item[<span class="string">'workLocation'</span>] = workLocation</span><br><span class="line">            item[<span class="string">'publishTime'</span>] = publishTime</span><br><span class="line"></span><br><span class="line">            curpage = re.search(<span class="string">'(\d+)'</span>, response.url).group(<span class="number">1</span>)</span><br><span class="line">            page = int(curpage) + <span class="number">10</span></span><br><span class="line">            url = re.sub(<span class="string">'\d+'</span>, str(page), response.url)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 发送新的url请求加入待爬队列，并调用回调函数 self.parse</span></span><br><span class="line">            <span class="keyword">yield</span> scrapy.Request(url, callback=self.parse)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 将获取的数据交给pipeline</span></span><br><span class="line">            <span class="keyword">yield</span> item</span><br></pre></td></tr></table></figure><ul><li>编写pipeline.py文件</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TencentJsonPipeline</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.file = open(<span class="string">'tencent.json'</span>, <span class="string">'w'</span>, encoding=<span class="string">'utf-8'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_item</span><span class="params">(self, item, spider)</span>:</span></span><br><span class="line">        content = json.dumps(dict(item), ensure_ascii=<span class="keyword">False</span>) + <span class="string">"\n"</span></span><br><span class="line">        self.file.write(content)</span><br><span class="line">        <span class="keyword">return</span> item</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">close_spider</span><span class="params">(self, spider)</span>:</span></span><br><span class="line">        self.file.close()</span><br></pre></td></tr></table></figure><ul><li>在 setting.py 里设置ITEM_PIPELINES</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ITEM_PIPELINES = &#123;</span><br><span class="line">   &apos;mySpider.pipelines.TencentJsonPipeline&apos;: 300,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>parse()方法的工作机制：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1. 因为使用的yield，而不是return。parse函数将会被当做一个生成器使用。scrapy会逐一获取parse方法中生成的结果，并判断该结果是一个什么样的类型；</span><br><span class="line">2. 如果是request则加入爬取队列，如果是item类型则使用pipeline处理，其他类型则返回错误信息；</span><br><span class="line">3. scrapy取到第一部分的request不会立马就去发送这个request，只是把这个request放到队列里，然后接着从生成器里获取；</span><br><span class="line">4. 取尽第一部分的request，然后再获取第二部分的item，取到item了，就会放到对应的pipeline里处理；</span><br><span class="line">5. parse()方法作为回调函数(callback)赋值给了Request，指定parse()方法来处理这些请求 scrapy.Request(url, callback=self.parse)</span><br><span class="line">6. Request对象经过调度，执行生成 scrapy.http.response()的响应对象，并送回给parse()方法，直到调度器中没有Request（递归的思路）；</span><br><span class="line">7. 取尽之后，parse()工作结束，引擎再根据队列和pipelines中的内容去执行相应的操作；</span><br><span class="line">8. 程序在取得各个页面的items前，会先处理完之前所有的request队列里的请求，然后再提取items；</span><br><span class="line">7. 这一切的一切，Scrapy引擎和调度器将负责到底。</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 爬虫 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 爬虫 </tag>
            
            <tag> Scrapy </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Scrapy 框架(三)之Item Pipeline</title>
      <link href="/post/ae0bd4cd.html"/>
      <url>/post/ae0bd4cd.html</url>
      <content type="html"><![CDATA[<h3 id="Item-Pipeline"><a href="#Item-Pipeline" class="headerlink" title="Item Pipeline"></a>Item Pipeline</h3><p>当Item在Spider中被收集之后，它将会被传递到Item Pipeline，这些Item Pipeline组件按定义的顺序处理Item。</p><p>每个Item Pipeline都是实现了简单方法的Python类，比如决定此Item是丢弃还是存储。以下是Item Pipeline的一些典型应用：</p><ul><li>验证爬取的数据(检查item包含某些字段，比如说name字段)</li><li>查重(并丢弃)</li><li>将爬取结果保存到文件或者数据库中</li><li>清理HTML数据</li></ul><h4 id="编写Item-Pipeline"><a href="#编写Item-Pipeline" class="headerlink" title="编写Item Pipeline"></a>编写Item Pipeline</h4><p>编写item pipeline很简单，item pipiline组件是一个独立的Python类，其中process_item()方法必须实现，另外还有几个比较实用的方法：open_spider()、close_spider()、from_crawler()</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomethingPipeline</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span>    </span><br><span class="line">        <span class="comment"># 可选实现，做参数初始化等</span></span><br><span class="line">    </span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">from_crawler</span><span class="params">(cls, crawler)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> cls()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_item</span><span class="params">(self, item, spider)</span>:</span></span><br><span class="line">        <span class="comment"># item (Item 对象) – 被爬取的item</span></span><br><span class="line">        <span class="comment"># spider (Spider 对象) – 爬取该item的spider</span></span><br><span class="line">        <span class="comment"># 这个方法必须实现，每个item pipeline组件都需要调用该方法，</span></span><br><span class="line">        <span class="comment"># 这个方法必须返回一个 Item 对象，被丢弃的item将不会被之后的pipeline组件所处理。</span></span><br><span class="line">        <span class="keyword">return</span> item</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">open_spider</span><span class="params">(self, spider)</span>:</span></span><br><span class="line">        <span class="comment"># spider (Spider 对象) – 被开启的spider</span></span><br><span class="line">        <span class="comment"># 可选实现，当spider被开启时，这个方法被调用。</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">close_spider</span><span class="params">(self, spider)</span>:</span></span><br><span class="line">        <span class="comment"># spider (Spider 对象) – 被关闭的spider</span></span><br><span class="line">        <span class="comment"># 可选实现，当spider被关闭时，这个方法被调用</span></span><br></pre></td></tr></table></figure><ul><li><p>process_item(self, item, spider)：是必须要实现的方法，被定义的 Item Pipeline 会默认调用这个方法对 Item 进行处理。比如，我们可以进行数据处理或者将数据写入到数据库等操作。它必须返回 Item 类型的值或者抛出一个 DropItem 异常。</p><ul><li>item：是 Item 对象，即被处理的 Item。</li><li>spider：是Spider对象，即生成该Item的Spider。</li></ul><p>如果它返回的是Item对象，那么此Item会被低优先级的Item Pipeline的process_item()方法处理，直到所有的方法被调用完毕。</p><p>如果它抛出的是DropItem异常，那么此Item会被丢弃，不再进行处理。</p></li><li><p>open_spider(self, spider)：open_spider()方法是在Spider开启的时候被自动调用的，在这里我们可以做一些初始化操作，如开启数据库连接等。</p><ul><li>spider：是被开启的Spider对象。</li></ul></li><li><p>close_spider(self, spider)：close_spider()方法是在Spider关闭的时候自动调用的，在这里我们可以做一些收尾工作，比如关闭数据库连接等。</p><ul><li>spider：是被关闭的Spider对象。</li></ul></li><li><p>from_crawler(cls, crawler)：from_crawler()方法是一个类方法，用@classmethod标识，是一种依赖注入的方式。</p><ul><li>cls：就是Class，返回一个Class实例。</li><li>crawler：通过crawler对象，我们可以拿到Scrapy的所有核心组件，如全局配置的每个信息，然后创建一个Pipeline实例。</li></ul></li></ul><h4 id="启用一个Item-Pipeline组件"><a href="#启用一个Item-Pipeline组件" class="headerlink" title="启用一个Item Pipeline组件"></a>启用一个Item Pipeline组件</h4><p>为了启用Item Pipeline组件，必须将它的类添加到 settings.py文件ITEM_PIPELINES 配置，就像下面这个例子: </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># See https://doc.scrapy.org/en/latest/topics/item-pipeline.html</span></span><br><span class="line"><span class="comment">#ITEM_PIPELINES = &#123;</span></span><br><span class="line">    <span class="string">'mySpider.pipelines.MyspiderPipeline'</span>: <span class="number">300</span>,</span><br><span class="line"><span class="comment">#&#125;</span></span><br></pre></td></tr></table></figure><p>分配给每个类的整型值，确定了他们运行的顺序，item按数字从低到高的顺序，通过pipeline，通常将这些数字定义在0-1000范围内（0-1000随意设置，数值越低，组件的优先级越高） </p>]]></content>
      
      <categories>
          
          <category> 爬虫 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 爬虫 </tag>
            
            <tag> Scrapy </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Scrapy 框架(二)之Scrapy Shell</title>
      <link href="/post/a9fd3a36.html"/>
      <url>/post/a9fd3a36.html</url>
      <content type="html"><![CDATA[<h3 id="Scrapy-Shell"><a href="#Scrapy-Shell" class="headerlink" title="Scrapy Shell"></a>Scrapy Shell</h3><p>Scrapy终端是一个交互终端，我们可以在未启动spider的情况下尝试及调试代码，也可以用来测试XPath或CSS表达式，查看他们的工作方式，方便我们爬取的网页中提取的数据。 </p><h3 id="启动Scrapy-Shell"><a href="#启动Scrapy-Shell" class="headerlink" title="启动Scrapy Shell"></a>启动Scrapy Shell</h3><p>进入项目的根目录，执行下列命令来启动shell:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scrapy shell &quot;http://hr.tencent.com/position.php?&amp;start=0#a&quot;</span><br></pre></td></tr></table></figure><p><img src="../img/spider/20180725180430.png" alt="img"></p><p>Scrapy Shell根据下载的页面会自动创建一些方便使用的对象，例如 Response 对象，以及 <code>Selector 对象 (对HTML及XML内容)</code>。</p><ul><li>当shell载入后，将得到一个包含response数据的本地 response 变量，输入 <code>response.body</code>将输出response的包体，输出 <code>response.headers</code> 可以看到response的包头。</li><li>输入 <code>response.selector</code> 时， 将获取到一个response 初始化的类 Selector 的对象，此时可以通过使用 <code>response.selector.xpath()</code>或<code>response.selector.css()</code> 来对 response 进行查询。</li><li>Scrapy也提供了一些快捷方式, 例如 <code>response.xpath()</code>或<code>response.css()</code>同样可以生效。</li></ul><h3 id="Selectors选择器"><a href="#Selectors选择器" class="headerlink" title="Selectors选择器"></a>Selectors选择器</h3><blockquote><p>Scrapy Selectors 内置 XPath 和 CSS Selector 表达式机制</p></blockquote><p>Selector有四个基本的方法，最常用的还是xpath:</p><ul><li>xpath(): 传入xpath表达式，返回该表达式所对应的所有节点的selector list列表</li><li>extract(): 序列化该节点为Unicode字符串并返回list</li><li>css(): 传入CSS表达式，返回该表达式所对应的所有节点的selector list列表，语法同 BeautifulSoup4</li><li>re(): 根据传入的正则表达式对数据进行提取，返回Unicode字符串list列表</li></ul><h4 id="XPath表达式的例子及对应的含义"><a href="#XPath表达式的例子及对应的含义" class="headerlink" title="XPath表达式的例子及对应的含义:"></a>XPath表达式的例子及对应的含义:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/html/head/title: 选择&lt;HTML&gt;文档中 &lt;head&gt; 标签内的 &lt;title&gt; 元素</span><br><span class="line">/html/head/title/text(): 选择上面提到的 &lt;title&gt; 元素的文字</span><br><span class="line">//td: 选择所有的 &lt;td&gt; 元素</span><br><span class="line">//div[@class=&quot;mine&quot;]: 选择所有具有 class=&quot;mine&quot; 属性的 div 元素</span><br></pre></td></tr></table></figure><h4 id="尝试Selector"><a href="#尝试Selector" class="headerlink" title="尝试Selector"></a>尝试Selector</h4><p>我们用腾讯社招的网站<a href="http://hr.tencent.com/position.php?&amp;start=0#a" target="_blank" rel="noopener">http://hr.tencent.com/position.php?&amp;start=0#a</a>举例： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># 启动</span><br><span class="line">scrapy shell &quot;http://hr.tencent.com/position.php?&amp;start=0#a&quot;</span><br><span class="line"></span><br><span class="line"># 返回 xpath选择器对象列表</span><br><span class="line">response.xpath(&apos;//title&apos;)</span><br><span class="line"># [&lt;Selector xpath=&apos;//title&apos; data=&apos;&lt;title&gt;职位搜索 | 社会招聘 | Tencent 腾讯招聘&lt;/title&apos;&gt;]</span><br><span class="line"></span><br><span class="line"># 使用 extract()方法返回字符串列表</span><br><span class="line">response.xpath(&apos;//title&apos;).extract()</span><br><span class="line"># [&apos;&lt;title&gt;职位搜索 | 社会招聘 | Tencent 腾讯招聘&lt;/title&gt;&apos;]</span><br><span class="line"></span><br><span class="line"># 打印列表第一个元素</span><br><span class="line">print(response.xpath(&apos;//title&apos;).extract()[0])</span><br><span class="line"># &lt;title&gt;职位搜索 | 社会招聘 | Tencent 腾讯招聘&lt;/title&gt;</span><br><span class="line">print(response.xpath(&apos;//title&apos;).extract_first())</span><br><span class="line"># &lt;title&gt;职位搜索 | 社会招聘 | Tencent 腾讯招聘&lt;/title&gt;</span><br><span class="line"></span><br><span class="line"># 返回 xpath选择器对象列表</span><br><span class="line">response.xpath(&apos;//title/text()&apos;)</span><br><span class="line"># [&lt;Selector xpath=&apos;//title/text()&apos; data=&apos;职位搜索 | 社会招聘 | Tencent 腾讯招聘&apos;&gt;]</span><br></pre></td></tr></table></figure><p>以后做数据提取的时候，可以把现在Scrapy Shell中测试，测试通过后再应用到代码中。 </p>]]></content>
      
      <categories>
          
          <category> 爬虫 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 爬虫 </tag>
            
            <tag> Scrapy </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Scrapy 框架(一)之简单入门</title>
      <link href="/post/eb531509.html"/>
      <url>/post/eb531509.html</url>
      <content type="html"><![CDATA[<p>很长时间不用Scrapy框架，都快忘记应该怎么使用了，重拾Scrapy我复习了两天，把这两天的成果写成文章，供以后查阅</p><h2 id="Scrapy-框架"><a href="#Scrapy-框架" class="headerlink" title="Scrapy 框架"></a>Scrapy 框架</h2><ul><li>Scrapy是用纯Python实现一个为了爬取网站数据、提取结构性数据而编写的应用框架，用途非常广泛。</li><li>框架的力量，用户只需要定制开发几个模块就可以轻松的实现一个爬虫，用来抓取网页内容以及各种图片，非常之方便。</li><li>Scrapy 使用了 Twisted<code>[&#39;twɪstɪd]</code>(其主要对手是Tornado)异步网络框架来处理网络通讯，可以加快我们的下载速度，不用自己去实现异步框架，并且包含了各种中间件接口，可以灵活的完成各种需求。</li></ul><h3 id="Scrapy架构图"><a href="#Scrapy架构图" class="headerlink" title="Scrapy架构图"></a>Scrapy架构图</h3><blockquote><p><strong>注意：</strong>绿线是数据流向</p></blockquote><p><img src="../img/spider/scrapy_all.png" alt="img"></p><ul><li><code>Scrapy Engine(引擎)</code>: 负责<code>Spider</code>、<code>ItemPipeline</code>、<code>Downloader</code>、<code>Scheduler</code>中间的通讯，信号、数据传递等。</li><li><code>Scheduler(调度器)</code>: 它负责接受<code>引擎</code>发送过来的Request请求，并按照一定的方式进行整理排列，入队，当<code>引擎</code>需要时，交还给<code>引擎</code>。</li><li><code>Downloader（下载器）</code>：负责下载<code>Scrapy Engine(引擎)</code>发送的所有Requests请求，并将其获取到的Responses交还给<code>Scrapy Engine(引擎)</code>，由<code>引擎</code>交给<code>Spider</code>来处理，</li><li><code>Spider（爬虫）</code>：它负责处理所有Responses,从中分析提取数据，获取Item字段需要的数据，并将需要跟进的URL提交给<code>引擎</code>，再次进入<code>Scheduler(调度器)</code>，</li><li><code>Item Pipeline(管道)</code>：它负责处理<code>Spider</code>中获取到的Item，并进行进行后期处理（详细分析、过滤、存储等）的地方.</li><li><code>Downloader Middlewares（下载中间件）</code>：你可以当作是一个可以自定义扩展下载功能的组件。</li><li><code>Spider Middlewares（Spider中间件）</code>：你可以理解为是一个可以自定扩展和操作<code>引擎</code>和<code>Spider</code>中间<code>通信</code>的功能组件（比如进入<code>Spider</code>的Responses;和从<code>Spider</code>出去的Requests）</li></ul><h3 id="Scrapy的运作流程-我认为这是重点重点重点"><a href="#Scrapy的运作流程-我认为这是重点重点重点" class="headerlink" title="Scrapy的运作流程(我认为这是重点重点重点)"></a>Scrapy的运作流程(我认为这是重点重点重点)</h3><p>代码写好，程序开始运行…</p><ol><li><code>引擎</code>：Hi！<code>Spider</code>, 你要处理哪一个网站？</li><li><code>Spider</code>：老大要我处理xxxx.com。</li><li><code>引擎</code>：你把第一个需要处理的URL给我吧。</li><li><code>Spider</code>：给你，第一个URL是xxxx.com。</li><li><code>引擎</code>：Hi！<code>调度器</code>，我这有request请求你帮我排序入队一下。</li><li><code>调度器</code>：好的，正在处理你等一下。</li><li><code>引擎</code>：Hi！<code>调度器</code>，把你处理好的request请求给我。</li><li><code>调度器</code>：给你，这是我处理好的request</li><li><code>引擎</code>：Hi！下载器，你按照老大的<code>下载中间件</code>的设置帮我下载一下这个request请求</li><li><code>下载器</code>：好的！给你，这是下载好的东西。（如果失败：sorry，这个request下载失败了。然后<code>引擎</code>告诉<code>调度器</code>，这个request下载失败了，你记录一下，我们待会儿再下载）</li><li><code>引擎</code>：Hi！<code>Spider</code>，这是下载好的东西，并且已经按照老大的<code>下载中间件</code>处理过了，你自己处理一下（注意！这儿responses默认是交给<code>def parse()</code>这个函数处理的）</li><li><code>Spider</code>：（处理完毕数据之后对于需要跟进的URL），Hi！<code>引擎</code>，我这里有两个结果，这个是我需要跟进的URL，还有这个是我获取到的Item数据。</li><li><code>引擎</code>：Hi ！<code>管道</code> 我这儿有个item你帮我处理一下！<code>调度器</code>！这是需要跟进URL你帮我处理下。然后从第四步开始循环，直到获取完老大需要全部信息。</li><li><code>管道``调度器</code>：好的，现在就做！</li></ol><p><strong>注意！只有当调度器中不存在任何request了，整个程序才会停止，（也就是说，对于下载失败的URL，Scrapy也会重新下载。）</strong></p><h3 id="Scrapy的配置安装"><a href="#Scrapy的配置安装" class="headerlink" title="Scrapy的配置安装"></a>Scrapy的配置安装</h3><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install Scrapy</span><br></pre></td></tr></table></figure><p>安装过程中会安装如下一些包，在之前的安装过程中，偶尔会出现Twisted失败的话，需要自己手动去安装。</p><p><img src="../img/spider/spider_scrapy_pip.png" alt="img"></p><p>在此也先安装另外一个必备的包pywin32，如果不安装该包的话，在运行爬虫的时候可能会提示<strong>“ModuleNotFoundError: No module named ‘win32api’”</strong>，因为Python没有自带访问windows系统API的库的，需要下载第三方库。库的名称叫pywin32。可以去网站上下载，<a href="https://sourceforge.net/projects/pywin32/files/pywin32/Build%20221/" target="_blank" rel="noopener">下载地址</a> </p><p><img src="../img/spider/scrapy_win32api.png" alt="img"></p><p>按照自己电脑上的python版本，进行下载安装。安装的时候，先进入虚拟环境中，然后执行easy_install pywin32-221.win-amd64-py3.6.exe 命令即可将包安装在我们当前的虚拟环境中了。 </p><p><img src="../img/spider/easyinstall_win32api.png" alt="img"></p><p><strong>具体Scrapy安装流程参考：<a href="http://doc.scrapy.org/en/latest/intro/install.html#intro-install-platform-notes" target="_blank" rel="noopener">http://doc.scrapy.org/en/latest/intro/install.html#intro-install-platform-notes</a> 里面有各个平台的安装方法</strong></p><h4 id="简单Scrapy-爬虫-一共需要4步："><a href="#简单Scrapy-爬虫-一共需要4步：" class="headerlink" title="简单Scrapy 爬虫 一共需要4步："></a>简单Scrapy 爬虫 一共需要4步：</h4><ul><li>新建项目 (scrapy startproject xxx)：新建一个新的爬虫项目</li><li>明确目标 （编写items.py）：明确你想要抓取的目标</li><li>制作爬虫 （spiders/xxspider.py）：制作爬虫开始爬取网页</li><li>存储内容 （pipelines.py）：设计管道存储爬取内容</li></ul><h3 id="入门案例"><a href="#入门案例" class="headerlink" title="入门案例"></a>入门案例</h3><h4 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h4><ul><li>在开始爬取之前，必须创建一个新的Scrapy项目。进入自定义的项目目录中，运行下列命令：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scrapy startproject mySpider</span><br></pre></td></tr></table></figure><ul><li>其中， mySpider 为项目名称，可以看到将会创建一个 mySpider 文件夹，目录结构大致如下：</li></ul><p><img src="../img/spider/7.2.png" alt="img"></p><p>下面来简单介绍一下各个主要文件的作用：</p><blockquote><p>scrapy.cfg ：项目的配置文件，主要为Scrapy命令行工具提供一个基础的配置信息。（真正爬虫相关的配置信息在settings.py文件中） </p><p>mySpider/ ：项目的Python模块，将会从这里引用代码</p><p>mySpider/items.py ：设置数据存储模板，用于结构化数据，如：Django的Model </p><p>mySpider/pipelines.py ：项目的管道文件</p><p>mySpider/settings.py ：项目的设置文件</p><p>mySpider/spiders/ ：存储爬虫代码目录</p></blockquote><h4 id="制作爬虫"><a href="#制作爬虫" class="headerlink" title="制作爬虫"></a>制作爬虫</h4><ul><li>在当前目录下输入命令，将在<code>mySpider/spider</code>目录下创建一个名为<code>qidian</code>的爬虫，并指定爬取域的范围：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scrapy genspider qidian www.qidian.com</span><br></pre></td></tr></table></figure><ul><li>打开 mySpider/spider目录里的 qidian.py，默认增加了下列代码:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import scrapy</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class QidianSpider(scrapy.Spider):</span><br><span class="line">    name = &apos;qidian&apos;</span><br><span class="line">    allowed_domains = [&apos;www.qidian.com&apos;]</span><br><span class="line">    start_urls = [&apos;http://www.qidian.com/&apos;]</span><br><span class="line"></span><br><span class="line">    def parse(self, response):</span><br><span class="line">        pass</span><br></pre></td></tr></table></figure><blockquote><p><strong>其实也可以由我们自行创建qidian.py并编写上面的代码，只不过使用命令可以免去编写固定代码的麻烦</strong></p></blockquote><p>要建立一个Spider， 你必须用scrapy.Spider类创建一个子类，并确定了三个强制的属性 和 一个方法。</p><ul><li><code>name = &quot;&quot;</code> ：这个爬虫的识别名称，必须是唯一的，在不同的爬虫必须定义不同的名字。</li><li><code>allow_domains = []</code> 是搜索的域名范围，也就是爬虫的约束区域，规定爬虫只爬取这个域名下的网页，不存在的URL会被忽略。</li><li><code>start_urls = []</code> ：爬取的URL元祖/列表。爬虫从这里开始抓取数据，所以，第一次下载的数据将会从这些urls开始。其他子URL将会从这些起始URL中继承性生成。</li><li><code>parse(self, response)</code> ：解析的方法，每个初始URL完成下载后将被调用，调用的时候传入从每一个URL传回的Response对象来作为唯一参数，主要作用如下：<ol><li>负责解析返回的网页数据(response.body)，提取结构化数据(生成item)</li><li>生成需要下一页的URL请求。</li></ol></li></ul><h5 id="将start-urls的值修改为需要爬取的第一个url"><a href="#将start-urls的值修改为需要爬取的第一个url" class="headerlink" title="将start_urls的值修改为需要爬取的第一个url"></a>将start_urls的值修改为需要爬取的第一个url</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">start_urls = [&apos;http://www.qidian.com/&apos;]</span><br></pre></td></tr></table></figure><h5 id="修改parse-方法"><a href="#修改parse-方法" class="headerlink" title="修改parse()方法"></a>修改parse()方法</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">def parse(self, response):</span><br><span class="line">    # 爬取时请求的url</span><br><span class="line">    current_url = response.url</span><br><span class="line"></span><br><span class="line">    # 返回的html</span><br><span class="line">    body = response.body</span><br><span class="line"></span><br><span class="line">    # 返回的html unicode编码</span><br><span class="line">    unicode_body = response.body_as_unicode()</span><br><span class="line">    res = Selector(response)</span><br><span class="line"></span><br><span class="line">    # 获取小说的分类信息</span><br><span class="line">    xiaoshuo_type = res.xpath(&apos;//*[@id=&quot;pin-nav&quot;]/div/div[1]/ul/li/a/text()&apos;).extract()</span><br><span class="line"></span><br><span class="line">    xiaoshuo_href = res.xpath(&apos;//*[@id=&quot;pin-nav&quot;]/div/div[1]/ul/li/a/@href&apos;).extract()</span><br><span class="line"></span><br><span class="line">    print(xiaoshuo_type, xiaoshuo_href)</span><br></pre></td></tr></table></figure><p>然后运行一下看看，在mySpider目录下执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scrapy crawl qidian</span><br></pre></td></tr></table></figure><p>是的，就是 qidian，看上面代码，它是 QidianSpider类的 name 属性，也就是使用 <code>scrapy genspider</code>命令的唯一爬虫名。</p><p>运行之后，如果打印的日志出现 <code>[scrapy] INFO: Spider closed (finished)</code>，代表执行完成。</p><p>执行流程：</p><blockquote><p>name: spider对应不同的name</p><p>start_urls:是spider抓取网页的起始点，可以包括多个url。</p><p>parse()：spider抓到一个网页以后默认调用的callback，避免使用这个名字来定义自己的方法。当spider拿到url的内容以后，会调用parse方法，并且传递一个response参数给它，response包含了抓到的网页的内容，在parse方法里，你可以从抓到的网页里面解析数据。</p></blockquote><p>运行结果：</p><p><img src="../img/spider/scrapy_qidian_type.png" alt=""></p>]]></content>
      
      <categories>
          
          <category> 爬虫 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 爬虫 </tag>
            
            <tag> Scrapy </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>爬虫糗事百科实例</title>
      <link href="/post/f825a662.html"/>
      <url>/post/f825a662.html</url>
      <content type="html"><![CDATA[<h2 id="糗事百科实例："><a href="#糗事百科实例：" class="headerlink" title="糗事百科实例："></a>糗事百科实例：</h2><p>爬取糗事百科段子，假设页面的URL是 <a href="http://www.qiushibaike.com/8hr/page/1" target="_blank" rel="noopener">http://www.qiushibaike.com/8hr/page/1</a></p><h3 id="要求："><a href="#要求：" class="headerlink" title="要求："></a>要求：</h3><ol><li>使用requests获取页面信息，用XPath / re 做数据提取</li><li>获取每个帖子里的<code>用户头像链接</code>、<code>用户姓名</code>、<code>段子内容</code>、<code>点赞次数</code>和<code>评论次数</code></li><li>保存到 json 文件内</li></ol><h3 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line"></span><br><span class="line">page = <span class="number">1</span></span><br><span class="line">url = <span class="string">'http://www.qiushibaike.com/8hr/page/'</span> + str(page)</span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">'User-Agent'</span>: <span class="string">'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/52.0.2743.116 Safari/537.36'</span>,</span><br><span class="line">    <span class="string">'Accept-Language'</span>: <span class="string">'zh-CN,zh;q=0.8'</span>&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_page</span><span class="params">()</span>:</span></span><br><span class="line">    response = requests.get(url, headers=headers)</span><br><span class="line">    <span class="comment"># response.encoding = response.apparent_encoding</span></span><br><span class="line">    <span class="keyword">if</span> response.status_code == <span class="number">200</span>:</span><br><span class="line">        <span class="keyword">return</span> response.text</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse</span><span class="params">()</span>:</span></span><br><span class="line">    resHtml = get_page()</span><br><span class="line">    <span class="keyword">if</span> resHtml <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    html = etree.HTML(resHtml)</span><br><span class="line">    result = html.xpath(<span class="string">'//div[contains(@id,"qiushi_tag")]'</span>)</span><br><span class="line">    items = []</span><br><span class="line">    <span class="keyword">for</span> site <span class="keyword">in</span> result:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            item = &#123;&#125;</span><br><span class="line"></span><br><span class="line">            imgurl = site.xpath(<span class="string">'./div/a/img/@src'</span>)[<span class="number">0</span>]</span><br><span class="line">            <span class="comment"># username = site.xpath('./div/a/@title')[0]</span></span><br><span class="line">            username = site.xpath(<span class="string">'.//h2'</span>)[<span class="number">0</span>].text</span><br><span class="line">            content = site.xpath(<span class="string">'.//div[@class="content"]/span'</span>)[<span class="number">0</span>].text.strip()</span><br><span class="line">            <span class="comment"># 投票次数</span></span><br><span class="line">            vote = site.xpath(<span class="string">'.//i'</span>)[<span class="number">0</span>].text</span><br><span class="line">            <span class="comment"># print site.xpath('.//*[@class="number"]')[0].text</span></span><br><span class="line">            <span class="comment"># 评论信息</span></span><br><span class="line">            comments = site.xpath(<span class="string">'.//i'</span>)[<span class="number">1</span>].text</span><br><span class="line"></span><br><span class="line">            item[<span class="string">'imgurl'</span>] = imgurl</span><br><span class="line">            item[<span class="string">'username'</span>] = username</span><br><span class="line">            item[<span class="string">'content'</span>] = content</span><br><span class="line">            item[<span class="string">'vote'</span>] = vote</span><br><span class="line">            item[<span class="string">'comments'</span>] = comments</span><br><span class="line">            print(imgurl, username, content, vote, comments)</span><br><span class="line">            items.append(item)</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            print(e)</span><br><span class="line">    <span class="keyword">return</span> items</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">save_items</span><span class="params">(items)</span>:</span></span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">'qiushibaike.json'</span>, <span class="string">'w'</span>, encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(json.dumps(items))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    items = parse()</span><br><span class="line">    save_items(items)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 爬虫 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>BeautifulSoup实例</title>
      <link href="/post/f484e02f.html"/>
      <url>/post/f484e02f.html</url>
      <content type="html"><![CDATA[<p>前面我们已经简单的使用BeautifulSoup，接下来我们以腾讯社招页面来做演示：<a href="https://hr.tencent.com/position.php?&amp;start=10#a" target="_blank" rel="noopener">https://hr.tencent.com/position.php?&amp;start=10#a</a></p><p>使用BeautifuSoup4解析器，将招聘网页上的职位名称、职位类别、招聘人数、工作地点、发布时间，以及每个职位详情的点击链接存储出来。 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"><span class="keyword">import</span> json  <span class="comment"># 使用了json格式存储</span></span><br><span class="line"></span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">'User-Agent'</span>: <span class="string">'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/52.0.2743.116 Safari/537.36'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">tencent</span><span class="params">()</span>:</span></span><br><span class="line">    url = <span class="string">'https://hr.tencent.com/position.php?&amp;start=10#a'</span></span><br><span class="line">    response = requests.get(url, headers=headers)</span><br><span class="line">    html = response.text</span><br><span class="line"></span><br><span class="line">    html = BeautifulSoup(html, <span class="string">'lxml'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建CSS选择器</span></span><br><span class="line">    result = html.select(<span class="string">'tr[class="even"]'</span>)</span><br><span class="line">    result2 = html.select(<span class="string">'tr[class="odd"]'</span>)</span><br><span class="line">    result += result2</span><br><span class="line"></span><br><span class="line">    items = []</span><br><span class="line">    <span class="keyword">for</span> site <span class="keyword">in</span> result:</span><br><span class="line">        item = &#123;&#125;</span><br><span class="line"></span><br><span class="line">        name = site.select(<span class="string">'td a'</span>)[<span class="number">0</span>].get_text()</span><br><span class="line">        detailLink = site.select(<span class="string">'td a'</span>)[<span class="number">0</span>].attrs[<span class="string">'href'</span>]</span><br><span class="line">        catalog = site.select(<span class="string">'td'</span>)[<span class="number">1</span>].get_text()</span><br><span class="line">        recruitNumber = site.select(<span class="string">'td'</span>)[<span class="number">2</span>].get_text()</span><br><span class="line">        workLocation = site.select(<span class="string">'td'</span>)[<span class="number">3</span>].get_text()</span><br><span class="line">        publishTime = site.select(<span class="string">'td'</span>)[<span class="number">4</span>].get_text()</span><br><span class="line"></span><br><span class="line">        item[<span class="string">'name'</span>] = name</span><br><span class="line">        item[<span class="string">'detailLink'</span>] = url + detailLink</span><br><span class="line">        item[<span class="string">'catalog'</span>] = catalog</span><br><span class="line">        item[<span class="string">'recruitNumber'</span>] = recruitNumber</span><br><span class="line">        item[<span class="string">'publishTime'</span>] = publishTime</span><br><span class="line"></span><br><span class="line">        items.append(item)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 禁用ascii编码，按utf-8编码</span></span><br><span class="line">    line = json.dumps(items, ensure_ascii=<span class="keyword">False</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">'tencent.json'</span>, <span class="string">'w'</span>, encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(line)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    tencent()</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 爬虫 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 爬虫 </tag>
            
            <tag> BeautifulSoup </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>BeautifulSoup的使用</title>
      <link href="/post/cd406da8.html"/>
      <url>/post/cd406da8.html</url>
      <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>今天介绍一个强大的解析工具，叫做 BeautiSoup，它就是借助网页的结构和属性等特性来解析网页的工具，有了它我们不用再去写一些复杂的正则，只需要简单的几条语句就可以完成网页中某个元素的提取。 </p><p>在<a href="https://germey.gitbooks.io/python3webspider/4.2-BeautifulSoup%E7%9A%84%E4%BD%BF%E7%94%A8.html" target="_blank" rel="noopener">崔庆才</a>老师那里找了一遍很详细的BeautifulSoup的使用</p><blockquote><p>原文地址：<a href="https://germey.gitbooks.io/python3webspider/4.2-BeautifulSoup%E7%9A%84%E4%BD%BF%E7%94%A8.html" target="_blank" rel="noopener">https://germey.gitbooks.io/python3webspider/4.2-BeautifulSoup%E7%9A%84%E4%BD%BF%E7%94%A8.html</a></p></blockquote><h3 id="BeautifulSoup简介"><a href="#BeautifulSoup简介" class="headerlink" title="BeautifulSoup简介"></a>BeautifulSoup简介</h3><p>简单来说，BeautifulSoup 就是 Python 的一个 HTML 或 XML 的解析库，我们可以用它来方便地从网页中提取数据，官方的解释如下：</p><blockquote><p>BeautifulSoup提供一些简单的、Python式的函数用来处理导航、搜索、修改分析树等功能。它是一个工具箱，通过解析文档为用户提供需要抓取的数据，因为简单，所以不需要多少代码就可以写出一个完整的应用程序。 BeautifulSoup 自动将输入文档转换为 Unicode 编码，输出文档转换为 utf-8 编码。你不需要考虑编码方式，除非文档没有指定一个编码方式，这时你仅仅需要说明一下原始编码方式就可以了。 BeautifulSoup 已成为和 lxml、html6lib 一样出色的 Python 解释器，为用户灵活地提供不同的解析策略或强劲的速度。</p></blockquote><p>所以说，利用它我们可以省去很多繁琐的提取工作，提高解析效率。</p><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><h4 id="Pip安装"><a href="#Pip安装" class="headerlink" title="Pip安装"></a>Pip安装</h4><p>目前 BeautifulSoup 的最新版本是 4.x 版本，之前的版本已经停止开发了，推荐使用 Pip 来安装，安装命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install beautifulsoup4</span><br></pre></td></tr></table></figure><p>命令执行完毕之后即可完成安装。</p><h4 id="Wheel安装"><a href="#Wheel安装" class="headerlink" title="Wheel安装"></a>Wheel安装</h4><p>当然也可以从 PyPi 下载 Wheel 文件安装，链接如下： <a href="https://pypi.python.org/pypi/beautifulsoup4" target="_blank" rel="noopener">https://pypi.python.org/pypi/beautifulsoup4</a></p><p>然后 Pip 安装 Wheel 文件即可。</p><h3 id="解析器"><a href="#解析器" class="headerlink" title="解析器"></a>解析器</h3><p>BeautifulSoup 在解析的时候实际上是依赖于解析器的，它除了支持 Python 标准库中的 HTML 解析器，还支持一些第三方的解析器比如 LXML，下面我们对 BeautifulSoup 支持的解析器及它们的一些优缺点做一个简单的对比。</p><table><thead><tr><th>解析器</th><th>使用方法</th><th>优势</th><th>劣势</th></tr></thead><tbody><tr><td>Python标准库</td><td>BeautifulSoup(markup, “html.parser”)</td><td>Python的内置标准库、执行速度适中 、文档容错能力强</td><td>Python 2.7.3 or 3.2.2)前的版本中文容错能力差</td></tr><tr><td>LXML HTML 解析器</td><td>BeautifulSoup(markup, “lxml”)</td><td>速度快、文档容错能力强</td><td>需要安装C语言库</td></tr><tr><td>LXML XML 解析器</td><td>BeautifulSoup(markup, “xml”)</td><td>速度快、唯一支持XML的解析器</td><td>需要安装C语言库</td></tr><tr><td>html5lib</td><td>BeautifulSoup(markup, “html5lib”)</td><td>最好的容错性、以浏览器的方式解析文档、生成 HTML5 格式的文档</td><td>速度慢、不依赖外部扩展</td></tr></tbody></table><p>所以通过以上对比可以看出，LXML 这个解析器有解析 HTML 和 XML 的功能，而且速度快，容错能力强，所以推荐使用这个解析器来进行解析。</p><p>使用 LXML 这个解析器，在初始化 BeautifulSoup 的时候我们可以把第二个参数改为 lxml 即可，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">from bs4 import BeautifulSoup</span><br><span class="line">soup = BeautifulSoup(&apos;&lt;p&gt;Hello&lt;/p&gt;&apos;, &apos;lxml&apos;)</span><br><span class="line">print(soup.p.string)</span><br></pre></td></tr></table></figure><p>后面 BeautifulSoup 的用法实例也统一用这个解析器来演示。</p><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><p>下面我们首先用一个实例来感受一下 BeautifulSoup 的基本使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">html = &quot;&quot;&quot;</span><br><span class="line">&lt;html&gt;&lt;head&gt;&lt;title&gt;The Dormouse&apos;s story&lt;/title&gt;&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;p class=&quot;title&quot; name=&quot;dromouse&quot;&gt;&lt;b&gt;The Dormouse&apos;s story&lt;/b&gt;&lt;/p&gt;</span><br><span class="line">&lt;p class=&quot;story&quot;&gt;Once upon a time there were three little sisters; and their names were</span><br><span class="line">&lt;a href=&quot;http://example.com/elsie&quot; class=&quot;sister&quot; id=&quot;link1&quot;&gt;&lt;!-- Elsie --&gt;&lt;/a&gt;,</span><br><span class="line">&lt;a href=&quot;http://example.com/lacie&quot; class=&quot;sister&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt; and</span><br><span class="line">&lt;a href=&quot;http://example.com/tillie&quot; class=&quot;sister&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;;</span><br><span class="line">and they lived at the bottom of a well.&lt;/p&gt;</span><br><span class="line">&lt;p class=&quot;story&quot;&gt;...&lt;/p&gt;</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">from bs4 import BeautifulSoup</span><br><span class="line">soup = BeautifulSoup(html, &apos;lxml&apos;)</span><br><span class="line">print(soup.prettify())</span><br><span class="line">print(soup.title.string)</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line"> &lt;head&gt;</span><br><span class="line">  &lt;title&gt;</span><br><span class="line">   The Dormouse&apos;s story</span><br><span class="line">  &lt;/title&gt;</span><br><span class="line"> &lt;/head&gt;</span><br><span class="line"> &lt;body&gt;</span><br><span class="line">  &lt;p class=&quot;title&quot; name=&quot;dromouse&quot;&gt;</span><br><span class="line">   &lt;b&gt;</span><br><span class="line">    The Dormouse&apos;s story</span><br><span class="line">   &lt;/b&gt;</span><br><span class="line">  &lt;/p&gt;</span><br><span class="line">  &lt;p class=&quot;story&quot;&gt;</span><br><span class="line">   Once upon a time there were three little sisters; and their names were</span><br><span class="line">   &lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;</span><br><span class="line">    &lt;!-- Elsie --&gt;</span><br><span class="line">   &lt;/a&gt;</span><br><span class="line">   ,</span><br><span class="line">   &lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;</span><br><span class="line">    Lacie</span><br><span class="line">   &lt;/a&gt;</span><br><span class="line">   and</span><br><span class="line">   &lt;a class=&quot;sister&quot; href=&quot;http://example.com/tillie&quot; id=&quot;link3&quot;&gt;</span><br><span class="line">    Tillie</span><br><span class="line">   &lt;/a&gt;</span><br><span class="line">   ;</span><br><span class="line">and they lived at the bottom of a well.</span><br><span class="line">  &lt;/p&gt;</span><br><span class="line">  &lt;p class=&quot;story&quot;&gt;</span><br><span class="line">   ...</span><br><span class="line">  &lt;/p&gt;</span><br><span class="line"> &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line">The Dormouse&apos;s story</span><br></pre></td></tr></table></figure><p>首先我们声明了一个变量 html，它是一个 HTML 字符串，但是注意到，它并不是一个完整的 HTML 字符串，body 和 html 节点都没有闭合，但是我们将它当作第一个参数传给 BeautifulSoup 对象，第二个参数传入的是解析器的类型，在这里我们使用 lxml，这样就完成了 BeaufulSoup 对象的初始化，将它赋值给 soup 这个变量。</p><p>那么接下来我们就可以通过调用 soup 的各个方法和属性对这串 HTM L代码解析了。</p><p>我们首先调用了 prettify() 方法，这个方法可以把要解析的字符串以标准的缩进格式输出，在这里注意到输出结果里面包含了 body 和 html 节点，也就是说对于不标准的 HTML 字符串 BeautifulSoup 可以自动更正格式，这一步实际上不是由 prettify() 方法做的，这个更正实际上在初始化 BeautifulSoup 时就完成了。</p><p>然后我们调用了 soup.title.string ，这个实际上是输出了 HTML 中 title 节点的文本内容。所以 soup.title 就可以选择出 HTML 中的 title 节点，再调用 string 属性就可以得到里面的文本了，所以我们就可以通过简单地调用几个属性就可以完成文本的提取了，是不是非常方便？</p><h3 id="节点选择器"><a href="#节点选择器" class="headerlink" title="节点选择器"></a>节点选择器</h3><p>刚才我们选择元素的时候直接通过调用节点的名称就可以选择节点元素了，然后再调用 string 属性就可以得到节点内的文本了，这种选择方式速度非常快，如果单个节点结构话层次非常清晰，可以选用这种方式来解析。</p><h4 id="选择元素"><a href="#选择元素" class="headerlink" title="选择元素"></a>选择元素</h4><p>下面我们再用一个例子详细说明一下它的选择方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">html = &quot;&quot;&quot;</span><br><span class="line">&lt;html&gt;&lt;head&gt;&lt;title&gt;The Dormouse&apos;s story&lt;/title&gt;&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;p class=&quot;title&quot; name=&quot;dromouse&quot;&gt;&lt;b&gt;The Dormouse&apos;s story&lt;/b&gt;&lt;/p&gt;</span><br><span class="line">&lt;p class=&quot;story&quot;&gt;Once upon a time there were three little sisters; and their names were</span><br><span class="line">&lt;a href=&quot;http://example.com/elsie&quot; class=&quot;sister&quot; id=&quot;link1&quot;&gt;&lt;!-- Elsie --&gt;&lt;/a&gt;,</span><br><span class="line">&lt;a href=&quot;http://example.com/lacie&quot; class=&quot;sister&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt; and</span><br><span class="line">&lt;a href=&quot;http://example.com/tillie&quot; class=&quot;sister&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;;</span><br><span class="line">and they lived at the bottom of a well.&lt;/p&gt;</span><br><span class="line">&lt;p class=&quot;story&quot;&gt;...&lt;/p&gt;</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">from bs4 import BeautifulSoup</span><br><span class="line">soup = BeautifulSoup(html, &apos;lxml&apos;)</span><br><span class="line">print(soup.title)</span><br><span class="line">print(type(soup.title))</span><br><span class="line">print(soup.title.string)</span><br><span class="line">print(soup.head)</span><br><span class="line">print(soup.p)</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;title&gt;The Dormouse&apos;s story&lt;/title&gt;</span><br><span class="line">&lt;class &apos;bs4.element.Tag&apos;&gt;</span><br><span class="line">The Dormouse&apos;s story</span><br><span class="line">&lt;head&gt;&lt;title&gt;The Dormouse&apos;s story&lt;/title&gt;&lt;/head&gt;</span><br><span class="line">&lt;p class=&quot;title&quot; name=&quot;dromouse&quot;&gt;&lt;b&gt;The Dormouse&apos;s story&lt;/b&gt;&lt;/p&gt;</span><br></pre></td></tr></table></figure><p>在这里我们依然选用了刚才的 HTML 代码，我们首先打印输出了 title 节点的选择结果，输出结果正是 title 节点加里面的文字内容。接下来输出了它的类型，是 bs4.element.Tag 类型，这是 BeautifulSoup 中的一个重要的数据结构，经过选择器选择之后，选择结果都是这种 Tag 类型，它具有一些属性比如 string 属性，调用 Tag 的 string 属性，就可以得到节点的文本内容了，所以接下来的输出结果正是节点的文本内容。</p><p>接下来我们又尝试选择了 head 节点，结果也是节点加其内部的所有内容，再接下来选择了 p 节点，不过这次情况比较特殊，我们发现结果是第一个 p 节点的内容，后面的几个 p 节点并没有选择到，也就是说，当有多个节点时，这种选择方式只会选择到第一个匹配的节点，其他的后面的节点都会忽略。</p><h4 id="提取信息"><a href="#提取信息" class="headerlink" title="提取信息"></a>提取信息</h4><p>在上面我们演示了调用 string 属性来获取文本的值，那我们要获取节点属性值怎么办呢？获取节点名怎么办呢？下面我们来统一梳理一下信息的提取方式</p><h5 id="获取名称"><a href="#获取名称" class="headerlink" title="获取名称"></a>获取名称</h5><p>可以利用 name 属性来获取节点的名称。还是以上面的文本为例，我们选取 title 节点，然后调用 name 属性就可以得到节点名称。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(soup.title.name)</span><br></pre></td></tr></table></figure><p>运行结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">title</span><br></pre></td></tr></table></figure><h5 id="获取属性"><a href="#获取属性" class="headerlink" title="获取属性"></a>获取属性</h5><p>每个节点可能有多个属性，比如 id，class 等等，我们选择到这个节点元素之后，可以调用 attrs 获取所有属性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(soup.p.attrs)</span><br><span class="line">print(soup.p.attrs[&apos;name&apos;])</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;&apos;class&apos;: [&apos;title&apos;], &apos;name&apos;: &apos;dromouse&apos;&#125;</span><br><span class="line">dromouse</span><br></pre></td></tr></table></figure><p>可以看到 attrs 的返回结果是字典形式，把选择的节点的所有属性和属性值组合成一个字典，接下来如果要获取 name 属性，就相当于从字典中获取某个键值，只需要用中括号加属性名称就可以得到结果了，比如获取 name 属性就可以通过 attrs[‘name’] 得到相应的属性值。</p><p>其实这样的写法还有点繁琐，还有一种更简单的获取方式，我们可以不用写 attrs，直接节点元素后面加中括号，传入属性名就可以达到属性值了，样例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(soup.p[&apos;name&apos;])</span><br><span class="line">print(soup.p[&apos;class&apos;])</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dromouse</span><br><span class="line">[&apos;title&apos;]</span><br></pre></td></tr></table></figure><p>在这里注意到有的返回结果是字符串，有的返回结果是字符串组成的列表。比如 name 属性的值是唯一的，返回的结果就是单个字符串，而对于 class，一个节点元素可能由多个 class，所以返回的是列表，所以在实际处理过程中要注意判断类型。</p><h5 id="获取内容"><a href="#获取内容" class="headerlink" title="获取内容"></a>获取内容</h5><p>可以利用 string 属性获取节点元素包含的文本内容，比如上面的文本我们获取第一个 p 节点的文本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(soup.p.string)</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The Dormouse&apos;s story</span><br></pre></td></tr></table></figure><p>再次注意一下这里选择到的 p 节点是第一个 p 节点，获取的文本也就是第一个 p 节点里面的文本。</p><h4 id="嵌套选择"><a href="#嵌套选择" class="headerlink" title="嵌套选择"></a>嵌套选择</h4><p>在上面的例子中我们知道每一个返回结果都是 bs4.element.Tag 类型，它同样可以继续调用节点进行下一步的选择，比如我们获取了 head 节点元素，我们可以继续调用 head 来选取其内部的 head 节点元素。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">html = &quot;&quot;&quot;</span><br><span class="line">&lt;html&gt;&lt;head&gt;&lt;title&gt;The Dormouse&apos;s story&lt;/title&gt;&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">from bs4 import BeautifulSoup</span><br><span class="line">soup = BeautifulSoup(html, &apos;lxml&apos;)</span><br><span class="line">print(soup.head.title)</span><br><span class="line">print(type(soup.head.title))</span><br><span class="line">print(soup.head.title.string)</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;title&gt;The Dormouse&apos;s story&lt;/title&gt;</span><br><span class="line">&lt;class &apos;bs4.element.Tag&apos;&gt;</span><br><span class="line">The Dormouse&apos;s story</span><br></pre></td></tr></table></figure><p>第一行结果是我们调用了 head 之后再次调用了 title 来选择的 title 节点元素，然后我们紧接着打印输出了它的类型，可以看到它仍然是 bs4.element.Tag 类型，也就是说我们在 Tag 类型的基础上再次选择得到的依然还是 Tag 类型，每次返回的结果都相同，所以这样我们就可以这样做嵌套的选择了。</p><p>最后输出了一下它的 string 属性，也就是节点里的文本内容。</p><h4 id="关联选择"><a href="#关联选择" class="headerlink" title="关联选择"></a>关联选择</h4><p>我们在做选择的时候有时候不能做到一步就可以选择到想要的节点元素，有时候在选择的时候需要先选中某一个节点元素，然后以它为基准再选择它的子节点、父节点、兄弟节点等等。所以在这里我们就介绍下如何来选择这些节点元素。</p><h5 id="子节点和子孙节点"><a href="#子节点和子孙节点" class="headerlink" title="子节点和子孙节点"></a>子节点和子孙节点</h5><p>选取到了一个节点元素之后，如果想要获取它的直接子节点可以调用 contents 属性，我们用一个实例来感受一下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">html = &quot;&quot;&quot;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;head&gt;</span><br><span class="line">        &lt;title&gt;The Dormouse&apos;s story&lt;/title&gt;</span><br><span class="line">    &lt;/head&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">        &lt;p class=&quot;story&quot;&gt;</span><br><span class="line">            Once upon a time there were three little sisters; and their names were</span><br><span class="line">            &lt;a href=&quot;http://example.com/elsie&quot; class=&quot;sister&quot; id=&quot;link1&quot;&gt;</span><br><span class="line">                &lt;span&gt;Elsie&lt;/span&gt;</span><br><span class="line">            &lt;/a&gt;</span><br><span class="line">            &lt;a href=&quot;http://example.com/lacie&quot; class=&quot;sister&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt; </span><br><span class="line">            and</span><br><span class="line">            &lt;a href=&quot;http://example.com/tillie&quot; class=&quot;sister&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;</span><br><span class="line">            and they lived at the bottom of a well.</span><br><span class="line">        &lt;/p&gt;</span><br><span class="line">        &lt;p class=&quot;story&quot;&gt;...&lt;/p&gt;</span><br><span class="line">&quot;&quot;&quot;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[&apos;\n            Once upon a time there were three little sisters; and their names were\n            &apos;, &lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;</span><br><span class="line">&lt;span&gt;Elsie&lt;/span&gt;</span><br><span class="line">&lt;/a&gt;, &apos;\n&apos;, &lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt;, &apos; \n            and\n            &apos;, &lt;a class=&quot;sister&quot; href=&quot;http://example.com/tillie&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;, &apos;\n            and they lived at the bottom of a well.\n        &apos;]</span><br></pre></td></tr></table></figure><p>返回的结果是列表形式，p 节点里面既包含文本，又包含节点，返回的结果会将他们以列表形式都统一返回。</p><p>注意得到的列表的每一个元素都是 p 节点的直接子节点，比如第一个 a 节点里面包含了一层 span 节点，这个就相当于孙子节点了，但是返回结果中并没有单独把 span 节点选出来作为结果的一部分，所以说 contents 属性得到的结果是直接子节点的列表。</p><p>同样地我们可以调用 children 属性，得到相应的结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">from bs4 import BeautifulSoup</span><br><span class="line">soup = BeautifulSoup(html, &apos;lxml&apos;)</span><br><span class="line">print(soup.p.children)</span><br><span class="line">for i, child in enumerate(soup.p.children):</span><br><span class="line">    print(i, child)</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;list_iterator object at 0x1064f7dd8&gt;</span><br><span class="line">0 </span><br><span class="line">            Once upon a time there were three little sisters; and their names were</span><br><span class="line"></span><br><span class="line">1 &lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;</span><br><span class="line">&lt;span&gt;Elsie&lt;/span&gt;</span><br><span class="line">&lt;/a&gt;</span><br><span class="line">2 </span><br><span class="line"></span><br><span class="line">3 &lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt;</span><br><span class="line">4  </span><br><span class="line">            and</span><br><span class="line"></span><br><span class="line">5 &lt;a class=&quot;sister&quot; href=&quot;http://example.com/tillie&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;</span><br><span class="line">6 </span><br><span class="line">            and they lived at the bottom of a well.</span><br></pre></td></tr></table></figure><p>还是同样的 HTML 文本，在这里我们调用了 children 属性来进行选择，返回结果可以看到是生成器类型，所以接下来我们用 for 循环输出了一下相应的内容，内容其实是一样的，只不过 children 返回的是生成器类型，而 contents 返回的是列表类型。</p><p>如果我们要得到所有的子孙节点的话可以调用 descendants 属性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">from bs4 import BeautifulSoup</span><br><span class="line">soup = BeautifulSoup(html, &apos;lxml&apos;)</span><br><span class="line">print(soup.p.descendants)</span><br><span class="line">for i, child in enumerate(soup.p.descendants):</span><br><span class="line">    print(i, child)</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;generator object descendants at 0x10650e678&gt;</span><br><span class="line">0 </span><br><span class="line">            Once upon a time there were three little sisters; and their names were</span><br><span class="line"></span><br><span class="line">1 &lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;</span><br><span class="line">&lt;span&gt;Elsie&lt;/span&gt;</span><br><span class="line">&lt;/a&gt;</span><br><span class="line">2 </span><br><span class="line"></span><br><span class="line">3 &lt;span&gt;Elsie&lt;/span&gt;</span><br><span class="line">4 Elsie</span><br><span class="line">5 </span><br><span class="line"></span><br><span class="line">6 </span><br><span class="line"></span><br><span class="line">7 &lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt;</span><br><span class="line">8 Lacie</span><br><span class="line">9  </span><br><span class="line">            and</span><br><span class="line"></span><br><span class="line">10 &lt;a class=&quot;sister&quot; href=&quot;http://example.com/tillie&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;</span><br><span class="line">11 Tillie</span><br><span class="line">12 </span><br><span class="line">            and they lived at the bottom of a well.</span><br></pre></td></tr></table></figure><p>返回结果还是生成器，遍历输出一下可以看到这次的输出结果就包含了 span 节点，descendants 会递归地查询所有子节点，得到的是所有的子孙节点。</p><h5 id="父节点和祖先节点"><a href="#父节点和祖先节点" class="headerlink" title="父节点和祖先节点"></a>父节点和祖先节点</h5><p>如果要获取某个节点元素的父节点，可以调用 parent 属性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">html = &quot;&quot;&quot;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;head&gt;</span><br><span class="line">        &lt;title&gt;The Dormouse&apos;s story&lt;/title&gt;</span><br><span class="line">    &lt;/head&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">        &lt;p class=&quot;story&quot;&gt;</span><br><span class="line">            Once upon a time there were three little sisters; and their names were</span><br><span class="line">            &lt;a href=&quot;http://example.com/elsie&quot; class=&quot;sister&quot; id=&quot;link1&quot;&gt;</span><br><span class="line">                &lt;span&gt;Elsie&lt;/span&gt;</span><br><span class="line">            &lt;/a&gt;</span><br><span class="line">        &lt;/p&gt;</span><br><span class="line">        &lt;p class=&quot;story&quot;&gt;...&lt;/p&gt;</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">from bs4 import BeautifulSoup</span><br><span class="line">soup = BeautifulSoup(html, &apos;lxml&apos;)</span><br><span class="line">print(soup.a.parent)</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;p class=&quot;story&quot;&gt;</span><br><span class="line">            Once upon a time there were three little sisters; and their names were</span><br><span class="line">            &lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;</span><br><span class="line">&lt;span&gt;Elsie&lt;/span&gt;</span><br><span class="line">&lt;/a&gt;</span><br><span class="line">&lt;/p&gt;</span><br></pre></td></tr></table></figure><p>在这里我们选择的是第一个 a 节点的父节点元素，很明显它的父节点是 p 节点，输出结果便是 p 节点及其内部的内容。</p><p>注意到这里输出的仅仅是 a 节点的直接父节点，而没有再向外寻找父节点的祖先节点，如果我们要想获取所有的祖先节点，可以调用 parents 属性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">html = &quot;&quot;&quot;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">        &lt;p class=&quot;story&quot;&gt;</span><br><span class="line">            &lt;a href=&quot;http://example.com/elsie&quot; class=&quot;sister&quot; id=&quot;link1&quot;&gt;</span><br><span class="line">                &lt;span&gt;Elsie&lt;/span&gt;</span><br><span class="line">            &lt;/a&gt;</span><br><span class="line">        &lt;/p&gt;</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">from bs4 import BeautifulSoup</span><br><span class="line">soup = BeautifulSoup(html, &apos;lxml&apos;)</span><br><span class="line">print(type(soup.a.parents))</span><br><span class="line">print(list(enumerate(soup.a.parents)))</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;class &apos;generator&apos;&gt;</span><br><span class="line">[(0, &lt;p class=&quot;story&quot;&gt;</span><br><span class="line">&lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;</span><br><span class="line">&lt;span&gt;Elsie&lt;/span&gt;</span><br><span class="line">&lt;/a&gt;</span><br><span class="line">&lt;/p&gt;), (1, &lt;body&gt;</span><br><span class="line">&lt;p class=&quot;story&quot;&gt;</span><br><span class="line">&lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;</span><br><span class="line">&lt;span&gt;Elsie&lt;/span&gt;</span><br><span class="line">&lt;/a&gt;</span><br><span class="line">&lt;/p&gt;</span><br><span class="line">&lt;/body&gt;), (2, &lt;html&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;p class=&quot;story&quot;&gt;</span><br><span class="line">&lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;</span><br><span class="line">&lt;span&gt;Elsie&lt;/span&gt;</span><br><span class="line">&lt;/a&gt;</span><br><span class="line">&lt;/p&gt;</span><br><span class="line">&lt;/body&gt;&lt;/html&gt;), (3, &lt;html&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;p class=&quot;story&quot;&gt;</span><br><span class="line">&lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;</span><br><span class="line">&lt;span&gt;Elsie&lt;/span&gt;</span><br><span class="line">&lt;/a&gt;</span><br><span class="line">&lt;/p&gt;</span><br><span class="line">&lt;/body&gt;&lt;/html&gt;)]</span><br></pre></td></tr></table></figure><p>返回结果是一个生成器类型，我们在这里用列表输出了它的索引和内容，可以发现列表中的元素就是 a 节点的祖先节点。</p><h5 id="兄弟节点"><a href="#兄弟节点" class="headerlink" title="兄弟节点"></a>兄弟节点</h5><p>上面说明了子节点和父节点的获取方式，如果要获取同级的节点也就是兄弟节点应该怎么办？我们先用一个实例来感受一下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">html = &quot;&quot;&quot;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">        &lt;p class=&quot;story&quot;&gt;</span><br><span class="line">            Once upon a time there were three little sisters; and their names were</span><br><span class="line">            &lt;a href=&quot;http://example.com/elsie&quot; class=&quot;sister&quot; id=&quot;link1&quot;&gt;</span><br><span class="line">                &lt;span&gt;Elsie&lt;/span&gt;</span><br><span class="line">            &lt;/a&gt;</span><br><span class="line">            Hello</span><br><span class="line">            &lt;a href=&quot;http://example.com/lacie&quot; class=&quot;sister&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt; </span><br><span class="line">            and</span><br><span class="line">            &lt;a href=&quot;http://example.com/tillie&quot; class=&quot;sister&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;</span><br><span class="line">            and they lived at the bottom of a well.</span><br><span class="line">        &lt;/p&gt;</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">from bs4 import BeautifulSoup</span><br><span class="line">soup = BeautifulSoup(html, &apos;lxml&apos;)</span><br><span class="line">print(&apos;Next Sibling&apos;, soup.a.next_sibling)</span><br><span class="line">print(&apos;Prev Sibling&apos;, soup.a.previous_sibling)</span><br><span class="line">print(&apos;Next Siblings&apos;, list(enumerate(soup.a.next_siblings)))</span><br><span class="line">print(&apos;Prev Siblings&apos;, list(enumerate(soup.a.previous_siblings)))</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Next Sibling </span><br><span class="line">            Hello</span><br><span class="line"></span><br><span class="line">Prev Sibling </span><br><span class="line">            Once upon a time there were three little sisters; and their names were</span><br><span class="line"></span><br><span class="line">Next Siblings [(0, &apos;\n            Hello\n            &apos;), (1, &lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt;), (2, &apos; \n            and\n            &apos;), (3, &lt;a class=&quot;sister&quot; href=&quot;http://example.com/tillie&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;), (4, &apos;\n            and they lived at the bottom of a well.\n        &apos;)]</span><br><span class="line">Prev Siblings [(0, &apos;\n            Once upon a time there were three little sisters; and their names were\n            &apos;)]</span><br></pre></td></tr></table></figure><p>可以看到在这里我们调用了四个不同的属性，next_sibling 和 previous_sibling 分别可以获取节点的下一个和上一个兄弟元素，next_siblings 和 previous_siblings 则分别返回所有前面和后面的兄弟节点的生成器。</p><h5 id="提取信息-1"><a href="#提取信息-1" class="headerlink" title="提取信息"></a>提取信息</h5><p>在上面我们讲解了关联元素节点的选择方法，如果我们想要获取它们的一些信息，比如文本、属性等等也是同样的方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">html = &quot;&quot;&quot;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">        &lt;p class=&quot;story&quot;&gt;</span><br><span class="line">            Once upon a time there were three little sisters; and their names were</span><br><span class="line">            &lt;a href=&quot;http://example.com/elsie&quot; class=&quot;sister&quot; id=&quot;link1&quot;&gt;Bob&lt;/a&gt;&lt;a href=&quot;http://example.com/lacie&quot; class=&quot;sister&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt; </span><br><span class="line">        &lt;/p&gt;</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">from bs4 import BeautifulSoup</span><br><span class="line">soup = BeautifulSoup(html, &apos;lxml&apos;)</span><br><span class="line">print(&apos;Next Sibling:&apos;)</span><br><span class="line">print(type(soup.a.next_sibling))</span><br><span class="line">print(soup.a.next_sibling)</span><br><span class="line">print(soup.a.next_sibling.string)</span><br><span class="line">print(&apos;Parent:&apos;)</span><br><span class="line">print(type(soup.a.parents))</span><br><span class="line">print(list(soup.a.parents)[0])</span><br><span class="line">print(list(soup.a.parents)[0].attrs[&apos;class&apos;])</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Next Sibling:</span><br><span class="line">&lt;class &apos;bs4.element.Tag&apos;&gt;</span><br><span class="line">&lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt;</span><br><span class="line">Lacie</span><br><span class="line">Parent:</span><br><span class="line">&lt;class &apos;generator&apos;&gt;</span><br><span class="line">&lt;p class=&quot;story&quot;&gt;</span><br><span class="line">            Once upon a time there were three little sisters; and their names were</span><br><span class="line">            &lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;Bob&lt;/a&gt;&lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt;</span><br><span class="line">&lt;/p&gt;</span><br><span class="line">[&apos;story&apos;]</span><br></pre></td></tr></table></figure><p>如果返回结果是单个节点，那么可以直接调用 string、attrs 等属性来获得其文本和属性，如果返回结果是多个节点的生成器，则可以转为列表后取出某个元素，然后再调用 string、attrs 等属性来获取其对应节点等文本和属性。</p><h3 id="方法选择器"><a href="#方法选择器" class="headerlink" title="方法选择器"></a>方法选择器</h3><p>前面我们所讲的选择方法都是通过属性来选择元素的，这种选择方法非常快，但是如果要进行比较复杂的选择的话则会比较繁琐，不够灵活。所以 BeautifulSoup 还为我们提供了一些查询的方法，比如 find_all()、find() 等方法，我们可以调用方法然后传入相应等参数就可以灵活地进行查询了。</p><p>最常用的查询方法莫过于 find_all() 和 find() 了，下面我们对它们的用法进行详细的介绍。</p><h4 id="find-all"><a href="#find-all" class="headerlink" title="find_all()"></a>find_all()</h4><p>find_all，顾名思义，就是查询所有符合条件的元素，可以给它传入一些属性或文本来得到符合条件的元素，功能十分强大。</p><p>它的API如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find_all(name , attrs , recursive , text , **kwargs)</span><br></pre></td></tr></table></figure><h5 id="name"><a href="#name" class="headerlink" title="name"></a>name</h5><p>我们可以根据节点名来查询元素，下面我们用一个实例来感受一下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">html=&apos;&apos;&apos;</span><br><span class="line">&lt;div class=&quot;panel&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;panel-heading&quot;&gt;</span><br><span class="line">        &lt;h4&gt;Hello&lt;/h4&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;panel-body&quot;&gt;</span><br><span class="line">        &lt;ul class=&quot;list&quot; id=&quot;list-1&quot;&gt;</span><br><span class="line">            &lt;li class=&quot;element&quot;&gt;Foo&lt;/li&gt;</span><br><span class="line">            &lt;li class=&quot;element&quot;&gt;Bar&lt;/li&gt;</span><br><span class="line">            &lt;li class=&quot;element&quot;&gt;Jay&lt;/li&gt;</span><br><span class="line">        &lt;/ul&gt;</span><br><span class="line">        &lt;ul class=&quot;list list-small&quot; id=&quot;list-2&quot;&gt;</span><br><span class="line">            &lt;li class=&quot;element&quot;&gt;Foo&lt;/li&gt;</span><br><span class="line">            &lt;li class=&quot;element&quot;&gt;Bar&lt;/li&gt;</span><br><span class="line">        &lt;/ul&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&apos;&apos;&apos;</span><br><span class="line">from bs4 import BeautifulSoup</span><br><span class="line">soup = BeautifulSoup(html, &apos;lxml&apos;)</span><br><span class="line">print(soup.find_all(name=&apos;ul&apos;))</span><br><span class="line">print(type(soup.find_all(name=&apos;ul&apos;)[0]))</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[&lt;ul class=&quot;list&quot; id=&quot;list-1&quot;&gt;</span><br><span class="line">&lt;li class=&quot;element&quot;&gt;Foo&lt;/li&gt;</span><br><span class="line">&lt;li class=&quot;element&quot;&gt;Bar&lt;/li&gt;</span><br><span class="line">&lt;li class=&quot;element&quot;&gt;Jay&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;, &lt;ul class=&quot;list list-small&quot; id=&quot;list-2&quot;&gt;</span><br><span class="line">&lt;li class=&quot;element&quot;&gt;Foo&lt;/li&gt;</span><br><span class="line">&lt;li class=&quot;element&quot;&gt;Bar&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;]</span><br><span class="line">&lt;class &apos;bs4.element.Tag&apos;&gt;</span><br></pre></td></tr></table></figure><p>在这里我们调用了 find_all() 方法，传入了一个 name 参数，参数值为 ul，也就是说我们想要查询所有 ul 节点，返回结果是列表类型，长度为 2，每个元素依然都是 bs4.element.Tag 类型。</p><p>因为都是 Tag 类型，所以我们依然可以进行嵌套查询，还是同样的文本，在这里我们查询出所有 ul 节点后再继续查询其内部的 li 节点。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for ul in soup.find_all(name=&apos;ul&apos;):</span><br><span class="line">    print(ul.find_all(name=&apos;li&apos;))</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[&lt;li class=&quot;element&quot;&gt;Foo&lt;/li&gt;, &lt;li class=&quot;element&quot;&gt;Bar&lt;/li&gt;, &lt;li class=&quot;element&quot;&gt;Jay&lt;/li&gt;]</span><br><span class="line">[&lt;li class=&quot;element&quot;&gt;Foo&lt;/li&gt;, &lt;li class=&quot;element&quot;&gt;Bar&lt;/li&gt;]</span><br></pre></td></tr></table></figure><p>返回结果是列表类型，列表中的每个元素依然还是 Tag 类型。</p><p>接下来我们就可以遍历每个 li 获取它的文本了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for ul in soup.find_all(name=&apos;ul&apos;):</span><br><span class="line">    print(ul.find_all(name=&apos;li&apos;))</span><br><span class="line">    for li in ul.find_all(name=&apos;li&apos;):</span><br><span class="line">        print(li.string)</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[&lt;li class=&quot;element&quot;&gt;Foo&lt;/li&gt;, &lt;li class=&quot;element&quot;&gt;Bar&lt;/li&gt;, &lt;li class=&quot;element&quot;&gt;Jay&lt;/li&gt;]</span><br><span class="line">Foo</span><br><span class="line">Bar</span><br><span class="line">Jay</span><br><span class="line">[&lt;li class=&quot;element&quot;&gt;Foo&lt;/li&gt;, &lt;li class=&quot;element&quot;&gt;Bar&lt;/li&gt;]</span><br><span class="line">Foo</span><br><span class="line">Bar</span><br></pre></td></tr></table></figure><h5 id="attrs"><a href="#attrs" class="headerlink" title="attrs"></a>attrs</h5><p>除了根据节点名查询，我们也可以传入一些属性来进行查询，我们用一个实例感受一下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">html=&apos;&apos;&apos;</span><br><span class="line">&lt;div class=&quot;panel&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;panel-heading&quot;&gt;</span><br><span class="line">        &lt;h4&gt;Hello&lt;/h4&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;panel-body&quot;&gt;</span><br><span class="line">        &lt;ul class=&quot;list&quot; id=&quot;list-1&quot; name=&quot;elements&quot;&gt;</span><br><span class="line">            &lt;li class=&quot;element&quot;&gt;Foo&lt;/li&gt;</span><br><span class="line">            &lt;li class=&quot;element&quot;&gt;Bar&lt;/li&gt;</span><br><span class="line">            &lt;li class=&quot;element&quot;&gt;Jay&lt;/li&gt;</span><br><span class="line">        &lt;/ul&gt;</span><br><span class="line">        &lt;ul class=&quot;list list-small&quot; id=&quot;list-2&quot;&gt;</span><br><span class="line">            &lt;li class=&quot;element&quot;&gt;Foo&lt;/li&gt;</span><br><span class="line">            &lt;li class=&quot;element&quot;&gt;Bar&lt;/li&gt;</span><br><span class="line">        &lt;/ul&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&apos;&apos;&apos;</span><br><span class="line">from bs4 import BeautifulSoup</span><br><span class="line">soup = BeautifulSoup(html, &apos;lxml&apos;)</span><br><span class="line">print(soup.find_all(attrs=&#123;&apos;id&apos;: &apos;list-1&apos;&#125;))</span><br><span class="line">print(soup.find_all(attrs=&#123;&apos;name&apos;: &apos;elements&apos;&#125;))</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[&lt;ul class=&quot;list&quot; id=&quot;list-1&quot; name=&quot;elements&quot;&gt;</span><br><span class="line">&lt;li class=&quot;element&quot;&gt;Foo&lt;/li&gt;</span><br><span class="line">&lt;li class=&quot;element&quot;&gt;Bar&lt;/li&gt;</span><br><span class="line">&lt;li class=&quot;element&quot;&gt;Jay&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;]</span><br><span class="line">[&lt;ul class=&quot;list&quot; id=&quot;list-1&quot; name=&quot;elements&quot;&gt;</span><br><span class="line">&lt;li class=&quot;element&quot;&gt;Foo&lt;/li&gt;</span><br><span class="line">&lt;li class=&quot;element&quot;&gt;Bar&lt;/li&gt;</span><br><span class="line">&lt;li class=&quot;element&quot;&gt;Jay&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;]</span><br></pre></td></tr></table></figure><p>在这里我们查询的时候传入的是 attrs 参数，参数的类型是字典类型，比如我们要查询 id 为 list-1 的节点，那就可以传入attrs={‘id’: ‘list-1’} 的查询条件，得到的结果是列表形式，包含的内容就是符合 id 为 list-1 的所有节点，上面的例子中符合条件的元素个数是 1，所以结果是长度为 1 的列表。</p><p>对于一些常用的属性比如 id、class 等，我们可以不用 attrs 来传递，比如我们要查询 id 为 list-1 的节点，我们可以直接传入 id 这个参数，还是上面的文本，我们换一种方式来查询。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">from bs4 import BeautifulSoup</span><br><span class="line">soup = BeautifulSoup(html, &apos;lxml&apos;)</span><br><span class="line">print(soup.find_all(id=&apos;list-1&apos;))</span><br><span class="line">print(soup.find_all(class_=&apos;element&apos;))</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[&lt;ul class=&quot;list&quot; id=&quot;list-1&quot;&gt;</span><br><span class="line">&lt;li class=&quot;element&quot;&gt;Foo&lt;/li&gt;</span><br><span class="line">&lt;li class=&quot;element&quot;&gt;Bar&lt;/li&gt;</span><br><span class="line">&lt;li class=&quot;element&quot;&gt;Jay&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;]</span><br><span class="line">[&lt;li class=&quot;element&quot;&gt;Foo&lt;/li&gt;, &lt;li class=&quot;element&quot;&gt;Bar&lt;/li&gt;, &lt;li class=&quot;element&quot;&gt;Jay&lt;/li&gt;, &lt;li class=&quot;element&quot;&gt;Foo&lt;/li&gt;, &lt;li class=&quot;element&quot;&gt;Bar&lt;/li&gt;]</span><br></pre></td></tr></table></figure><p>在这里我们直接传入 id=’list-1’ 就可以查询 id 为 list-1 的节点元素了。而对于 class 来说，由于 class 在 python 里是一个关键字，所以在这里后面需要加一个下划线，class_=’element’，返回的结果依然还是 Tag 组成的列表。</p><h5 id="text"><a href="#text" class="headerlink" title="text"></a>text</h5><p>text 参数可以用来匹配节点的文本，传入的形式可以是字符串，可以是正则表达式对象，我们用一个实例来感受一下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import re</span><br><span class="line">html=&apos;&apos;&apos;</span><br><span class="line">&lt;div class=&quot;panel&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;panel-body&quot;&gt;</span><br><span class="line">        &lt;a&gt;Hello, this is a link&lt;/a&gt;</span><br><span class="line">        &lt;a&gt;Hello, this is a link, too&lt;/a&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&apos;&apos;&apos;</span><br><span class="line">from bs4 import BeautifulSoup</span><br><span class="line">soup = BeautifulSoup(html, &apos;lxml&apos;)</span><br><span class="line">print(soup.find_all(text=re.compile(&apos;link&apos;)))</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&apos;Hello, this is a link&apos;, &apos;Hello, this is a link, too&apos;]</span><br></pre></td></tr></table></figure><p>在这里有两个 a 节点，其内部包含有文本信息，在这里我们调用 find_all() 方法传入 text 参数，参数为正则表达式对象，结果会返回所有匹配正则表达式的节点文本组成的列表。</p><h4 id="find"><a href="#find" class="headerlink" title="find()"></a>find()</h4><p>除了 find_all() 方法，还有 find() 方法，只不过 find() 方法返回的是单个元素，也就是第一个匹配的元素，而 find_all() 返回的是所有匹配的元素组成的列表。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">html=&apos;&apos;&apos;</span><br><span class="line">&lt;div class=&quot;panel&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;panel-heading&quot;&gt;</span><br><span class="line">        &lt;h4&gt;Hello&lt;/h4&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;panel-body&quot;&gt;</span><br><span class="line">        &lt;ul class=&quot;list&quot; id=&quot;list-1&quot;&gt;</span><br><span class="line">            &lt;li class=&quot;element&quot;&gt;Foo&lt;/li&gt;</span><br><span class="line">            &lt;li class=&quot;element&quot;&gt;Bar&lt;/li&gt;</span><br><span class="line">            &lt;li class=&quot;element&quot;&gt;Jay&lt;/li&gt;</span><br><span class="line">        &lt;/ul&gt;</span><br><span class="line">        &lt;ul class=&quot;list list-small&quot; id=&quot;list-2&quot;&gt;</span><br><span class="line">            &lt;li class=&quot;element&quot;&gt;Foo&lt;/li&gt;</span><br><span class="line">            &lt;li class=&quot;element&quot;&gt;Bar&lt;/li&gt;</span><br><span class="line">        &lt;/ul&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&apos;&apos;&apos;</span><br><span class="line">from bs4 import BeautifulSoup</span><br><span class="line">soup = BeautifulSoup(html, &apos;lxml&apos;)</span><br><span class="line">print(soup.find(name=&apos;ul&apos;))</span><br><span class="line">print(type(soup.find(name=&apos;ul&apos;)))</span><br><span class="line">print(soup.find(class_=&apos;list&apos;))</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul class=&quot;list&quot; id=&quot;list-1&quot;&gt;</span><br><span class="line">&lt;li class=&quot;element&quot;&gt;Foo&lt;/li&gt;</span><br><span class="line">&lt;li class=&quot;element&quot;&gt;Bar&lt;/li&gt;</span><br><span class="line">&lt;li class=&quot;element&quot;&gt;Jay&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">&lt;class &apos;bs4.element.Tag&apos;&gt;</span><br><span class="line">&lt;ul class=&quot;list&quot; id=&quot;list-1&quot;&gt;</span><br><span class="line">&lt;li class=&quot;element&quot;&gt;Foo&lt;/li&gt;</span><br><span class="line">&lt;li class=&quot;element&quot;&gt;Bar&lt;/li&gt;</span><br><span class="line">&lt;li class=&quot;element&quot;&gt;Jay&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure><p>返回结果不再是列表形式，而是第一个匹配的节点元素，类型依然是 Tag 类型。</p><p>另外还有许多的查询方法，用法与前面介绍的 find_all()、find() 方法完全相同，只不过查询范围不同，在此做一下简单的说明。</p><h4 id="find-parents-find-parent"><a href="#find-parents-find-parent" class="headerlink" title="find_parents() find_parent()"></a>find_parents() find_parent()</h4><p>find_parents() 返回所有祖先节点，find_parent() 返回直接父节点。</p><h4 id="find-next-siblings-find-next-sibling"><a href="#find-next-siblings-find-next-sibling" class="headerlink" title="find_next_siblings() find_next_sibling()"></a>find_next_siblings() find_next_sibling()</h4><p>find_next_siblings() 返回后面所有兄弟节点，find_next_sibling() 返回后面第一个兄弟节点。</p><h4 id="find-previous-siblings-find-previous-sibling"><a href="#find-previous-siblings-find-previous-sibling" class="headerlink" title="find_previous_siblings() find_previous_sibling()"></a>find_previous_siblings() find_previous_sibling()</h4><p>find_previous_siblings() 返回前面所有兄弟节点，find_previous_sibling() 返回前面第一个兄弟节点。</p><h4 id="find-all-next-find-next"><a href="#find-all-next-find-next" class="headerlink" title="find_all_next() find_next()"></a>find_all_next() find_next()</h4><p>find_all_next() 返回节点后所有符合条件的节点, find_next() 返回第一个符合条件的节点。</p><h4 id="find-all-previous-和-find-previous"><a href="#find-all-previous-和-find-previous" class="headerlink" title="find_all_previous() 和 find_previous()"></a>find_all_previous() 和 find_previous()</h4><p>find_all_previous() 返回节点后所有符合条件的节点, find_previous() 返回第一个符合条件的节点</p><h3 id="CSS选择器"><a href="#CSS选择器" class="headerlink" title="CSS选择器"></a>CSS选择器</h3><p>BeautifulSoup 还提供了另外一种选择器，那就是 CSS 选择器，如果对 Web 开发熟悉对话，CSS 选择器肯定也不陌生，如果不熟悉的话，可以看一下：<a href="http://www.w3school.com.cn/cssref/css_selectors.asp" target="_blank" rel="noopener">http://www.w3school.com.cn/cssref/css_selectors.asp</a>。</p><p>使用 CSS 选择器，只需要调用 select() 方法，传入相应的 CSS 选择器即可，我们用一个实例来感受一下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">html=&apos;&apos;&apos;</span><br><span class="line">&lt;div class=&quot;panel&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;panel-heading&quot;&gt;</span><br><span class="line">        &lt;h4&gt;Hello&lt;/h4&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;panel-body&quot;&gt;</span><br><span class="line">        &lt;ul class=&quot;list&quot; id=&quot;list-1&quot;&gt;</span><br><span class="line">            &lt;li class=&quot;element&quot;&gt;Foo&lt;/li&gt;</span><br><span class="line">            &lt;li class=&quot;element&quot;&gt;Bar&lt;/li&gt;</span><br><span class="line">            &lt;li class=&quot;element&quot;&gt;Jay&lt;/li&gt;</span><br><span class="line">        &lt;/ul&gt;</span><br><span class="line">        &lt;ul class=&quot;list list-small&quot; id=&quot;list-2&quot;&gt;</span><br><span class="line">            &lt;li class=&quot;element&quot;&gt;Foo&lt;/li&gt;</span><br><span class="line">            &lt;li class=&quot;element&quot;&gt;Bar&lt;/li&gt;</span><br><span class="line">        &lt;/ul&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&apos;&apos;&apos;</span><br><span class="line">from bs4 import BeautifulSoup</span><br><span class="line">soup = BeautifulSoup(html, &apos;lxml&apos;)</span><br><span class="line">print(soup.select(&apos;.panel .panel-heading&apos;))</span><br><span class="line">print(soup.select(&apos;ul li&apos;))</span><br><span class="line">print(soup.select(&apos;#list-2 .element&apos;))</span><br><span class="line">print(type(soup.select(&apos;ul&apos;)[0]))</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[&lt;div class=&quot;panel-heading&quot;&gt;</span><br><span class="line">&lt;h4&gt;Hello&lt;/h4&gt;</span><br><span class="line">&lt;/div&gt;]</span><br><span class="line">[&lt;li class=&quot;element&quot;&gt;Foo&lt;/li&gt;, &lt;li class=&quot;element&quot;&gt;Bar&lt;/li&gt;, &lt;li class=&quot;element&quot;&gt;Jay&lt;/li&gt;, &lt;li class=&quot;element&quot;&gt;Foo&lt;/li&gt;, &lt;li class=&quot;element&quot;&gt;Bar&lt;/li&gt;]</span><br><span class="line">[&lt;li class=&quot;element&quot;&gt;Foo&lt;/li&gt;, &lt;li class=&quot;element&quot;&gt;Bar&lt;/li&gt;]</span><br><span class="line">&lt;class &apos;bs4.element.Tag&apos;&gt;</span><br></pre></td></tr></table></figure><p>在这里我们用了三次 CSS 选择器，返回的结果均是符合 CSS 选择器的节点组成的列表。例如 select(‘ul li’) 则是选择所有 ul 节点下面的所有 li 节点，结果便是所有的 li 节点组成的列表。</p><p>最后一句我们打印输出了列表中元素的类型，可以看到类型依然是 Tag 类型。</p><h4 id="嵌套选择-1"><a href="#嵌套选择-1" class="headerlink" title="嵌套选择"></a>嵌套选择</h4><p>select() 方法同样支持嵌套选择，例如我们先选择所有 ul 节点，再遍历每个 ul 节点选择其 li 节点，样例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">from bs4 import BeautifulSoup</span><br><span class="line">soup = BeautifulSoup(html, &apos;lxml&apos;)</span><br><span class="line">for ul in soup.select(&apos;ul&apos;):</span><br><span class="line">    print(ul.select(&apos;li&apos;))</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[&lt;li class=&quot;element&quot;&gt;Foo&lt;/li&gt;, &lt;li class=&quot;element&quot;&gt;Bar&lt;/li&gt;, &lt;li class=&quot;element&quot;&gt;Jay&lt;/li&gt;]</span><br><span class="line">[&lt;li class=&quot;element&quot;&gt;Foo&lt;/li&gt;, &lt;li class=&quot;element&quot;&gt;Bar&lt;/li&gt;]</span><br></pre></td></tr></table></figure><p>可以看到正常输出了遍历每个 ul 节点之后，其下的所有 li 节点组成的列表。</p><h4 id="获取属性-1"><a href="#获取属性-1" class="headerlink" title="获取属性"></a>获取属性</h4><p>我们知道节点类型是 Tag 类型，所以获取属性还是可以用原来的方法获取，仍然是上面的 HTML 文本，我们在这里尝试获取每个 ul 节点的 id 属性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">from bs4 import BeautifulSoup</span><br><span class="line">soup = BeautifulSoup(html, &apos;lxml&apos;)</span><br><span class="line">for ul in soup.select(&apos;ul&apos;):</span><br><span class="line">    print(ul[&apos;id&apos;])</span><br><span class="line">    print(ul.attrs[&apos;id&apos;])</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">list-1</span><br><span class="line">list-1</span><br><span class="line">list-2</span><br><span class="line">list-2</span><br></pre></td></tr></table></figure><p>可以看到直接传入中括号和属性名和通过 attrs 属性获取属性值都是可以成功的。</p><h4 id="获取文本"><a href="#获取文本" class="headerlink" title="获取文本"></a>获取文本</h4><p>那么获取文本当然也可以用前面所讲的 string 属性，还有一个方法那就是 get_text()，同样可以获取文本值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">from bs4 import BeautifulSoup</span><br><span class="line">soup = BeautifulSoup(html, &apos;lxml&apos;)</span><br><span class="line">for li in soup.select(&apos;li&apos;):</span><br><span class="line">    print(&apos;Get Text:&apos;, li.get_text())</span><br><span class="line">    print(&apos;String:&apos;, li.string)</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Get Text: Foo</span><br><span class="line">String: Foo</span><br><span class="line">Get Text: Bar</span><br><span class="line">String: Bar</span><br><span class="line">Get Text: Jay</span><br><span class="line">String: Jay</span><br><span class="line">Get Text: Foo</span><br><span class="line">String: Foo</span><br><span class="line">Get Text: Bar</span><br><span class="line">String: Bar</span><br></pre></td></tr></table></figure><p>二者的效果是完全一致的，都可以获取到节点的文本值。</p><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><blockquote><ul><li>推荐使用 LXML 解析库，必要时使用 html.parser。</li><li>节点选择筛选功能弱但是速度快。</li><li>建议使用 find()、find_all() 查询匹配单个结果或者多个结果。</li><li>如果对 CSS 选择器熟悉的话可以使用 select() 选择法。</li></ul></blockquote>]]></content>
      
      <categories>
          
          <category> 爬虫 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 爬虫 </tag>
            
            <tag> BeautifulSoup </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>XPath 和 lxml库</title>
      <link href="/post/606df891.html"/>
      <url>/post/606df891.html</url>
      <content type="html"><![CDATA[<h3 id="关于Python爬虫，我们需要学习的有："><a href="#关于Python爬虫，我们需要学习的有：" class="headerlink" title="关于Python爬虫，我们需要学习的有："></a>关于Python爬虫，我们需要学习的有：</h3><h5 id="1-Python基础语法学习（基础知识）"><a href="#1-Python基础语法学习（基础知识）" class="headerlink" title="1. Python基础语法学习（基础知识）"></a>1. Python基础语法学习（基础知识）</h5><h5 id="2-HTML页面的内容抓取（数据抓取）"><a href="#2-HTML页面的内容抓取（数据抓取）" class="headerlink" title="2. HTML页面的内容抓取（数据抓取）"></a>2. HTML页面的内容抓取（数据抓取）</h5><h5 id="3-HTML页面的数据提取（数据清洗）"><a href="#3-HTML页面的数据提取（数据清洗）" class="headerlink" title="3. HTML页面的数据提取（数据清洗）"></a>3. HTML页面的数据提取（数据清洗）</h5><h5 id="4-Scrapy框架以及scrapy-redis分布式策略（第三方框架）"><a href="#4-Scrapy框架以及scrapy-redis分布式策略（第三方框架）" class="headerlink" title="4. Scrapy框架以及scrapy-redis分布式策略（第三方框架）"></a>4. Scrapy框架以及scrapy-redis分布式策略（第三方框架）</h5><h5 id="6-爬虫-Spider-、反爬虫-Anti-Spider-、反反爬虫-Anti-Anti-Spider-之间的斗争…"><a href="#6-爬虫-Spider-、反爬虫-Anti-Spider-、反反爬虫-Anti-Anti-Spider-之间的斗争…" class="headerlink" title="6. 爬虫(Spider)、反爬虫(Anti-Spider)、反反爬虫(Anti-Anti-Spider)之间的斗争…."></a>6. 爬虫(Spider)、反爬虫(Anti-Spider)、反反爬虫(Anti-Anti-Spider)之间的斗争….</h5><p>为了重拾爬虫部分，决定写博客复习一下，废话不多说，这篇文章主要说一下 XPath与lxml类库 </p><h2 id="什么是XPath？"><a href="#什么是XPath？" class="headerlink" title="什么是XPath？"></a>什么是XPath？</h2><blockquote><p>XPath (XML Path Language) 是一门在 XML 文档中查找信息的语言，可用来在 XML 文档中对元素和属性进行遍历。</p><p>W3School官方文档：<a href="http://www.w3school.com.cn/xpath/index.asp" target="_blank" rel="noopener">http://www.w3school.com.cn/xpath/index.asp</a></p></blockquote><h3 id="XPath-开发工具"><a href="#XPath-开发工具" class="headerlink" title="XPath 开发工具"></a>XPath 开发工具</h3><ol><li>开源的XPath表达式编辑工具:XMLQuire(XML格式文件可用)</li><li>Chrome插件XPath Helper</li><li>Firefox插件 XPath Checker</li></ol><h3 id="选取节点"><a href="#选取节点" class="headerlink" title="选取节点"></a>选取节点</h3><p>XPath 使用路径表达式来选取 XML 文档中的节点或者节点集。这些路径表达式和我们在常规的电脑文件系统中看到的表达式非常相似。</p><p>下面列出了最常用的路径表达式：</p><table><thead><tr><th>表达式</th><th>描述</th></tr></thead><tbody><tr><td>nodename</td><td>选取此节点的所有子节点。</td></tr><tr><td>/</td><td>从根节点选取。</td></tr><tr><td>//</td><td>从匹配选择的当前节点选择文档中的节点，而不考虑它们的位置。</td></tr><tr><td>.</td><td>选取当前节点。</td></tr><tr><td>..</td><td>选取当前节点的父节点。</td></tr><tr><td>@</td><td>选取属性。</td></tr></tbody></table><p>在下面的表格中，我们已列出了一些路径表达式以及表达式的结果：</p><table><thead><tr><th></th><th>路径表达式</th></tr></thead><tbody><tr><td>bookstore</td><td>选取 bookstore 元素的所有子节点。</td></tr><tr><td>/bookstore</td><td>选取根元素 bookstore。注释：假如路径起始于正斜杠( / )，则此路径始终代表到某元素的绝对路径！</td></tr><tr><td>bookstore/book</td><td>选取属于 bookstore 的子元素的所有 book 元素。</td></tr><tr><td>//book</td><td>选取所有 book 子元素，而不管它们在文档中的位置。</td></tr><tr><td>bookstore//book</td><td>选择属于 bookstore 元素的后代的所有 book 元素，而不管它们位于 bookstore 之下的什么位置。</td></tr><tr><td>//@lang</td><td>选取名为 lang 的所有属性。</td></tr></tbody></table><h3 id="谓语（Predicates）"><a href="#谓语（Predicates）" class="headerlink" title="谓语（Predicates）"></a>谓语（Predicates）</h3><p>谓语用来查找某个特定的节点或者包含某个指定的值的节点，被嵌在方括号中。</p><p>在下面的表格中，我们列出了带有谓语的一些路径表达式，以及表达式的结果：</p><table><thead><tr><th>路径表达式</th><th>结果</th></tr></thead><tbody><tr><td>/bookstore/book[1]</td><td>选取属于 bookstore 子元素的第一个 book 元素。</td></tr><tr><td>/bookstore/book[last()]</td><td>选取属于 bookstore 子元素的最后一个 book 元素。</td></tr><tr><td>/bookstore/book[last()-1]</td><td>选取属于 bookstore 子元素的倒数第二个 book 元素。</td></tr><tr><td>/bookstore/book[position()&lt;3]</td><td>选取最前面的两个属于 bookstore 元素的子元素的 book 元素。</td></tr><tr><td>//title[@lang]</td><td>选取所有拥有名为 lang 的属性的 title 元素。</td></tr><tr><td>//title[@lang=’eng’]</td><td>选取所有 title 元素，且这些元素拥有值为 eng 的 lang 属性。</td></tr><tr><td>/bookstore/book[price&gt;35.00]</td><td>选取 bookstore 元素的所有 book 元素，且其中的 price 元素的值须大于 35.00。</td></tr><tr><td>/bookstore/book[price&gt;35.00]/title</td><td>选取 bookstore 元素中的 book 元素的所有 title 元素，且其中的 price 元素的值须大于 35.00。</td></tr></tbody></table><h3 id="选取未知节点"><a href="#选取未知节点" class="headerlink" title="选取未知节点"></a>选取未知节点</h3><p>XPath 通配符可用来选取未知的 XML 元素。</p><table><thead><tr><th>通配符</th><th>描述</th></tr></thead><tbody><tr><td>*</td><td>匹配任何元素节点。</td></tr><tr><td>@*</td><td>匹配任何属性节点。</td></tr><tr><td>node()</td><td>匹配任何类型的节点。</td></tr></tbody></table><p>在下面的表格中，我们列出了一些路径表达式，以及这些表达式的结果：</p><table><thead><tr><th>路径表达式</th><th>结果</th></tr></thead><tbody><tr><td>/bookstore/*</td><td>选取 bookstore 元素的所有子元素。</td></tr><tr><td>//*</td><td>选取文档中的所有元素。</td></tr><tr><td>//title[@*]</td><td>选取所有带有属性的 title 元素。</td></tr></tbody></table><h3 id="选取若干路径"><a href="#选取若干路径" class="headerlink" title="选取若干路径"></a>选取若干路径</h3><p>通过在路径表达式中使用“|”运算符，您可以选取若干个路径。</p><p>实例</p><p>在下面的表格中，我们列出了一些路径表达式，以及这些表达式的结果：</p><table><thead><tr><th>路径表达式</th><th>结果</th></tr></thead><tbody><tr><td>//book/title \</td><td>//book/price</td><td>选取 book 元素的所有 title 和 price 元素。</td></tr><tr><td>//title \</td><td>//price</td><td>选取文档中的所有 title 和 price 元素。</td></tr><tr><td>/bookstore/book/title \</td><td>//price</td><td>选取属于 bookstore 元素的 book 元素的所有 title 元素，以及文档中所有的 price 元素。</td></tr></tbody></table><h3 id="XPath的运算符"><a href="#XPath的运算符" class="headerlink" title="XPath的运算符"></a>XPath的运算符</h3><p>下面列出了可用在 XPath 表达式中的运算符：</p><p><img src="../img/spider/xpath.png" alt="img"></p><h5 id="这些就是XPath的语法内容，在运用到Python抓取时要先转换为xml。"><a href="#这些就是XPath的语法内容，在运用到Python抓取时要先转换为xml。" class="headerlink" title="这些就是XPath的语法内容，在运用到Python抓取时要先转换为xml。"></a>这些就是XPath的语法内容，在运用到Python抓取时要先转换为xml。</h5><h2 id="lxml库"><a href="#lxml库" class="headerlink" title="lxml库"></a>lxml库</h2><blockquote><p>lxml 是 一个HTML/XML的解析器，主要的功能是如何解析和提取 HTML/XML 数据。</p><p>lxml和正则一样，也是用 C 实现的，是一款高性能的 Python HTML/XML 解析器，我们可以利用之前学习的XPath语法，来快速的定位特定元素以及节点信息。</p><p>lxml python 官方文档：<a href="http://lxml.de/index.html" target="_blank" rel="noopener">http://lxml.de/index.html</a></p><p>需要安装C语言库，可使用 pip 安装：<code>pip install lxml</code> （或通过wheel方式安装）</p></blockquote><h3 id="初步使用"><a href="#初步使用" class="headerlink" title="初步使用"></a>初步使用</h3><p>我们利用它来解析 HTML 代码，简单示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"># 使用 lxml 的 etree 库</span><br><span class="line">from lxml import etree </span><br><span class="line"></span><br><span class="line">text = &apos;&apos;&apos;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">         &lt;li class=&quot;item-0&quot;&gt;&lt;a href=&quot;link1.html&quot;&gt;first item&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">         &lt;li class=&quot;item-1&quot;&gt;&lt;a href=&quot;link2.html&quot;&gt;second item&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">         &lt;li class=&quot;item-inactive&quot;&gt;&lt;a href=&quot;link3.html&quot;&gt;third item&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">         &lt;li class=&quot;item-1&quot;&gt;&lt;a href=&quot;link4.html&quot;&gt;fourth item&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">         &lt;li class=&quot;item-0&quot;&gt;&lt;a href=&quot;link5.html&quot;&gt;fifth item&lt;/a&gt; # 注意，此处缺少一个 &lt;/li&gt; 闭合标签</span><br><span class="line">     &lt;/ul&gt;</span><br><span class="line"> &lt;/div&gt;</span><br><span class="line">&apos;&apos;&apos;</span><br><span class="line"></span><br><span class="line">#利用etree.HTML，将字符串解析为HTML文档</span><br><span class="line">html = etree.HTML(text) </span><br><span class="line"></span><br><span class="line"># 按字符串序列化HTML文档</span><br><span class="line">result = etree.tostring(html) </span><br><span class="line"></span><br><span class="line">print(result)</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;&lt;body&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">         &lt;li class=&quot;item-0&quot;&gt;&lt;a href=&quot;link1.html&quot;&gt;first item&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">         &lt;li class=&quot;item-1&quot;&gt;&lt;a href=&quot;link2.html&quot;&gt;second item&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">         &lt;li class=&quot;item-inactive&quot;&gt;&lt;a href=&quot;link3.html&quot;&gt;third item&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">         &lt;li class=&quot;item-1&quot;&gt;&lt;a href=&quot;link4.html&quot;&gt;fourth item&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">         &lt;li class=&quot;item-0&quot;&gt;&lt;a href=&quot;link5.html&quot;&gt;fifth item&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line"> &lt;/div&gt;</span><br><span class="line">&lt;/body&gt;&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>lxml 可以自动修正 html 代码，例子里不仅补全了 li 标签，还添加了 body，html 标签。</p><h3 id="文件读取："><a href="#文件读取：" class="headerlink" title="文件读取："></a>文件读取：</h3><p>除了直接读取字符串，lxml还支持从文件里读取内容。我们新建一个hello.html文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- hello.html --&gt;</span><br><span class="line"></span><br><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">         &lt;li class=&quot;item-0&quot;&gt;&lt;a href=&quot;link1.html&quot;&gt;first item&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">         &lt;li class=&quot;item-1&quot;&gt;&lt;a href=&quot;link2.html&quot;&gt;second item&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">         &lt;li class=&quot;item-inactive&quot;&gt;&lt;a href=&quot;link3.html&quot;&gt;&lt;span class=&quot;bold&quot;&gt;third item&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">         &lt;li class=&quot;item-1&quot;&gt;&lt;a href=&quot;link4.html&quot;&gt;fourth item&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">         &lt;li class=&quot;item-0&quot;&gt;&lt;a href=&quot;link5.html&quot;&gt;fifth item&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">     &lt;/ul&gt;</span><br><span class="line"> &lt;/div&gt;</span><br></pre></td></tr></table></figure><p>再利用 etree.parse() 方法来读取文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">from lxml import etree</span><br><span class="line"></span><br><span class="line"># 读取外部文件 hello.html</span><br><span class="line">html = etree.parse(&apos;./hello.html&apos;)</span><br><span class="line">result = etree.tostring(html, pretty_print=True)</span><br><span class="line"></span><br><span class="line">print(result)</span><br></pre></td></tr></table></figure><p>输出结果与之前相同：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;&lt;body&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">         &lt;li class=&quot;item-0&quot;&gt;&lt;a href=&quot;link1.html&quot;&gt;first item&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">         &lt;li class=&quot;item-1&quot;&gt;&lt;a href=&quot;link2.html&quot;&gt;second item&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">         &lt;li class=&quot;item-inactive&quot;&gt;&lt;a href=&quot;link3.html&quot;&gt;third item&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">         &lt;li class=&quot;item-1&quot;&gt;&lt;a href=&quot;link4.html&quot;&gt;fourth item&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">         &lt;li class=&quot;item-0&quot;&gt;&lt;a href=&quot;link5.html&quot;&gt;fifth item&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line"> &lt;/div&gt;</span><br><span class="line">&lt;/body&gt;&lt;/html&gt;</span><br></pre></td></tr></table></figure><h3 id="XPath实例测试"><a href="#XPath实例测试" class="headerlink" title="XPath实例测试"></a>XPath实例测试</h3><h4 id="1-获取所有的-lt-li-gt-标签"><a href="#1-获取所有的-lt-li-gt-标签" class="headerlink" title="1. 获取所有的 &lt;li&gt; 标签"></a>1. 获取所有的 <code>&lt;li&gt;</code> 标签</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">from lxml import etree</span><br><span class="line"></span><br><span class="line">html = etree.parse(&apos;hello.html&apos;)</span><br><span class="line">print(type(html))  # 显示etree.parse() 返回类型</span><br><span class="line"></span><br><span class="line">result = html.xpath(&apos;//li&apos;)</span><br><span class="line"></span><br><span class="line">print(result)  # 打印&lt;li&gt;标签的元素集合</span><br><span class="line">print(len(result))</span><br><span class="line">print(type(result))</span><br><span class="line">print(type(result[0]))</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;class &apos;lxml.etree._ElementTree&apos;&gt;</span><br><span class="line">[&lt;Element li at 0x2cec9e0&gt;, &lt;Element li at 0x2cec9b8&gt;, &lt;Element li at 0x2cec990&gt;, &lt;Element li at 0x2cec968&gt;, &lt;Element li at 0x2cec6c0&gt;]</span><br><span class="line">5</span><br><span class="line">&lt;class &apos;list&apos;&gt;</span><br><span class="line">&lt;class &apos;lxml.etree._Element&apos;&gt;</span><br></pre></td></tr></table></figure><h4 id="2-继续获取-lt-li-gt-标签的所有-class属性"><a href="#2-继续获取-lt-li-gt-标签的所有-class属性" class="headerlink" title="2. 继续获取&lt;li&gt; 标签的所有 class属性"></a>2. 继续获取<code>&lt;li&gt;</code> 标签的所有 <code>class</code>属性</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">from lxml import etree</span><br><span class="line"></span><br><span class="line">html = etree.parse(&apos;hello.html&apos;)</span><br><span class="line">result = html.xpath(&apos;//li/@class&apos;)</span><br><span class="line"></span><br><span class="line">print(result)</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&apos;item-0&apos;, &apos;item-1&apos;, &apos;item-inactive&apos;, &apos;item-1&apos;, &apos;item-0&apos;]</span><br></pre></td></tr></table></figure><h4 id="3-继续获取-lt-li-gt-标签下hre-为-link1-html-的-lt-a-gt-标签"><a href="#3-继续获取-lt-li-gt-标签下hre-为-link1-html-的-lt-a-gt-标签" class="headerlink" title="3. 继续获取&lt;li&gt;标签下hre 为 link1.html 的 &lt;a&gt; 标签"></a>3. 继续获取<code>&lt;li&gt;</code>标签下<code>hre</code> 为 <code>link1.html</code> 的 <code>&lt;a&gt;</code> 标签</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">from lxml import etree</span><br><span class="line"></span><br><span class="line">html = etree.parse(&apos;hello.html&apos;)</span><br><span class="line">result = html.xpath(&apos;//li/a[@href=&quot;link1.html&quot;]&apos;)</span><br><span class="line"></span><br><span class="line">print(result)</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&lt;Element a at 0x8dc9b8&gt;]</span><br></pre></td></tr></table></figure><h4 id="4-获取-lt-li-gt-标签下的所有-lt-span-gt-标签"><a href="#4-获取-lt-li-gt-标签下的所有-lt-span-gt-标签" class="headerlink" title="4. 获取&lt;li&gt; 标签下的所有 &lt;span&gt; 标签"></a>4. 获取<code>&lt;li&gt;</code> 标签下的所有 <code>&lt;span&gt;</code> 标签</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">from lxml import etree</span><br><span class="line"></span><br><span class="line">html = etree.parse(&apos;hello.html&apos;)</span><br><span class="line"></span><br><span class="line"># result = html.xpath(&apos;//li/span&apos;)</span><br><span class="line"># 注意这么写是不对的：</span><br><span class="line"># 因为 / 是用来获取子元素的，而 &lt;span&gt; 并不是 &lt;li&gt; 的子元素，所以，要用双斜杠</span><br><span class="line"></span><br><span class="line">result = html.xpath(&apos;//li//span&apos;)</span><br><span class="line"></span><br><span class="line">print(result)</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&lt;Element span at 0x363c9e0&gt;]</span><br></pre></td></tr></table></figure><h4 id="5-获取-lt-li-gt-标签下的-lt-a-gt-标签里的所有-class"><a href="#5-获取-lt-li-gt-标签下的-lt-a-gt-标签里的所有-class" class="headerlink" title="5. 获取 &lt;li&gt; 标签下的&lt;a&gt;标签里的所有 class"></a>5. 获取 <code>&lt;li&gt;</code> 标签下的<code>&lt;a&gt;</code>标签里的所有 class</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">from lxml import etree</span><br><span class="line"></span><br><span class="line">html = etree.parse(&apos;hello.html&apos;)</span><br><span class="line">result = html.xpath(&apos;//li/a//@class&apos;)</span><br><span class="line"></span><br><span class="line">print(result)</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&apos;blod&apos;]</span><br></pre></td></tr></table></figure><h4 id="6-获取最后一个-lt-li-gt-的-lt-a-gt-的-href"><a href="#6-获取最后一个-lt-li-gt-的-lt-a-gt-的-href" class="headerlink" title="6. 获取最后一个 &lt;li&gt; 的 &lt;a&gt; 的 href"></a>6. 获取最后一个 <code>&lt;li&gt;</code> 的 <code>&lt;a&gt;</code> 的 href</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">from lxml import etree</span><br><span class="line"></span><br><span class="line">html = etree.parse(&apos;hello.html&apos;)</span><br><span class="line"></span><br><span class="line">result = html.xpath(&apos;//li[last()]/a/@href&apos;)</span><br><span class="line"># 谓语 [last()] 可以找到最后一个元素</span><br><span class="line"></span><br><span class="line">print(result)</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&apos;link5.html&apos;]</span><br></pre></td></tr></table></figure><h4 id="7-获取倒数第二个元素的内容"><a href="#7-获取倒数第二个元素的内容" class="headerlink" title="7. 获取倒数第二个元素的内容"></a>7. 获取倒数第二个元素的内容</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">from lxml import etree</span><br><span class="line"></span><br><span class="line">html = etree.parse(&apos;hello.html&apos;)</span><br><span class="line">result = html.xpath(&apos;//li[last()-1]/a&apos;)</span><br><span class="line"></span><br><span class="line"># text 方法可以获取元素内容</span><br><span class="line">print(result[0].text)</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fourth item</span><br></pre></td></tr></table></figure><h4 id="8-获取-class-值为-bold-的标签名"><a href="#8-获取-class-值为-bold-的标签名" class="headerlink" title="8. 获取 class 值为 bold 的标签名"></a>8. 获取 <code>class</code> 值为 <code>bold</code> 的标签名</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">from lxml import etree</span><br><span class="line"></span><br><span class="line">html = etree.parse(&apos;hello.html&apos;)</span><br><span class="line"></span><br><span class="line">result = html.xpath(&apos;//*[@class=&quot;bold&quot;]&apos;)</span><br><span class="line"></span><br><span class="line"># tag方法可以获取标签名</span><br><span class="line">print(result[0].tag)</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">span</span><br></pre></td></tr></table></figure><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><p>现在我们用XPath来做一个简单的爬虫，我们尝试爬取某个贴吧里的所有帖子，并且将该这个帖子里每个楼层发布的图片下载到本地 。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Spider</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.tiebaName = input(<span class="string">"请需要访问的贴吧："</span>)</span><br><span class="line">        self.beginPage = int(input(<span class="string">"请输入起始页："</span>))</span><br><span class="line">        self.endPage = int(input(<span class="string">"请输入终止页："</span>))</span><br><span class="line"></span><br><span class="line">        self.url = <span class="string">'http://tieba.baidu.com/f'</span></span><br><span class="line">        self.ua_header = &#123;<span class="string">"User-Agent"</span>: <span class="string">"Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1 Trident/5.0;"</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">tieba_spider</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> page <span class="keyword">in</span> range(self.beginPage, self.endPage + <span class="number">1</span>):</span><br><span class="line">            pn = (page - <span class="number">1</span>) * <span class="number">50</span>  <span class="comment"># page number</span></span><br><span class="line">            word = &#123;<span class="string">'pn'</span>: pn, <span class="string">'kw'</span>: self.tiebaName&#125;</span><br><span class="line"></span><br><span class="line">            word = urllib.parse.urlencode(word)  <span class="comment"># 转换成url编码格式（字符串）</span></span><br><span class="line">            url = self.url + <span class="string">"?"</span> + word</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 示例：http://tieba.baidu.com/f? kw=%E7%BE%8E%E5%A5%B3 &amp; pn=50</span></span><br><span class="line">            <span class="comment"># 调用 页面处理函数 load_Page</span></span><br><span class="line">            <span class="comment"># 并且获取页面所有帖子链接,</span></span><br><span class="line">            self.load_page(url)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">load_page</span><span class="params">(self, url)</span>:</span></span><br><span class="line">        <span class="string">"""读取页面内容"""</span></span><br><span class="line">        req = requests.get(url, headers=self.ua_header)</span><br><span class="line">        html = req.text</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 解析html 为 HTML 文档</span></span><br><span class="line">        selector = etree.HTML(html)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 抓取当前页面的所有帖子的url的后半部分，也就是帖子编号</span></span><br><span class="line">        <span class="comment"># http://tieba.baidu.com/p/4884069807里的 “p/4884069807”</span></span><br><span class="line">        links = selector.xpath(<span class="string">'//div[@class="threadlist_lz clearfix"]/div/a/@href'</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># links 类型为 etreeElementString 列表</span></span><br><span class="line">        <span class="comment"># 遍历列表，并且合并成一个帖子地址，调用 图片处理函数 loadImage</span></span><br><span class="line">        <span class="keyword">for</span> link <span class="keyword">in</span> links:</span><br><span class="line">            link = <span class="string">"http://tieba.baidu.com"</span> + link</span><br><span class="line">            self.load_images(link)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 获取图片</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">load_images</span><span class="params">(self, link)</span>:</span></span><br><span class="line">        req = urllib.request.Request(link, headers=self.ua_header)</span><br><span class="line">        html = urllib.request.urlopen(req).read()</span><br><span class="line"></span><br><span class="line">        selector = etree.HTML(html)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 获取这个帖子里所有图片的src路径</span></span><br><span class="line">        images_links = selector.xpath(<span class="string">'//img[@class="BDE_Image"]/@src'</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 依次取出图片路径，下载保存</span></span><br><span class="line">        <span class="keyword">for</span> images_link <span class="keyword">in</span> images_links:</span><br><span class="line">            self.write_images(images_link)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">write_images</span><span class="params">(self, images_link)</span>:</span></span><br><span class="line">        <span class="string">"""将 images 里的二进制内容存入到 userNname 文件中"""</span></span><br><span class="line"></span><br><span class="line">        print(images_link)</span><br><span class="line">        file_name = os.path.basename(images_link)</span><br><span class="line">        print(<span class="string">"正在存储文件 %s ..."</span> % file_name)</span><br><span class="line"></span><br><span class="line">        images = requests.get(images_link).content</span><br><span class="line"></span><br><span class="line">        <span class="keyword">with</span> open(<span class="string">'./images/'</span> + str(file_name), <span class="string">'wb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">            f.write(images)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    <span class="comment"># 首先创建爬虫对象</span></span><br><span class="line">    mySpider = Spider()</span><br><span class="line">    <span class="comment"># 调用爬虫对象的方法，开始工作</span></span><br><span class="line">    mySpider.tieba_spider()</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 爬虫 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 爬虫 </tag>
            
            <tag> XPath </tag>
            
            <tag> lxml </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Flask(二)</title>
      <link href="/post/dc6a7e6c.html"/>
      <url>/post/dc6a7e6c.html</url>
      <content type="html"><![CDATA[<h3 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h3><p>Flask除请求对象之外，还有一个 session 对象。它允许你在不同请求间存储特定用户的信息。它是在 Cookies 的基础上实现的，并且对 Cookies 进行密钥签名要使用会话，你需要设置一个密钥。 </p><ul><li>设置：session[‘username’] ＝ ‘xxx’</li><li>删除：session.pop(‘username’, None)</li></ul><h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, session, redirect, url_for, escape, request</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route('/')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="string">'username'</span> <span class="keyword">in</span> session:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'Logged in as %s'</span> % escape(session[<span class="string">'username'</span>])</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'You are not logged in'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route('/login', methods=['GET', 'POST'])</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">login</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">'POST'</span>:</span><br><span class="line">        session[<span class="string">'username'</span>] = request.form[<span class="string">'username'</span>]</span><br><span class="line">        <span class="keyword">return</span> redirect(url_for(<span class="string">'index'</span>))</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'''</span></span><br><span class="line"><span class="string">        &lt;form action="" method="post"&gt;</span></span><br><span class="line"><span class="string">            &lt;p&gt;&lt;input type=text name=username&gt;</span></span><br><span class="line"><span class="string">            &lt;p&gt;&lt;input type=submit value=Login&gt;</span></span><br><span class="line"><span class="string">        &lt;/form&gt;</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route('/logout')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">logout</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># remove the username from the session if it's there</span></span><br><span class="line">    session.pop(<span class="string">'username'</span>, <span class="keyword">None</span>)</span><br><span class="line">    <span class="keyword">return</span> redirect(url_for(<span class="string">'index'</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># set the secret key.  keep this really secret:</span></span><br><span class="line">app.secret_key = <span class="string">'A0Zr98j/3yX R~XHH!jmN]LWX/,?RT'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    app.run()</span><br></pre></td></tr></table></figure><h4 id="第三方session（我喜欢用这种类型）"><a href="#第三方session（我喜欢用这种类型）" class="headerlink" title="第三方session（我喜欢用这种类型）"></a>第三方session（我喜欢用这种类型）</h4><p>这里使用Redis类型，首先在虚拟环境安装两个包，分别是<code>pip install redis</code>和<code>pip install flask-session</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, session, redirect</span><br><span class="line"><span class="keyword">from</span> flask_session <span class="keyword">import</span> Session</span><br><span class="line"><span class="keyword">from</span> redis <span class="keyword">import</span> Redis</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line">app.debug = <span class="keyword">True</span></span><br><span class="line"><span class="comment"># 这里可以任意填写一个字符串，我这里是采用base64.b64encode(os.urandom(48))</span></span><br><span class="line">app.secret_key = <span class="string">'ix4En7l1Hau10aPq8kv8tuzcVl1s2Zo6eA+5+R+CXor8G3Jo0IJvcj001jz3XuXl'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app.config[<span class="string">'SESSION_TYPE'</span>] = <span class="string">'redis'</span></span><br><span class="line">app.config[<span class="string">'SESSION_REDIS'</span>] = Redis(host=<span class="string">'127.0.0.1'</span>, port=<span class="string">'6379'</span>)</span><br><span class="line">Session(app)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route('/login')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">login</span><span class="params">()</span>:</span></span><br><span class="line">    session[<span class="string">'username'</span>] = <span class="string">'gavinliu'</span></span><br><span class="line">    <span class="keyword">return</span> redirect(<span class="string">'/index'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route('/index')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">()</span>:</span></span><br><span class="line">    name = session[<span class="string">'username'</span>]</span><br><span class="line">    <span class="keyword">return</span> name</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    app.run()</span><br></pre></td></tr></table></figure><h3 id="蓝图"><a href="#蓝图" class="headerlink" title="蓝图"></a>蓝图</h3><h4 id="什么是蓝图"><a href="#什么是蓝图" class="headerlink" title="什么是蓝图"></a>什么是蓝图</h4><p>在Flask项目中可以用Blueprint(蓝图)实现模块化的应用，使用蓝图可以让应用层次更清晰，开发者更容易去维护和开发项目。蓝图将作用于相同的URL前缀的请求地址，将具有相同前缀的请求都放在一个模块中，这样查找问题，一看路由就很快的可以找到对应的视图，并解决问题了。 </p><h4 id="使用蓝图"><a href="#使用蓝图" class="headerlink" title="使用蓝图"></a>使用蓝图</h4><h5 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install flask_blueprint</span><br></pre></td></tr></table></figure><h5 id="实例化蓝图"><a href="#实例化蓝图" class="headerlink" title="实例化蓝图"></a>实例化蓝图</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">blue = Blueprint(&apos;first&apos;，__name__)</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意：</strong>Blueprint中传入了两个参数，第一个是蓝图的名称，第二个是蓝图所在的包或模块，<code>__name__</code>代表当前模块名或者包名 </p></blockquote><h5 id="注册蓝图"><a href="#注册蓝图" class="headerlink" title="注册蓝图"></a>注册蓝图</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line">app.register_blueprint(blue, url_prefix=<span class="string">'/user'</span>)</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意：</strong>注意：第一个参数即我们定义初始化定义的蓝图对象，第二个参数url_prefix表示该蓝图下，所有的url请求必须以/user开始。这样对一个模块的url可以很好的进行统一管理 </p></blockquote><h5 id="使用蓝图-1"><a href="#使用蓝图-1" class="headerlink" title="使用蓝图"></a>使用蓝图</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@blue.route('/', methods=['GET', 'POST'], endpoint='index')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 视图函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Hello World'</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>注意：</strong>这时候访问应该是127.0.0.1:5000/user/ </p></blockquote><h5 id="url-for反向解析"><a href="#url-for反向解析" class="headerlink" title="url_for反向解析"></a>url_for反向解析</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">url_for(endpoint, 参数名=value)  # 如果在路由上没有配置endpoint，第一个参数可以传递&quot;蓝图中定义的第一个参数.函数名&quot;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> url_for, redirect</span><br><span class="line"></span><br><span class="line"><span class="meta">@blue.route('/redirect/')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_redirect</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> redirect(url_for(<span class="string">'index'</span>))</span><br></pre></td></tr></table></figure><h3 id="请求扩展（装饰器实现）"><a href="#请求扩展（装饰器实现）" class="headerlink" title="请求扩展（装饰器实现）"></a>请求扩展（装饰器实现）</h3><ul><li>@app.before_request</li><li>@app.after_request</li><li>@app.errorhandler                # 状态码错误信息</li><li>@app.before_first_request   # 请求来只执行第一次</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line">app.debug = <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.before_request</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">process_request1</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">    print(<span class="string">'process_request1进来了'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.before_request</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">process_request2</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">    print(<span class="string">'process_request2进来了'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.after_request</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">process_response1</span><span class="params">(response)</span>:</span></span><br><span class="line">    print(<span class="string">'process_response1走了'</span>)</span><br><span class="line">    <span class="keyword">return</span> response</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.after_request</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">process_response2</span><span class="params">(response)</span>:</span></span><br><span class="line">    print(<span class="string">'process_response2走了'</span>)</span><br><span class="line">    <span class="keyword">return</span> response</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.before_first_request</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">first</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">    print(<span class="string">'first'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.errorhandler(404)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">error_404</span><span class="params">(arg)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'404错误了'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 可自定义模板</span></span><br><span class="line"><span class="meta">@app.template_global()</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sb</span><span class="params">(a1, a2)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> a1 + a2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用方式：&#123;&#123;sb(1,2)&#125;&#125;</span></span><br><span class="line"><span class="meta">@app.template_filter()</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">db</span><span class="params">(a1, a2, a3)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> a1 + a2 + a3</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用方式：&#123;&#123; 1|db(2,3)&#125;&#125;</span></span><br><span class="line"><span class="meta">@app.route('/')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'index函数'</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Hello World!'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    app.run()</span><br></pre></td></tr></table></figure><p>这个执行流程类似django中间件，可以参考<a href="https://gavinliu4011.github.io/post/11a0df73.html">django中间件</a></p><h3 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h3><p>其实Flask也有中间件，Django中也有中间件，但是Flask中的请求扩展就相当于Django中的中间件，而Django中的中间件却不相当于Flask中的中间件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route('/')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Hello World!'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Md</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, old_wsgi_app)</span>:</span></span><br><span class="line">        self.old_wsgi_app = old_wsgi_app</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, environ, start_response)</span>:</span></span><br><span class="line">        print(<span class="string">'开始之前'</span>)</span><br><span class="line">        ret = self.old_wsgi_app(environ, start_response)</span><br><span class="line">        print(<span class="string">'结束之后'</span>)</span><br><span class="line">        <span class="keyword">return</span> ret</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    app.wsgi_app = Md(app.wsgi_app)</span><br><span class="line">    app.run()</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Flask </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Flask </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Flask(一)</title>
      <link href="/post/735be50e.html"/>
      <url>/post/735be50e.html</url>
      <content type="html"><![CDATA[<h3 id="Flask介绍"><a href="#Flask介绍" class="headerlink" title="Flask介绍"></a>Flask介绍</h3><p>Flask是一个用Python编写的Web应用程序框架。 它由Armin Ronacher开发，他领导着一个名为Pocco的Python爱好者的国际组织。 Flask基于Werkzeug WSGI工具包和Jinja2模板引擎。 </p><h4 id="WSGI"><a href="#WSGI" class="headerlink" title="WSGI"></a>WSGI</h4><p>Web服务器网关接口(WSGI)已被采纳为Python Web应用程序开发的标准。 WSGI是Web服务器和Web应用程序之间通用接口的规范。 </p><h4 id="WERKZEUG"><a href="#WERKZEUG" class="headerlink" title="WERKZEUG"></a>WERKZEUG</h4><p>它是一个WSGI工具包，它实现了请求，响应对象和其他实用程序功能。 这可以在其上构建Web框架。 Flask框架使用Werkzeug作为其一个基础模块之一。 </p><h3 id="浅谈Django、Flask和Tornado区别？"><a href="#浅谈Django、Flask和Tornado区别？" class="headerlink" title="浅谈Django、Flask和Tornado区别？"></a>浅谈Django、Flask和Tornado区别？</h3><ul><li><strong>Django：</strong>简单的说Django是一个大而全的Web框架，内置了很多组件，ORM、admin、Form、</li></ul><p>ModelForm、中间件、信号和缓存等。基于wsgi协议部署的，使用wsgiref模块实现此协议；</p><ul><li><strong>Flask：</strong>微型的小而精的Web框架，可扩展性强，内置的组件很少，需要引入第三方组件实现功能业务，如果开发简单的项目，使用Flask比较快速和方便。如果开发大型项目，需要引入大量的第三方组件，这时Flask会越来越像Django框架。基于wsgi协议部署，使用werkzeug模块实现此协议，模板系统由 Jinja2提<br>供。</li><li><strong>Tornado：</strong>是一个轻量级的Web框架，可扩展性强，用于快速开发简单程序，用于强大的异步非阻塞<br>和内置WebSocket功能。</li></ul><h3 id="Flask快速入门"><a href="#Flask快速入门" class="headerlink" title="Flask快速入门"></a>Flask快速入门</h3><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>在创建项目之前我们需要安装Flask，当然在这之前应该创建虚拟环境,在虚拟环境中安装Flask，在这里就不多说：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install Flask</span><br></pre></td></tr></table></figure><h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route('/')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello_world</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Hello World!'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    app.run()</span><br></pre></td></tr></table></figure><p>参数介绍：</p><p>flask(import_name, static_url_path, template_folder, instance_path, instance_relative_config, root_path, static_folder)</p><ul><li><strong>import_name：</strong>要创建的app的名称 </li><li><strong>static_url_path：</strong>用来指定url路径中<code>static</code>代表的路径，可以看作别名，类似Django中的<code>STATICFILES_DIRS</code>配置，static用来存放静态文件，默认为<code>static</code> </li><li><strong>static_folder：</strong>指定静态文件的存放目录，默认为<code>static</code> </li><li><strong>template_folder：</strong>指定模板文件的存放目录，默认为<code>templates</code> </li><li><strong>root_path：</strong>应用搜索<code>static、templates</code>等目录的根目录，也就是说，会在<code>root_path</code>指定的目录下搜索<code>static、templates</code>文件夹 <ul><li>如果你没有指定<code>root_path</code>，那么Flask就会将<code>import_name</code>所在的目录作为<code>root_oath</code></li></ul></li><li><strong>instance_relative_config：</strong>这个参数只在为app生成配置的时候有用，app在生成Config的时候，<code>make_config</code>传递进入的是<code>root_path</code>还是在实例化<code>app</code>时指定的<code>instance_path</code></li><li><strong>instance_path：</strong>当<code>instance_relative_config=True</code>的时候该参数才有效 ，如果<code>instance_path=None(默认)</code>，默认搜索配置文件的路径就是<code>root_path</code>下的<code>instance/</code>目录</li></ul><h4 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h4><p>flask中的配置文件是一个flask.config.Config对象（继承字典）,默认配置为 :</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        &apos;DEBUG&apos;: get_debug_flag(default=False),  # 是否开启Debug模式</span><br><span class="line">        &apos;TESTING&apos;: False,  # 是否开启测试模式</span><br><span class="line">        &apos;PROPAGATE_EXCEPTIONS&apos;: None,</span><br><span class="line">        &apos;PRESERVE_CONTEXT_ON_EXCEPTION&apos;: None,</span><br><span class="line">        &apos;SECRET_KEY&apos;: None,</span><br><span class="line">        &apos;PERMANENT_SESSION_LIFETIME&apos;: timedelta(days=31),</span><br><span class="line">        &apos;USE_X_SENDFILE&apos;: False,</span><br><span class="line">        &apos;LOGGER_NAME&apos;: None,</span><br><span class="line">        &apos;LOGGER_HANDLER_POLICY&apos;: &apos;always&apos;,</span><br><span class="line">        &apos;SERVER_NAME&apos;: None,</span><br><span class="line">        &apos;APPLICATION_ROOT&apos;: None,</span><br><span class="line">        &apos;SESSION_COOKIE_NAME&apos;: &apos;session&apos;,</span><br><span class="line">        &apos;SESSION_COOKIE_DOMAIN&apos;: None,</span><br><span class="line">        &apos;SESSION_COOKIE_PATH&apos;: None,</span><br><span class="line">        &apos;SESSION_COOKIE_HTTPONLY&apos;: True,</span><br><span class="line">        &apos;SESSION_COOKIE_SECURE&apos;: False,</span><br><span class="line">        &apos;SESSION_REFRESH_EACH_REQUEST&apos;: True,</span><br><span class="line">        &apos;MAX_CONTENT_LENGTH&apos;: None,</span><br><span class="line">        &apos;SEND_FILE_MAX_AGE_DEFAULT&apos;: timedelta(hours=12),</span><br><span class="line">        &apos;TRAP_BAD_REQUEST_ERRORS&apos;: False,</span><br><span class="line">        &apos;TRAP_HTTP_EXCEPTIONS&apos;: False,</span><br><span class="line">        &apos;EXPLAIN_TEMPLATE_LOADING&apos;: False,</span><br><span class="line">        &apos;PREFERRED_URL_SCHEME&apos;: &apos;http&apos;,</span><br><span class="line">        &apos;JSON_AS_ASCII&apos;: True,</span><br><span class="line">        &apos;JSON_SORT_KEYS&apos;: True,</span><br><span class="line">        &apos;JSONIFY_PRETTYPRINT_REGULAR&apos;: True,</span><br><span class="line">        &apos;JSONIFY_MIMETYPE&apos;: &apos;application/json&apos;,</span><br><span class="line">        &apos;TEMPLATES_AUTO_RELOAD&apos;: None,</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>如果需要修改配置，可以根据下面的方式修改：</p><ol><li><p>方式一</p><p>app.config[DEBUG]=True</p><blockquote><p>注意：由于Config对象本质上是字典，可以使用app.config.update(…)</p></blockquote></li><li><p>方式二</p><p>app.config.form_pyfile(‘python文件名称’)</p><p>如:settings.py </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DEBUG = <span class="keyword">True</span></span><br></pre></td></tr></table></figure><p>app.config.from_pyfile(‘settings.py’) </p></li><li><p>方式三</p><p>app.config.form_envvar(‘环境变量名称’)</p><p>环境变量的值为python文件名称，内部调用form_pyfile方法</p></li><li><p>方式四</p><p>app.config.form_json(‘json文件名称’)</p><p>json文件必须是json格式，内部会执行json.loads</p></li><li><p>方式五</p><p>app.config.from_mapping({‘DEBUG’:True}) </p></li><li><p>方式六（推荐使用）</p><p>app.config.from_object(‘python类或类的路径’)   #默认从根目录开始 </p><ul><li>settings.py文件</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">class Config(object):</span><br><span class="line">    &quot;&quot;&quot;应用程序配置类&quot;&quot;&quot;</span><br><span class="line">    # 开启调试模式</span><br><span class="line">    DEBUG = True</span><br><span class="line"></span><br><span class="line">    # logging等级</span><br><span class="line">    LOGGIONG_LEVEL = logging.DEBUG</span><br><span class="line">    # flask-sqlalchemy使用的参数</span><br><span class="line">    SQLALCHEMY_DATABASE_URI = &apos;mysql+pymysql://root:root@127.0.0.1:3306/ehome&apos;</span><br><span class="line">    # 追踪数据库的修改行为，如果不设置会报警告，不影响代码的执行</span><br><span class="line">    SQLALCHEMY_TRACK_MODIFICATIONS = True</span><br><span class="line">    # 显示sql语句</span><br><span class="line">    # SQLALCHEMY_ECHO = True</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class DevelopConfig(Config):</span><br><span class="line">    &quot;&quot;&quot;开发阶段下的配置子类&quot;&quot;&quot;</span><br><span class="line">    # logging等级</span><br><span class="line">    LOGGIONG_LEVEL = logging.DEBUG</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class UnitTestConfig(Config):</span><br><span class="line">    &quot;&quot;&quot;单元测试配置子类&quot;&quot;&quot;</span><br><span class="line">    # logging等级</span><br><span class="line">    LOGGIONG_LEVEL = logging.DEBUG</span><br><span class="line">    SQLALCHEMY_DATABASE_URI = &apos;mysql://root:root@127.0.0.1:3306/ehome_test&apos;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class ProductionConfig(Config):</span><br><span class="line">    &quot;&quot;&quot;生产环境下配置子类&quot;&quot;&quot;</span><br><span class="line">    # logging等级</span><br><span class="line">    LOGGIONG_LEVEL = logging.WARNING</span><br><span class="line">    DEBUG = False</span><br><span class="line">    SQLALCHEMY_DATABASE_URI = &apos;mysql://root:root@47.106.93.190:3306127.0.0.1:3306/ehome&apos;</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意：</strong>settings.py文件默认路径要放在程序root_path目录，如果instance_relative_config为<code>True</code>，则就是instance_path目录</p></blockquote></li></ol><h4 id="路由系统"><a href="#路由系统" class="headerlink" title="路由系统"></a>路由系统</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># @app.route('/user/&lt;username&gt;')</span></span><br><span class="line"><span class="comment"># @app.route('/post/&lt;int:post_id&gt;')</span></span><br><span class="line"><span class="comment"># @app.route('/post/float:post_id')</span></span><br><span class="line"><span class="comment"># @app.route('/post/path:path')</span></span><br><span class="line"><span class="comment"># @app.route('/login', methods=['GET', 'POST'])</span></span><br></pre></td></tr></table></figure><p>以上五种路由是最常用的，下面再来了解一下路由的执行过程：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@app.route('/', methods=['GET','POST'], endpoint='hello')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Hello World!'</span></span><br></pre></td></tr></table></figure><ol><li><p>当执行app.route(‘/‘,methods=[‘GET’,’POST’],endpoint=’hello’)时会执行如下代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">route</span><span class="params">(self, rule, **options)</span>:</span></span><br><span class="line">    <span class="comment"># self 是app对象</span></span><br><span class="line">    <span class="comment"># rule = '/'</span></span><br><span class="line">    <span class="comment"># options = &#123;methods=['GET','POST'], endpoint='hello'&#125;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decorator</span><span class="params">(f)</span>:</span></span><br><span class="line">        endpoint = options.pop(<span class="string">'endpoint'</span>, <span class="keyword">None</span>)</span><br><span class="line">        self.add_url_rule(rule, endpoint, f, **options)</span><br><span class="line">    <span class="keyword">return</span> f</span><br><span class="line">    <span class="keyword">return</span> decorator</span><br></pre></td></tr></table></figure><p>实质就是<strong>decorator = app.route(‘/‘,methods=[‘GET’,’POST’],endpoint=’hello’)</strong></p></li><li><p>有返回值后，实际上就是<strong>@decorator</strong>，这次执行decorator函数会把index函数当做参数传入</p></li></ol><p>我们这里写的路由其实就是执行了<strong>app.add_url_rule(‘/‘, ‘hello’, index, methods=[‘GET’,’POST‘])</strong>这句代码，这就跟django框架一样了</p><p>在来看看 @app.route和app.add_url_rule常用参数（只是部分）：</p><ul><li><p>rule：URL规则</p></li><li><p>view_func：视图函数名称</p></li><li><p>defaults=None：默认值，当URL中无参数，函数需要参数时，使用defaults={‘k’:’v’}为函数提供参数</p></li><li><p>endpoint=None：名称，用于反向生成URL，即： url_for(‘名称’)</p></li><li><p>methods=None：允许的请求方式，如：[‘GET’,’POST’]</p></li><li><p>strict_slashes=None：对URL最后的 / 符号是否严格要求</p></li><li><p>redirect_to=None：重定向到指定地址，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@app.route(&apos;/index/&lt;int:nid&gt;&apos;, redirect_to=&apos;/home/&lt;nid&gt;&apos;)</span><br><span class="line">或</span><br><span class="line">def func(adapter, nid):</span><br><span class="line">return &quot;/home/888&quot;</span><br><span class="line">@app.route(&apos;/index/&lt;int:nid&gt;&apos;, redirect_to=func)</span><br></pre></td></tr></table></figure></li></ul><p>所有的路由系统都是基于一下对应关系来处理 ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">DEFAULT_CONVERTERS = &#123;</span><br><span class="line">    &apos;default&apos;:          UnicodeConverter,</span><br><span class="line">    &apos;string&apos;:           UnicodeConverter,</span><br><span class="line">    &apos;any&apos;:              AnyConverter,</span><br><span class="line">    &apos;path&apos;:             PathConverter,</span><br><span class="line">    &apos;int&apos;:              IntegerConverter,</span><br><span class="line">    &apos;float&apos;:            FloatConverter,</span><br><span class="line">    &apos;uuid&apos;:             UUIDConverter,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：此配置在werkzeug包下routing.py文件中</p></blockquote><p>以上的路由其实已经够用了，但是不排除有一些比较另类的，这时可以考虑自定制正则路由匹配</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, views, url_for</span><br><span class="line"><span class="keyword">from</span> werkzeug.routing <span class="keyword">import</span> BaseConverter</span><br><span class="line"></span><br><span class="line">app = Flask(import_name=__name__)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RegexConverter</span><span class="params">(BaseConverter)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    自定义URL匹配正则表达式</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, url_map, regex)</span>:</span></span><br><span class="line">        super(RegexConverter, self).__init__(url_map)</span><br><span class="line">        self.regex = regex</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">to_python</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        路由匹配时，匹配成功后传递给视图函数中参数的值</span></span><br><span class="line"><span class="string">        :param value: </span></span><br><span class="line"><span class="string">        :return: </span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> int(value)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">to_url</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        使用url_for反向生成URL时，传递的参数经过该方法处理，返回的值用于生成URL中的参数</span></span><br><span class="line"><span class="string">        :param value: </span></span><br><span class="line"><span class="string">        :return: </span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        val = super(RegexConverter, self).to_url(value)</span><br><span class="line">        <span class="keyword">return</span> val</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="comment"># 为app中的url路由添加正则表达式匹配</span></span><br><span class="line">app.url_map.converters[<span class="string">'regex'</span>] = RegexConverter</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route('/index/&lt;regex("\d+"):nid&gt;')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">(nid)</span>:</span></span><br><span class="line">    print(url_for(<span class="string">'index'</span>, nid=<span class="string">'666'</span>))</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Index'</span></span><br></pre></td></tr></table></figure><h4 id="请求和响应"><a href="#请求和响应" class="headerlink" title="请求和响应"></a>请求和响应</h4><h5 id="请求相关信息"><a href="#请求相关信息" class="headerlink" title="请求相关信息"></a>请求相关信息</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># request.method</span></span><br><span class="line"><span class="comment"># request.args</span></span><br><span class="line"><span class="comment"># request.form</span></span><br><span class="line"><span class="comment"># request.values</span></span><br><span class="line"><span class="comment"># request.cookies</span></span><br><span class="line"><span class="comment"># request.headers</span></span><br><span class="line"><span class="comment"># request.path</span></span><br><span class="line"><span class="comment"># request.full_path</span></span><br><span class="line"><span class="comment"># request.script_root</span></span><br><span class="line"><span class="comment"># request.url</span></span><br><span class="line"><span class="comment"># request.base_url</span></span><br><span class="line"><span class="comment"># request.url_root</span></span><br><span class="line"><span class="comment"># request.host_url</span></span><br><span class="line"><span class="comment"># request.host</span></span><br><span class="line"><span class="comment"># request.files</span></span><br><span class="line"><span class="comment"># obj = request.files['the_file_name']</span></span><br><span class="line"><span class="comment"># obj.save('/var/www/uploads/' + secure_filename(f.filename))</span></span><br></pre></td></tr></table></figure><h5 id="响应相关信息"><a href="#响应相关信息" class="headerlink" title="响应相关信息"></a>响应相关信息</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># return '字符串'</span></span><br><span class="line"><span class="comment"># return render_template('html模板路径',**&#123;&#125;)</span></span><br><span class="line"><span class="comment"># return redirect('/index.html')</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># response = make_response(render_template('index.html'))</span></span><br><span class="line"><span class="comment"># response是flask.wrappers.Response类型</span></span><br><span class="line"><span class="comment"># response.delete_cookie('key')</span></span><br><span class="line"><span class="comment"># response.set_cookie('key', 'value')</span></span><br><span class="line"><span class="comment"># response.headers['X-Something'] = 'A value'</span></span><br><span class="line"><span class="comment"># return response</span></span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Flask </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Flask </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Python版RabbitMQ消息队列之RPC（六）</title>
      <link href="/post/8d587096.html"/>
      <url>/post/8d587096.html</url>
      <content type="html"><![CDATA[<h2 id="远程过程调用（RPC）"><a href="#远程过程调用（RPC）" class="headerlink" title="远程过程调用（RPC）"></a>远程过程调用（RPC）</h2><p>在第二篇教程中我们介绍了如何使用工作队列（work queue）在多个工作者（woker）中间分发耗时的任务。</p><p>可是如果我们需要将一个函数运行在远程计算机上并且等待从那儿获取结果时，该怎么办呢？这就是另外的故事了。这种模式通常被称为远程过程调用（Remote Procedure Call）或者RPC。</p><p>这篇教程中，我们会使用RabbitMQ来构建一个RPC系统：包含一个客户端和一个RPC服务器。现在的情况是，我们没有一个值得被分发的足够耗时的任务，所以接下来，我们会创建一个模拟RPC服务来返回斐波那契数列。</p><h3 id="客户端接口"><a href="#客户端接口" class="headerlink" title="客户端接口"></a>客户端接口</h3><p>为了展示RPC服务如何使用，我们创建了一个简单的客户端类。它会暴露出一个名为“call”的方法用来发送一个RPC请求，并且在收到回应前保持阻塞。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fibonacci_rpc = FibonacciRpcClient()</span><br><span class="line">result = fibonacci_rpc.call(4)</span><br><span class="line">print(&quot;fib(4) is %r&quot; % (result,))</span><br></pre></td></tr></table></figure><blockquote><h4 id="关于RPC的注意事项："><a href="#关于RPC的注意事项：" class="headerlink" title="关于RPC的注意事项："></a>关于RPC的注意事项：</h4><p>尽管RPC在计算领域是一个常用模式，但它也经常被诟病。当一个问题被抛出的时候，程序员往往意识不到这到底是由本地调用还是由较慢的RPC调用引起的。同样的困惑还来自于系统的不可预测性和给调试工作带来的不必要的复杂性。跟软件精简不同的是，滥用RPC会导致不可维护的<a href="http://zh.wikipedia.org/wiki/%E9%9D%A2%E6%9D%A1%E5%BC%8F%E4%BB%A3%E7%A0%81" target="_blank" rel="noopener">面条代码</a>.</p><p>考虑到这一点，牢记以下建议：</p><p>确保能够明确的搞清楚哪个函数是本地调用的，哪个函数是远程调用的。给你的系统编写文档。保持各个组件间的依赖明确。处理错误案例。明了客户端改如何处理RPC服务器的宕机和长时间无响应情况。</p><p>当对避免使用RPC有疑问的时候。如果可以的话，你应该尽量使用异步管道来代替RPC类的阻塞。结果被异步地推送到下一个计算场景。</p></blockquote><h3 id="回调队列"><a href="#回调队列" class="headerlink" title="回调队列"></a>回调队列</h3><p>一般来说通过RabbitMQ来实现RPC是很容易的。一个客户端发送请求信息，服务器端将其应用到一个回复信息中。为了接收到回复信息，客户端需要在发送请求的时候同时发送一个回调队列（callback queue）的地址。我们试试看：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">result = channel.queue_declare(exclusive=True)</span><br><span class="line">callback_queue = result.method.queue</span><br><span class="line"></span><br><span class="line">channel.basic_publish(exchange=&apos;&apos;,</span><br><span class="line">                      routing_key=&apos;rpc_queue&apos;,</span><br><span class="line">                      properties=pika.BasicProperties(</span><br><span class="line">                            reply_to = callback_queue,</span><br><span class="line">                            ),</span><br><span class="line">                      body=request)</span><br><span class="line"></span><br><span class="line"># ... and some code to read a response message from the callback_queue ...</span><br></pre></td></tr></table></figure><blockquote><h4 id="消息属性"><a href="#消息属性" class="headerlink" title="消息属性"></a>消息属性</h4><p>AMQP协议给消息预定义了一系列的14个属性。大多数属性很少会用到，除了以下几个：</p><ul><li>delivery_mode（投递模式）：将消息标记为持久的（值为2）或暂存的（除了2之外的其他任何值）。第二篇教程里接触过这个属性，记得吧？</li><li>content_type（内容类型）:用来描述编码的mime-type。例如在实际使用中常常使用application/json来描述JOSN编码类型。</li><li>reply_to（回复目标）：通常用来命名回调队列。</li><li>correlation_id（关联标识）：用来将RPC的响应和请求关联起来。</li></ul></blockquote><h3 id="关联标识"><a href="#关联标识" class="headerlink" title="关联标识"></a>关联标识</h3><p>上边介绍的方法中，我们建议给每一个RPC请求新建一个回调队列。这不是一个高效的做法，幸好这儿有一个更好的办法 —— 我们可以为每个客户端只建立一个独立的回调队列。</p><p>这就带来一个新问题，当此队列接收到一个响应的时候它无法辨别出这个响应是属于哪个请求的。<strong>correlation_id</strong> 就是为了解决这个问题而来的。我们给每个请求设置一个独一无二的值。稍后，当我们从回调队列中接收到一个消息的时候，我们就可以查看这条属性从而将响应和请求匹配起来。如果我们接手到的消息的correlation_id是未知的，那就直接销毁掉它，因为它不属于我们的任何一条请求。</p><p>你也许会问，为什么我们接收到未知消息的时候不抛出一个错误，而是要将它忽略掉？这是为了解决服务器端有可能发生的竞争情况。尽管可能性不大，但RPC服务器还是有可能在已将应答发送给我们但还未将确认消息发送给请求的情况下死掉。如果这种情况发生，RPC在重启后会重新处理请求。这就是为什么我们必须在客户端优雅的处理重复响应，同时RPC也需要尽可能保持幂等性。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><img src="http://www.rabbitmq.com/img/tutorials/python-six.png" alt="img"></p><p>我们的RPC如此工作:</p><ul><li>当客户端启动的时候，它创建一个匿名独享的回调队列。</li><li>在RPC请求中，客户端发送带有两个属性的消息：一个是设置回调队列的 <em>reply_to</em> 属性，另一个是设置唯一值的 <em>correlation_id</em> 属性。</li><li>将请求发送到一个 <em>rpc_queue</em> 队列中。</li><li>RPC工作者（又名：服务器）等待请求发送到这个队列中来。当请求出现的时候，它执行他的工作并且将带有执行结果的消息发送给reply_to字段指定的队列。</li><li>客户端等待回调队列里的数据。当有消息出现的时候，它会检查correlation_id属性。如果此属性的值与请求匹配，将它返回给应用。</li></ul><h2 id="整合到一起"><a href="#整合到一起" class="headerlink" title="整合到一起"></a>整合到一起</h2><p>rpc_server.py代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line">import pika</span><br><span class="line"></span><br><span class="line">connection = pika.BlockingConnection(pika.ConnectionParameters(</span><br><span class="line">        host=&apos;localhost&apos;))</span><br><span class="line"></span><br><span class="line">channel = connection.channel()</span><br><span class="line"></span><br><span class="line">channel.queue_declare(queue=&apos;rpc_queue&apos;)</span><br><span class="line"></span><br><span class="line">def fib(n):</span><br><span class="line">    if n == 0:</span><br><span class="line">        return 0</span><br><span class="line">    elif n == 1:</span><br><span class="line">        return 1</span><br><span class="line">    else:</span><br><span class="line">        return fib(n-1) + fib(n-2)</span><br><span class="line"></span><br><span class="line">def on_request(ch, method, props, body):</span><br><span class="line">    n = int(body)</span><br><span class="line"></span><br><span class="line">    print(&quot; [.] fib(%s)&quot;  % (n,))</span><br><span class="line">    response = fib(n)</span><br><span class="line"></span><br><span class="line">    ch.basic_publish(exchange=&apos;&apos;,</span><br><span class="line">                     routing_key=props.reply_to,</span><br><span class="line">                     properties=pika.BasicProperties(correlation_id = \</span><br><span class="line">                                                     props.correlation_id),</span><br><span class="line">                     body=str(response))</span><br><span class="line">    ch.basic_ack(delivery_tag = method.delivery_tag)</span><br><span class="line"></span><br><span class="line">channel.basic_qos(prefetch_count=1)</span><br><span class="line">channel.basic_consume(on_request, queue=&apos;rpc_queue&apos;)</span><br><span class="line"></span><br><span class="line">print(&quot; [x] Awaiting RPC requests&quot;)</span><br><span class="line">channel.start_consuming()</span><br></pre></td></tr></table></figure><p>服务器端代码相当简单：</p><ul><li>（4）像往常一样，我们建立连接，声明队列</li><li>（11）我们声明我们的fibonacci函数，它假设只有合法的正整数当作输入。（别指望这个函数能处理很大的数值，函数递归你们都懂得…）</li><li>（19）我们为 basic_consume 声明了一个回调函数，这是RPC服务器端的核心。它执行实际的操作并且作出响应。</li><li>（32）或许我们希望能在服务器上多开几个线程。为了能将负载平均地分摊到多个服务器，我们需要将 prefetch_count 设置好。</li></ul><p>rpc_client.py 代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line">import pika</span><br><span class="line">import uuid</span><br><span class="line"></span><br><span class="line">class FibonacciRpcClient(object):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.connection = pika.BlockingConnection(pika.ConnectionParameters(</span><br><span class="line">                host=&apos;localhost&apos;))</span><br><span class="line"></span><br><span class="line">        self.channel = self.connection.channel()</span><br><span class="line"></span><br><span class="line">        result = self.channel.queue_declare(exclusive=True)</span><br><span class="line">        self.callback_queue = result.method.queue</span><br><span class="line"></span><br><span class="line">        self.channel.basic_consume(self.on_response, no_ack=True,</span><br><span class="line">                                   queue=self.callback_queue)</span><br><span class="line"></span><br><span class="line">    def on_response(self, ch, method, props, body):</span><br><span class="line">        if self.corr_id == props.correlation_id:</span><br><span class="line">            self.response = body</span><br><span class="line"></span><br><span class="line">    def call(self, n):</span><br><span class="line">        self.response = None</span><br><span class="line">        self.corr_id = str(uuid.uuid4())</span><br><span class="line">        self.channel.basic_publish(exchange=&apos;&apos;,</span><br><span class="line">                                   routing_key=&apos;rpc_queue&apos;,</span><br><span class="line">                                   properties=pika.BasicProperties(</span><br><span class="line">                                         reply_to = self.callback_queue,</span><br><span class="line">                                         correlation_id = self.corr_id,</span><br><span class="line">                                         ),</span><br><span class="line">                                   body=str(n))</span><br><span class="line">        while self.response is None:</span><br><span class="line">            self.connection.process_data_events()</span><br><span class="line">        return int(self.response)</span><br><span class="line"></span><br><span class="line">fibonacci_rpc = FibonacciRpcClient()</span><br><span class="line"></span><br><span class="line">print(&quot; [x] Requesting fib(30)&quot;)</span><br><span class="line">response = fibonacci_rpc.call(30)</span><br><span class="line">print(&quot; [.] Got %r&quot; % (response,))</span><br></pre></td></tr></table></figure><p>客户端代码稍微有点难懂：</p><ul><li>（7）建立连接、通道并且为回复（replies）声明独享的回调队列。</li><li>（16）我们订阅这个回调队列，以便接收RPC的响应。</li><li>（18）“on_response”回调函数对每一个响应执行一个非常简单的操作，检查每一个响应消息的correlation_id属性是否与我们期待的一致，如果一致，将响应结果赋给self.response，然后跳出consuming循环。</li><li>（23）接下来，我们定义我们的主要方法 call 方法。它执行真正的RPC请求。</li><li>（24）在这个方法中，首先我们生成一个唯一的 correlation_id 值并且保存起来，’on_response’回调函数会用它来获取符合要求的响应。</li><li>（25）接下来，我们将带有 reply_to 和 correlation_id 属性的消息发布出去。</li><li>（32）现在我们可以坐下来，等待正确的响应到来。</li><li>（33）最后，我们将响应返回给用户。</li></ul><p>我们的RPC服务已经准备就绪了，现在启动服务器端：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ python rpc_server.py</span><br><span class="line"> [x] Awaiting RPC requests</span><br></pre></td></tr></table></figure><p>运行客户端，请求一个fibonacci队列。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ python rpc_client.py</span><br><span class="line"> [x] Requesting fib(30)</span><br></pre></td></tr></table></figure><p>此处呈现的设计并不是实现RPC服务的唯一方式，但是他有一些重要的优势：</p><ul><li>如果RPC服务器运行的过慢的时候，你可以通过运行另外一个服务器端轻松扩展它。试试在控制台中运行第二个 rpc_server.py 。</li><li>在客户端，RPC请求只发送或接收一条消息。不需要像 queue_declare 这样的异步调用。所以RPC客户端的单个请求只需要一个网络往返。</li></ul><p>我们的代码依旧非常简单，而且没有试图去解决一些复杂（但是重要）的问题，如：</p><ul><li>当没有服务器运行时，客户端如何作出反映。</li><li>客户端是否需要实现类似RPC超时的东西。</li><li>如果服务器发生故障，并且抛出异常，应该被转发到客户端吗？</li><li>在处理前，防止混入无效的信息（例如检查边界）</li></ul><blockquote><p>如果你想做一些实验，你会发现<a href="http://www.rabbitmq.com/plugins.html" target="_blank" rel="noopener">rabbitmq-management plugin</a>在观测队列方面是很有用处的。</p></blockquote><p>（完整的<a href="https://github.com/rabbitmq/rabbitmq-tutorials/blob/master/python/rpc_client.py" target="_blank" rel="noopener">rpc_client.py</a> 和 <a href="https://github.com/rabbitmq/rabbitmq-tutorials/blob/master/python/rpc_server.py" target="_blank" rel="noopener">rpc_server.py</a>代码)</p>]]></content>
      
      <categories>
          
          <category> RabbitMQ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> RabbitMQ </tag>
            
            <tag> 消息队列 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Python版RabbitMQ消息队列之主题交换机（五）</title>
      <link href="/post/3a0f7196.html"/>
      <url>/post/3a0f7196.html</url>
      <content type="html"><![CDATA[<h2 id="为什么需要主题交换机？"><a href="#为什么需要主题交换机？" class="headerlink" title="为什么需要主题交换机？"></a>为什么需要主题交换机？</h2><p>上一篇教程里，我们改进了我们的日志系统。我们使用直连交换机替代了扇型交换机，从只能盲目的广播消息改进为有可能选择性的接收日志。</p><p>尽管直连交换机能够改善我们的系统，但是它也有它的限制 —— 没办法基于多个标准执行路由操作。</p><p>在我们的日志系统中，我们不只希望订阅基于严重程度的日志，同时还希望订阅基于发送来源的日志。Unix工具<a href="http://en.wikipedia.org/wiki/Syslog" target="_blank" rel="noopener">syslog</a>就是同时基于严重程度-severity (info/warn/crit…) 和 设备-facility (auth/cron/kern…)来路由日志的。</p><p>如果这样的话，将会给予我们非常大的灵活性，我们既可以监听来源于“cron”的严重程度为“critical errors”的日志，也可以监听来源于“kern”的所有日志。</p><p>为了实现这个目的，接下来我们学习如何使用另一种更复杂的交换机 —— 主题交换机。</p><h2 id="主题交换机"><a href="#主题交换机" class="headerlink" title="主题交换机"></a>主题交换机</h2><p>发送到主题交换机（topic exchange）的消息不可以携带随意什么样子的路由键（routing_key），它的路由键必须是一个由<code>.</code>分隔开的词语列表。这些单词随便是什么都可以，但是最好是跟携带它们的消息有关系的词汇。以下是几个推荐的例子：”stock.usd.nyse”, “nyse.vmw”, “quick.orange.rabbit”。词语的个数可以随意，但是不要超过255字节。</p><p>绑定键也必须拥有同样的格式。主题交换机背后的逻辑跟直连交换机很相似 —— 一个携带着特定路由键的消息会被主题交换机投递给绑定键与之想匹配的队列。但是它的绑定键和路由键有两个特殊应用方式：</p><ul><li><code>*</code> (星号) 用来表示一个单词.</li><li><code>#</code> (井号) 用来表示任意数量（零个或多个）单词。</li></ul><p>下边用图说明：<br><img src="http://www.rabbitmq.com/img/tutorials/python-five.png" alt="None"></p><p>这个例子里，我们发送的所有消息都是用来描述小动物的。发送的消息所携带的路由键是由三个单词所组成的，这三个单词被两个<code>.</code>分割开。路由键里的第一个单词描述的是动物的手脚的利索程度，第二个单词是动物的颜色，第三个是动物的种类。所以它看起来是这样的： <code>&lt;celerity&gt;.&lt;colour&gt;.&lt;species&gt;</code>。</p><p>我们创建了三个绑定：Q1的绑定键为 <code>*.orange.*</code>，Q2的绑定键为 <code>*.*.rabbit</code> 和 <code>lazy.#</code> 。</p><p>这三个绑定键被可以总结为：</p><ul><li>Q1 对<em>所有的桔黄色动物</em>都感兴趣。</li><li>Q2 则是对<em>所有的兔子</em>和<em>所有懒惰的动物</em>感兴趣。</li></ul><p>一个携带有 <code>quick.orange.rabbit</code> 的消息将会被分别投递给这两个队列。携带着 <code>lazy.orange.elephant</code> 的消息同样也会给两个队列都投递过去。另一方面携带有 <code>quick.orange.fox</code> 的消息会投递给第一个队列，携带有 <code>lazy.brown.fox</code> 的消息会投递给第二个队列。携带有 <code>lazy.pink.rabbit</code> 的消息只会被投递给第二个队列一次，即使它同时匹配第二个队列的两个绑定。携带着 <code>quick.brown.fox</code> 的消息不会投递给任何一个队列。</p><p>如果我们违反约定，发送了一个携带有一个单词或者四个单词（<code>&quot;orange&quot;</code> or <code>&quot;quick.orange.male.rabbit&quot;</code>）的消息时，发送的消息不会投递给任何一个队列，而且会丢失掉。</p><p>但是另一方面，即使 <code>&quot;lazy.orange.male.rabbit&quot;</code> 有四个单词，他还是会匹配最后一个绑定，并且被投递到第二个队列中。</p><blockquote><h4 id="主题交换机-1"><a href="#主题交换机-1" class="headerlink" title="主题交换机"></a>主题交换机</h4><p>主题交换机是很强大的，它可以表现出跟其他交换机类似的行为</p><p>当一个队列的绑定键为 “#”（井号） 的时候，这个队列将会无视消息的路由键，接收所有的消息。</p><p>当 <code>*</code> (星号) 和 <code>#</code> (井号) 这两个特殊字符都未在绑定键中出现的时候，此时主题交换机就拥有的直连交换机的行为。</p></blockquote><h2 id="组合在一起"><a href="#组合在一起" class="headerlink" title="组合在一起"></a>组合在一起</h2><p>接下来我们会将主题交换机应用到我们的日志系统中。在开始工作前，我们假设日志的路由键由两个单词组成，路由键看起来是这样的：<code>&lt;facility&gt;.&lt;severity&gt;</code></p><p>代码跟上一篇教程差不多。</p><p>emit_log_topic.py的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line">import pika</span><br><span class="line">import sys</span><br><span class="line"></span><br><span class="line">connection = pika.BlockingConnection(pika.ConnectionParameters(</span><br><span class="line">        host=&apos;localhost&apos;))</span><br><span class="line">channel = connection.channel()</span><br><span class="line"></span><br><span class="line">channel.exchange_declare(exchange=&apos;topic_logs&apos;,</span><br><span class="line">                         type=&apos;topic&apos;)</span><br><span class="line"></span><br><span class="line">routing_key = sys.argv[1] if len(sys.argv) &gt; 1 else &apos;anonymous.info&apos;</span><br><span class="line">message = &apos; &apos;.join(sys.argv[2:]) or &apos;Hello World!&apos;</span><br><span class="line">channel.basic_publish(exchange=&apos;topic_logs&apos;,</span><br><span class="line">                      routing_key=routing_key,</span><br><span class="line">                      body=message)</span><br><span class="line">print(&quot; [x] Sent %r:%r&quot; % (routing_key, message))</span><br><span class="line">connection.close()</span><br></pre></td></tr></table></figure><p>receive_logs_topic.py的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line">import pika</span><br><span class="line">import sys</span><br><span class="line"></span><br><span class="line">connection = pika.BlockingConnection(pika.ConnectionParameters(</span><br><span class="line">        host=&apos;localhost&apos;))</span><br><span class="line">channel = connection.channel()</span><br><span class="line"></span><br><span class="line">channel.exchange_declare(exchange=&apos;topic_logs&apos;,</span><br><span class="line">                         type=&apos;topic&apos;)</span><br><span class="line"></span><br><span class="line">result = channel.queue_declare(exclusive=True)</span><br><span class="line">queue_name = result.method.queue</span><br><span class="line"></span><br><span class="line">binding_keys = sys.argv[1:]</span><br><span class="line">if not binding_keys:</span><br><span class="line">    sys.stderr.write(&quot;Usage: %s [info] [warning] [error]\n&quot; % sys.argv[0]) #定义了三种接收消息方式info,warning,error</span><br><span class="line">    sys.exit(1)</span><br><span class="line"></span><br><span class="line">for binding_key in binding_keys:</span><br><span class="line">    channel.queue_bind(exchange=&apos;topic_logs&apos;,</span><br><span class="line">                       queue=queue_name,</span><br><span class="line">                       routing_key=binding_key)</span><br><span class="line"></span><br><span class="line">print(&apos; [*] Waiting for logs. To exit press CTRL+C&apos;)</span><br><span class="line"></span><br><span class="line">def callback(ch, method, properties, body):</span><br><span class="line">    print(&quot; [x] %r:%r&quot; % (method.routing_key, body,))</span><br><span class="line"></span><br><span class="line">channel.basic_consume(callback,</span><br><span class="line">                      queue=queue_name,</span><br><span class="line">                      no_ack=True)</span><br><span class="line"></span><br><span class="line">channel.start_consuming()</span><br></pre></td></tr></table></figure><p>执行下边命令 接收所有日志：<br><code>python receive_logs_topic.py &quot;#&quot;</code></p><p>执行下边命令 接收来自”kern“设备的日志：<br><code>python receive_logs_topic.py &quot;kern.*&quot;</code></p><p>执行下边命令 只接收严重程度为”critical“的日志：<br><code>python receive_logs_topic.py &quot;*.critical&quot;</code></p><p>执行下边命令 建立多个绑定：<br><code>python receive_logs_topic.py &quot;kern.*&quot; &quot;*.critical&quot;</code></p><p>执行下边命令 发送路由键为 “kern.critical” 的日志：<br><code>python emit_log_topic.py &quot;kern.critical&quot; &quot;A critical kernel error&quot;</code></p><p>执行上边命令试试看效果吧。另外，上边代码不会对路由键和绑定键做任何假设，所以你可以在命令中使用超过两个路由键参数。</p><h3 id="如果你现在还没被搞晕，想想下边问题"><a href="#如果你现在还没被搞晕，想想下边问题" class="headerlink" title="如果你现在还没被搞晕，想想下边问题:"></a>如果你现在还没被搞晕，想想下边问题:</h3><ul><li>绑定键为 <code>*</code> 的队列会取到一个路由键为空的消息吗？</li><li>绑定键为 <code>#.*</code> 的队列会获取到一个名为<code>..</code>的路由键的消息吗？它会取到一个路由键为单个单词的消息吗？</li><li><code>a.*.#</code> 和 <code>a.#</code>的区别在哪儿？</li></ul><p>（完整代码参见<a href="https://github.com/rabbitmq/rabbitmq-tutorials/blob/master/python/emit_log_topic.py" target="_blank" rel="noopener">emit_logs_topic.py</a> and <a href="https://github.com/rabbitmq/rabbitmq-tutorials/blob/master/python/receive_logs_topic.py" target="_blank" rel="noopener">receive_logs_topic.py</a>)</p>]]></content>
      
      <categories>
          
          <category> RabbitMQ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> RabbitMQ </tag>
            
            <tag> 消息队列 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Python版RabbitMQ消息队列之路由（四）</title>
      <link href="/post/9d637a8e.html"/>
      <url>/post/9d637a8e.html</url>
      <content type="html"><![CDATA[<h2 id="路由-Routing"><a href="#路由-Routing" class="headerlink" title="路由(Routing)"></a>路由(Routing)</h2><p>在前面的教程中，我们实现了一个简单的日志系统。可以把日志消息广播给多个接收者。</p><p>本篇教程中我们打算新增一个功能 —— 使得它能够只订阅消息的一个字集。例如，我们只需要把严重的错误日志信息写入日志文件（存储到磁盘），但同时仍然把所有的日志信息输出到控制台中</p><h2 id="绑定（Bindings）"><a href="#绑定（Bindings）" class="headerlink" title="绑定（Bindings）"></a>绑定（Bindings）</h2><p>前面的例子，我们已经创建过绑定（bindings），代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.queue_bind(exchange=exchange_name, queue=queue_name)</span><br></pre></td></tr></table></figure><p>绑定（binding）是指交换机（exchange）和队列（queue）的关系。可以简单理解为：这个队列（queue）对这个交换机（exchange）的消息感兴趣。</p><p>绑定的时候可以带上一个额外的routing_key参数。为了避免与basic_publish的参数混淆，我们把它叫做绑定键（binding key）。以下是如何创建一个带绑定键的绑定。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.queue_bind(exchange=exchange_name, queue=queue_name, routing_key=&apos;black&apos;)</span><br></pre></td></tr></table></figure><p>绑定键的意义取决于交换机（exchange）的类型。我们之前使用过的扇型交换机（fanout exchanges）会忽略这个值。</p><h2 id="直连交换机（Direct-exchange）"><a href="#直连交换机（Direct-exchange）" class="headerlink" title="直连交换机（Direct exchange）"></a>直连交换机（Direct exchange）</h2><p>我们的日志系统广播所有的消息给所有的消费者（consumers）。我们打算扩展它，使其基于日志的严重程度进行消息过滤。例如我们也许只是希望将比较严重的错误（error）日志写入磁盘，以免在警告（warning）或者信息（info）日志上浪费磁盘空间。</p><p>我们使用的扇型交换机（fanout exchange）没有足够的灵活性 —— 它能做的仅仅是广播。</p><p>我们将会使用直连交换机（direct exchange）来代替。路由的算法很简单 —— 交换机将会对绑定键（binding key）和路由键（routing key）进行精确匹配，从而确定消息该分发到哪个队列。</p><p>下图能够很好的描述这个场景：</p><p><img src="http://www.rabbitmq.com/img/tutorials/direct-exchange.png" alt="img"></p><p>在这个场景中，我们可以看到直连交换机 X和两个队列进行了绑定。第一个队列使用orange作为绑定键，第二个队列有两个绑定，一个使用black作为绑定键，另外一个使用green。</p><p>这样以来，当路由键为orange的消息发布到交换机，就会被路由到队列Q1。路由键为black或者green的消息就会路由到Q2。其他的所有消息都将会被丢弃。</p><h2 id="多个绑定（Multiple-bindings）"><a href="#多个绑定（Multiple-bindings）" class="headerlink" title="多个绑定（Multiple bindings）"></a>多个绑定（Multiple bindings）</h2><p><img src="http://www.rabbitmq.com/img/tutorials/direct-exchange-multiple.png" alt="img"></p><p>多个队列使用相同的绑定键是合法的。这个例子中，我们可以添加一个X和Q1之间的绑定，使用black绑定键。这样一来，直连交换机就和扇型交换机的行为一样，会将消息广播到所有匹配的队列。带有black路由键的消息会同时发送到Q1和Q2。</p><h2 id="发送日志"><a href="#发送日志" class="headerlink" title="发送日志"></a>发送日志</h2><p>我们将会发送消息到一个直连交换机，把日志级别作为路由键。这样接收日志的脚本就可以根据严重级别来选择它想要处理的日志。我们先看看发送日志。</p><p>我们需要创建一个交换机（exchange）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.exchange_declare(exchange=&apos;direct_logs&apos;, type=&apos;direct&apos;)</span><br></pre></td></tr></table></figure><p>然后我们发送一则消息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.basic_publish(exchange=&apos;direct_logs&apos;, routing_key=severity, body=message)</span><br></pre></td></tr></table></figure><p>我们先假设“severity”的值是info、warning、error中的一个。</p><h2 id="订阅"><a href="#订阅" class="headerlink" title="订阅"></a>订阅</h2><p>处理接收消息的方式和之前差不多，只有一个例外，我们将会为我们感兴趣的每个严重级别分别创建一个新的绑定。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">result = channel.queue_declare(exclusive=True)</span><br><span class="line">queue_name = result.method.queue</span><br><span class="line"></span><br><span class="line">for severity in severities:</span><br><span class="line">    channel.queue_bind(exchange=&apos;direct_logs&apos;, queue=queue_name, routing_key=severity)</span><br></pre></td></tr></table></figure><h2 id="代码整合"><a href="#代码整合" class="headerlink" title="代码整合"></a>代码整合</h2><p><img src="http://www.rabbitmq.com/img/tutorials/python-four.png" alt="img"></p><p>emit_log_direct.py的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line">import pika</span><br><span class="line">import sys</span><br><span class="line"></span><br><span class="line">connection = pika.BlockingConnection(pika.ConnectionParameters(host=&apos;localhost&apos;))</span><br><span class="line">channel = connection.channel()</span><br><span class="line"></span><br><span class="line">channel.exchange_declare(exchange=&apos;direct_logs&apos;, type=&apos;direct&apos;)</span><br><span class="line"></span><br><span class="line">severity = sys.argv[1] if len(sys.argv) &gt; 1 else &apos;info&apos;</span><br><span class="line">message = &apos; &apos;.join(sys.argv[2:]) or &apos;Hello World!&apos;</span><br><span class="line">channel.basic_publish(exchange=&apos;direct_logs&apos;, routing_key=severity, body=message)</span><br><span class="line">print(&quot; [x] Sent %r:%r&quot; % (severity, message))</span><br><span class="line">connection.close()</span><br></pre></td></tr></table></figure><p>receive_logs_direct.py的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line">import pika</span><br><span class="line">import sys</span><br><span class="line"></span><br><span class="line">connection = pika.BlockingConnection(pika.ConnectionParameters(host=&apos;localhost&apos;))</span><br><span class="line">channel = connection.channel()</span><br><span class="line"></span><br><span class="line">channel.exchange_declare(exchange=&apos;direct_logs&apos;, type=&apos;direct&apos;)</span><br><span class="line"></span><br><span class="line">result = channel.queue_declare(exclusive=True)</span><br><span class="line">queue_name = result.method.queue</span><br><span class="line"></span><br><span class="line">severities = sys.argv[1:]</span><br><span class="line">if not severities:</span><br><span class="line">    sys.stderr.write(&quot;Usage: %s [info] [warning] [error]\n&quot; % sys.argv[0]) #定义了三种接收消息方式info,warning,error</span><br><span class="line">    sys.exit(1)</span><br><span class="line"></span><br><span class="line">for severity in severities:</span><br><span class="line">    channel.queue_bind(exchange=&apos;direct_logs&apos;,</span><br><span class="line">                       queue=queue_name,</span><br><span class="line">                       routing_key=severity)</span><br><span class="line"></span><br><span class="line">print(&apos; [*] Waiting for logs. To exit press CTRL+C&apos;)</span><br><span class="line"></span><br><span class="line">def callback(ch, method, properties, body):</span><br><span class="line">    print(&quot; [x] %r:%r&quot; % (method.routing_key, body))</span><br><span class="line"></span><br><span class="line">channel.basic_consume(callback,</span><br><span class="line">                      queue=queue_name,</span><br><span class="line">                      no_ack=True)</span><br><span class="line"></span><br><span class="line">channel.start_consuming()</span><br></pre></td></tr></table></figure><p>如果你希望只是保存warning和error级别的日志到磁盘，只需要打开控制台并输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ python receive_logs_direct.py warning error &gt; logs_from_rabbit.log</span><br></pre></td></tr></table></figure><p>如果你希望所有的日志信息都输出到屏幕中，打开一个新的终端，然后输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ python receive_logs_direct.py info warning error</span><br><span class="line"> [*] Waiting for logs. To exit press CTRL+C</span><br></pre></td></tr></table></figure><p>如果要触发一个error级别的日志，只需要输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ python emit_log_direct.py error &quot;Run. Run. Or it will explode.&quot;</span><br><span class="line"> [x] Sent &apos;error&apos;:&apos;Run. Run. Or it will explode.&apos;</span><br></pre></td></tr></table></figure><p>这里是完整的代码：(<a href="https://github.com/rabbitmq/rabbitmq-tutorials/blob/master/python/emit_log_direct.py" target="_blank" rel="noopener">emit_log_direct.py</a>和<a href="https://github.com/rabbitmq/rabbitmq-tutorials/blob/master/python/receive_logs_direct.py" target="_blank" rel="noopener">receive_logs_direct.py</a>)</p>]]></content>
      
      <categories>
          
          <category> RabbitMQ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> RabbitMQ </tag>
            
            <tag> 消息队列 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Python版RabbitMQ消息队列之发布／订阅（三）</title>
      <link href="/post/2092e5cc.html"/>
      <url>/post/2092e5cc.html</url>
      <content type="html"><![CDATA[<h2 id="发布／订阅"><a href="#发布／订阅" class="headerlink" title="发布／订阅"></a>发布／订阅</h2><p>在上篇教程中，我们搭建了一个工作队列，每个任务只分发给一个工作者（worker）。在本篇教程中，我们要做的跟之前完全不一样 —— 分发一个消息给多个消费者（consumers）。这种模式被称为“发布／订阅”。</p><p>为了描述这种模式，我们将会构建一个简单的日志系统。它包括两个程序——第一个程序负责发送日志消息，第二个程序负责获取消息并输出内容。</p><p>在我们的这个日志系统中，所有正在运行的接收方程序都会接受消息。我们用其中一个接收者（receiver）把日志写入硬盘中，另外一个接受者（receiver）把日志输出到屏幕上。</p><p>最终，日志消息被广播给所有的接受者（receivers）。</p><h2 id="交换机（Exchanges）"><a href="#交换机（Exchanges）" class="headerlink" title="交换机（Exchanges）"></a>交换机（Exchanges）</h2><p>前面的教程中，我们发送消息到队列并从中取出消息。现在是时候介绍RabbitMQ中完整的消息模型了。</p><p>让我们简单的概括一下之前的教程：</p><ul><li>发布者（producer）是发布消息的应用程序。</li><li>队列（queue）用于消息存储的缓冲。</li><li>消费者（consumer）是接收消息的应用程序。</li></ul><p>RabbitMQ消息模型的核心理念是：发布者（producer）不会直接发送任何消息给队列。事实上，发布者（producer）甚至不知道消息是否已经被投递到队列。</p><p>发布者（producer）只需要把消息发送给一个交换机（exchange）。交换机非常简单，它一边从发布者方接收消息，一边把消息推送到队列。交换机必须知道如何处理它接收到的消息，是应该推送到指定的队列还是是多个队列，或者是直接忽略消息。这些规则是通过交换机类型（exchange type）来定义的。</p><p><img src="http://www.rabbitmq.com/img/tutorials/exchanges.png" alt="img"></p><p>有几个可供选择的交换机类型：直连交换机（direct）, 主题交换机（topic）, （头交换机）headers和 扇型交换机（fanout）。我们在这里主要说明最后一个 —— 扇型交换机（fanout）。先创建一个fanout类型的交换机，命名为logs：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.exchange_declare(exchange=&apos;logs&apos;, type=&apos;fanout&apos;)</span><br></pre></td></tr></table></figure><p>扇型交换机（fanout）很简单，你可能从名字上就能猜测出来，它把消息发送给它所知道的所有队列。这正是我们的日志系统所需要的。</p><blockquote><h4 id="交换器列表"><a href="#交换器列表" class="headerlink" title="交换器列表"></a>交换器列表</h4><p>rabbitmqctl能够列出服务器上所有的交换器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt; $ sudo rabbitmqctl list_exchanges</span><br><span class="line">&gt; Listing exchanges ...</span><br><span class="line">&gt; logs      fanout</span><br><span class="line">&gt; amq.direct      direct</span><br><span class="line">&gt; amq.topic       topic</span><br><span class="line">&gt; amq.fanout      fanout</span><br><span class="line">&gt; amq.headers     headers</span><br><span class="line">&gt; ...done.</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p>这个列表中有一些叫做amq.*的交换器。这些都是默认创建的，不过这时候你还不需要使用他们。</p><h4 id="匿名的交换器"><a href="#匿名的交换器" class="headerlink" title="匿名的交换器"></a>匿名的交换器</h4><p>前面的教程中我们对交换机一无所知，但仍然能够发送消息到队列中。因为我们使用了命名为空字符串(“”)默认的交换机。</p><p>回想我们之前是如何发布一则消息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; channel.basic_publish(exchange=&apos;&apos;, routing_key=&apos;hello&apos;, body=message)</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p>exchange参数就是交换机的名称。空字符串代表默认或者匿名交换机：消息将会根据指定的routing_key分发到指定的队列。</p></blockquote><p>现在，我们就可以发送消息到一个具名交换机了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.basic_publish(exchange=&apos;logs&apos;, routing_key=&apos;&apos;, body=message)</span><br></pre></td></tr></table></figure><h2 id="临时队列"><a href="#临时队列" class="headerlink" title="临时队列"></a>临时队列</h2><p>你还记得之前我们使用的队列名吗（ hello和task_queue）？给一个队列命名是很重要的——我们需要把工作者（workers）指向正确的队列。如果你打算在发布者（producers）和消费者（consumers）之间共享同队列的话，给队列命名是十分重要的。</p><p>但是这并不适用于我们的日志系统。我们打算接收所有的日志消息，而不仅仅是一小部分。我们关心的是最新的消息而不是旧的。为了解决这个问题，我们需要做两件事情。</p><p>首先，当我们连接上RabbitMQ的时候，我们需要一个全新的、空的队列。我们可以手动创建一个随机的队列名，或者让服务器为我们选择一个随机的队列名（推荐）。我们只需要在调用queue_declare方法的时候，不提供queue参数就可以了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result = channel.queue_declare()</span><br></pre></td></tr></table></figure><p>这时候我们可以通过result.method.queue获得已经生成的随机队列名。它可能是这样子的：amq.gen-U0srCoW8TsaXjNh73pnVAw==。</p><p>第二步，当与消费者（consumer）断开连接的时候，这个队列应当被立即删除。exclusive标识符即可达到此目的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result = channel.queue_declare(exclusive=True)</span><br></pre></td></tr></table></figure><h2 id="绑定（Bindings）"><a href="#绑定（Bindings）" class="headerlink" title="绑定（Bindings）"></a>绑定（Bindings）</h2><p><img src="http://www.rabbitmq.com/img/tutorials/bindings.png" alt="img"></p><p>我们已经创建了一个扇型交换机（fanout）和一个队列。现在我们需要告诉交换机如何发送消息给我们的队列。交换器和队列之间的联系我们称之为绑定（binding）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.queue_bind(exchange=&apos;logs&apos;, queue=result.method.queue)</span><br></pre></td></tr></table></figure><p>现在，logs交换机将会把消息添加到我们的队列中。</p><blockquote><h4 id="绑定（binding）列表"><a href="#绑定（binding）列表" class="headerlink" title="绑定（binding）列表"></a>绑定（binding）列表</h4><p>你可以使用<code>rabbitmqctl list_bindings</code> 列出所有现存的绑定。</p></blockquote><h2 id="代码整合"><a href="#代码整合" class="headerlink" title="代码整合"></a>代码整合</h2><p><img src="http://www.rabbitmq.com/img/tutorials/python-three-overall.png" alt="img"></p><p>发布日志消息的程序看起来和之前的没有太大区别。最重要的改变就是我们把消息发送给logs交换机而不是匿名交换机。在发送的时候我们需要提供routing_key参数，但是它的值会被扇型交换机（fanout exchange）忽略。以下是emit_log.py脚本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line">import pika</span><br><span class="line">import sys</span><br><span class="line"></span><br><span class="line">connection = pika.BlockingConnection(pika.ConnectionParameters(</span><br><span class="line">        host=&apos;localhost&apos;))</span><br><span class="line">channel = connection.channel()</span><br><span class="line"></span><br><span class="line">channel.exchange_declare(exchange=&apos;logs&apos;,</span><br><span class="line">                         type=&apos;fanout&apos;)</span><br><span class="line"></span><br><span class="line">message = &apos; &apos;.join(sys.argv[1:]) or &quot;info: Hello World!&quot;</span><br><span class="line">channel.basic_publish(exchange=&apos;logs&apos;,</span><br><span class="line">                      routing_key=&apos;&apos;,</span><br><span class="line">                      body=message)</span><br><span class="line">print(&quot; [x] Sent %r&quot; % (message,))</span><br><span class="line">connection.close()</span><br></pre></td></tr></table></figure><p>(<a href="http://github.com/rabbitmq/rabbitmq-tutorials/blob/master/python/emit_log.py" target="_blank" rel="noopener">emit_log.py</a> 源文件)</p><p>正如你看到的那样，在连接成功之后，我们声明了一个交换器，这一个是很重要的，因为不允许发布消息到不存在的交换器。</p><p>如果没有绑定队列到交换器，消息将会丢失。但这个没有所谓，如果没有消费者监听，那么消息就会被忽略。</p><p>receive_logs.py的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line">import pika</span><br><span class="line"></span><br><span class="line">connection = pika.BlockingConnection(pika.ConnectionParameters(</span><br><span class="line">        host=&apos;localhost&apos;))</span><br><span class="line">channel = connection.channel()</span><br><span class="line"></span><br><span class="line">channel.exchange_declare(exchange=&apos;logs&apos;,</span><br><span class="line">                         type=&apos;fanout&apos;)</span><br><span class="line"></span><br><span class="line">result = channel.queue_declare(exclusive=True)</span><br><span class="line">queue_name = result.method.queue</span><br><span class="line"></span><br><span class="line">channel.queue_bind(exchange=&apos;logs&apos;,</span><br><span class="line">                   queue=queue_name)</span><br><span class="line"></span><br><span class="line">print(&apos; [*] Waiting for logs. To exit press CTRL+C&apos;)</span><br><span class="line"></span><br><span class="line">def callback(ch, method, properties, body):</span><br><span class="line">    print(&quot; [x] %r&quot; % (body,))</span><br><span class="line"></span><br><span class="line">channel.basic_consume(callback,</span><br><span class="line">                      queue=queue_name,</span><br><span class="line">                      no_ack=True)</span><br><span class="line"></span><br><span class="line">channel.start_consuming()</span><br></pre></td></tr></table></figure><p>(<a href="http://github.com/rabbitmq/rabbitmq-tutorials/blob/master/python/receive_logs.py" target="_blank" rel="noopener">receive_logs.py</a> source)</p><p>这样我们就完成了。如果你想把日志保存到文件中，只需要打开控制台输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ python receive_logs.py &gt; logs_from_rabbit.log</span><br></pre></td></tr></table></figure><p>如果你想在屏幕中查看日志，那么打开一个新的终端然后运行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ python receive_logs.py</span><br></pre></td></tr></table></figure><p>当然还要发送日志：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ python emit_log.py</span><br></pre></td></tr></table></figure><p>使用<code>rabbitmqctl list_bindings</code>你可确认已经创建的队列绑定。你可以看到运行中的两个receive_logs.py程序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ sudo rabbitmqctl list_bindings</span><br><span class="line">Listing bindings ...</span><br><span class="line"> ...</span><br><span class="line">logs    amq.gen-TJWkez28YpImbWdRKMa8sg==                []</span><br><span class="line">logs    amq.gen-x0kymA4yPzAT6BoC/YP+zw==                []</span><br><span class="line">...done.</span><br></pre></td></tr></table></figure><p>显示结果很直观：logs交换器把数据发送给两个系统命名的队列。这就是我们所期望的。</p>]]></content>
      
      <categories>
          
          <category> RabbitMQ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> RabbitMQ </tag>
            
            <tag> 消息队列 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Python版RabbitMQ消息队列之工作队列（二）</title>
      <link href="/post/2efe5f21.html"/>
      <url>/post/2efe5f21.html</url>
      <content type="html"><![CDATA[<h2 id="工作队列"><a href="#工作队列" class="headerlink" title="工作队列"></a>工作队列</h2><p><img src="http://www.rabbitmq.com/img/tutorials/python-two.png" alt="img"></p><p>在第一篇教程中，我们已经写了一个从已知队列中发送和获取消息的程序。在这篇教程中，我们将创建一个工作队列（Work Queue），它会发送一些耗时的任务给多个工作者（Worker）。</p><p>工作队列（又称：任务队列——Task Queues）是为了避免等待一些占用大量资源、时间的操作。当我们把任务（Task）当作消息发送到队列中，一个运行在后台的工作者（worker）进程就会取出任务然后处理。当你运行多个工作者（workers），任务就会在它们之间共享。</p><p>这个概念在网络应用中是非常有用的，它可以在短暂的HTTP请求中处理一些复杂的任务。</p><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>之前的教程中，我们发送了一个包含“Hello World!”的字符串消息。现在，我们将发送一些字符串，把这些字符串当作复杂的任务。我们没有真实的例子，例如图片缩放、pdf文件转换。所以使用time.sleep()函数来模拟这种情况。我们在字符串中加上点号（.）来表示任务的复杂程度，一个点（.）将会耗时1秒钟。比如”Hello…”就会耗时3秒钟。</p><p>我们对之前教程的send.py做些简单的调整，以便可以发送随意的消息。这个程序会按照计划发送任务到我们的工作队列中。我们把它命名为new_task.py：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import sys</span><br><span class="line"></span><br><span class="line">message = &apos; &apos;.join(sys.argv[1:]) or &quot;Hello World!&quot;</span><br><span class="line">channel.basic_publish(exchange=&apos;&apos;,</span><br><span class="line">                      routing_key=&apos;hello&apos;,</span><br><span class="line">                      body=message)</span><br><span class="line">print(&quot; [x] Sent %r&quot; % (message,))</span><br></pre></td></tr></table></figure><p>我们的旧脚本（receive.py）同样需要做一些改动：它需要为消息体中每一个点号（.）模拟1秒钟的操作。它会从队列中获取消息并执行，我们把它命名为worker.py：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import time</span><br><span class="line"></span><br><span class="line">def callback(ch, method, properties, body):</span><br><span class="line">    print(&quot; [x] Received %r&quot; % (body,))</span><br><span class="line">    time.sleep( body.count(&apos;.&apos;) )</span><br><span class="line">    print(&quot; [x] Done&quot;)</span><br></pre></td></tr></table></figure><h2 id="循环调度"><a href="#循环调度" class="headerlink" title="循环调度:"></a>循环调度:</h2><p>使用工作队列的一个好处就是它能够并行的处理队列。如果堆积了很多任务，我们只需要添加更多的工作者（workers）就可以了，扩展很简单。</p><p>首先，我们先同时运行两个worker.py脚本，它们都会从队列中获取消息，到底是不是这样呢？我们看看。</p><p>你需要打开三个终端，两个用来运行worker.py脚本，这两个终端就是我们的两个消费者（consumers）—— C1 和 C2。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">shell1$ python worker.py</span><br><span class="line"> [*] Waiting for messages. To exit press CTRL+C</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">shell2$ python worker.py</span><br><span class="line"> [*] Waiting for messages. To exit press CTRL+C</span><br></pre></td></tr></table></figure><p>第三个终端，我们用来发布新任务。你可以发送一些消息给消费者（consumers）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">shell3$ python new_task.py First message.</span><br><span class="line">shell3$ python new_task.py Second message..</span><br><span class="line">shell3$ python new_task.py Third message...</span><br><span class="line">shell3$ python new_task.py Fourth message....</span><br><span class="line">shell3$ python new_task.py Fifth message.....</span><br></pre></td></tr></table></figure><p>看看到底发送了什么给我们的工作者（workers）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">shell1$ python worker.py</span><br><span class="line"> [*] Waiting for messages. To exit press CTRL+C</span><br><span class="line"> [x] Received &apos;First message.&apos;</span><br><span class="line"> [x] Received &apos;Third message...&apos;</span><br><span class="line"> [x] Received &apos;Fifth message.....&apos;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">shell2$ python worker.py</span><br><span class="line"> [*] Waiting for messages. To exit press CTRL+C</span><br><span class="line"> [x] Received &apos;Second message..&apos;</span><br><span class="line"> [x] Received &apos;Fourth message....&apos;</span><br></pre></td></tr></table></figure><p>默认来说，RabbitMQ会按顺序得把消息发送给每个消费者（consumer）。平均每个消费者都会收到同等数量得消息。这种发送消息得方式叫做——轮询（round-robin）。试着添加三个或更多得工作者（workers）。</p><h2 id="消息确认"><a href="#消息确认" class="headerlink" title="消息确认"></a>消息确认</h2><p>当处理一个比较耗时得任务的时候，你也许想知道消费者（consumers）是否运行到一半就挂掉。当前的代码中，当消息被RabbitMQ发送给消费者（consumers）之后，马上就会在内存中移除。这种情况，你只要把一个工作者（worker）停止，正在处理的消息就会丢失。同时，所有发送到这个工作者的还没有处理的消息都会丢失。</p><p>我们不想丢失任何任务消息。如果一个工作者（worker）挂掉了，我们希望任务会重新发送给其他的工作者（worker）。</p><p>为了防止消息丢失，RabbitMQ提供了消息响应（acknowledgments）。消费者会通过一个ack（响应），告诉RabbitMQ已经收到并处理了某条消息，然后RabbitMQ就会释放并删除这条消息。</p><p>如果消费者（consumer）挂掉了，没有发送响应，RabbitMQ就会认为消息没有被完全处理，然后重新发送给其他消费者（consumer）。这样，及时工作者（workers）偶尔的挂掉，也不会丢失消息。</p><p>消息是没有超时这个概念的；当工作者与它断开连的时候，RabbitMQ会重新发送消息。这样在处理一个耗时非常长的消息任务的时候就不会出问题了。</p><p>消息响应默认是开启的。之前的例子中我们可以使用no_ack=True标识把它关闭。是时候移除这个标识了，当工作者（worker）完成了任务，就发送一个响应。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def callback(ch, method, properties, body):</span><br><span class="line">    print(&quot; [x] Received %r&quot; % (body,))</span><br><span class="line">    time.sleep( body.count(&apos;.&apos;) )</span><br><span class="line">    print(&quot; [x] Done&quot;)</span><br><span class="line">    ch.basic_ack(delivery_tag = method.delivery_tag)</span><br><span class="line"></span><br><span class="line">channel.basic_consume(callback, queue=&apos;hello&apos;)</span><br></pre></td></tr></table></figure><p>运行上面的代码，我们发现即使使用CTRL+C杀掉了一个工作者（worker）进程，消息也不会丢失。当工作者（worker）挂掉这后，所有没有响应的消息都会重新发送。</p><blockquote><h4 id="忘记确认"><a href="#忘记确认" class="headerlink" title="忘记确认"></a>忘记确认</h4><p>一个很容易犯的错误就是忘了basic_ack，后果很严重。消息在你的程序退出之后就会重新发送，如果它不能够释放没响应的消息，RabbitMQ就会占用越来越多的内存。</p><p>为了排除这种错误，你可以使用rabbitmqctl命令，输出messages_unacknowledged字段：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; $ sudo rabbitmqctl list_queues name messages_ready messages_unacknowledged</span><br><span class="line">&gt; Listing queues ...</span><br><span class="line">&gt; hello    0       0</span><br><span class="line">&gt; ...done.</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h2 id="消息持久化"><a href="#消息持久化" class="headerlink" title="消息持久化"></a>消息持久化</h2><p>如果你没有特意告诉RabbitMQ，那么在它退出或者崩溃的时候，将会丢失所有队列和消息。为了确保信息不会丢失，有两个事情是需要注意的：我们必须把“队列”和“消息”设为持久化。</p><p>首先，为了不让队列消失，需要把队列声明为持久化（durable）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.queue_declare(queue=&apos;hello&apos;, durable=True)</span><br></pre></td></tr></table></figure><p>尽管这行代码本身是正确的，但是仍然不会正确运行。因为我们已经定义过一个叫hello的非持久化队列。RabbitMq不允许你使用不同的参数重新定义一个队列，它会返回一个错误。但我们现在使用一个快捷的解决方法——用不同的名字，例如task_queue。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.queue_declare(queue=&apos;task_queue&apos;, durable=True)</span><br></pre></td></tr></table></figure><p>这个queue_declare必须在生产者（producer）和消费者（consumer）对应的代码中修改。</p><p>这时候，我们就可以确保在RabbitMq重启之后queue_declare队列不会丢失。另外，我们需要把我们的消息也要设为持久化——将delivery_mode的属性设为2。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">channel.basic_publish(exchange=&apos;&apos;,</span><br><span class="line">                      routing_key=&quot;task_queue&quot;,</span><br><span class="line">                      body=message,</span><br><span class="line">                      properties=pika.BasicProperties(</span><br><span class="line">                         delivery_mode = 2, # make message persistent</span><br><span class="line">                      ))</span><br></pre></td></tr></table></figure><blockquote><h4 id="注意：消息持久化"><a href="#注意：消息持久化" class="headerlink" title="注意：消息持久化"></a>注意：消息持久化</h4><p>将消息设为持久化并不能完全保证不会丢失。以上代码只是告诉了RabbitMq要把消息存到硬盘，但从RabbitMq收到消息到保存之间还是有一个很小的间隔时间。因为RabbitMq并不是所有的消息都使用fsync(2)——它有可能只是保存到缓存中，并不一定会写到硬盘中。并不能保证真正的持久化，但已经足够应付我们的简单工作队列。如果你一定要保证持久化，你需要改写你的代码来支持事务（transaction）。</p></blockquote><h2 id="公平调度"><a href="#公平调度" class="headerlink" title="公平调度"></a>公平调度</h2><p>你应该已经发现，它仍旧没有按照我们期望的那样进行分发。比如有两个工作者（workers），处理奇数消息的比较繁忙，处理偶数消息的比较轻松。然而RabbitMQ并不知道这些，它仍然一如既往的派发消息。</p><p>这时因为RabbitMQ只管分发进入队列的消息，不会关心有多少消费者（consumer）没有作出响应。它盲目的把第n-th条消息发给第n-th个消费者。</p><p><img src="http://www.rabbitmq.com/img/tutorials/prefetch-count.png" alt="img"></p><p>我们可以使用basic.qos方法，并设置prefetch_count=1。这样是告诉RabbitMQ，再同一时刻，不要发送超过1条消息给一个工作者（worker），直到它已经处理了上一条消息并且作出了响应。这样，RabbitMQ就会把消息分发给下一个空闲的工作者（worker）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.basic_qos(prefetch_count=1)</span><br></pre></td></tr></table></figure><blockquote><h4 id="关于队列大小"><a href="#关于队列大小" class="headerlink" title="关于队列大小"></a>关于队列大小</h4><p>如果所有的工作者都处理繁忙状态，你的队列就会被填满。你需要留意这个问题，要么添加更多的工作者（workers），要么使用其他策略。</p></blockquote><h2 id="整合代码"><a href="#整合代码" class="headerlink" title="整合代码"></a>整合代码</h2><p>new_task.py的完整代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line">import pika</span><br><span class="line">import sys</span><br><span class="line"></span><br><span class="line">connection = pika.BlockingConnection(pika.ConnectionParameters(</span><br><span class="line">        host=&apos;localhost&apos;))</span><br><span class="line">channel = connection.channel()</span><br><span class="line"></span><br><span class="line">channel.queue_declare(queue=&apos;task_queue&apos;, durable=True)</span><br><span class="line"></span><br><span class="line">message = &apos; &apos;.join(sys.argv[1:]) or &quot;Hello World!&quot;</span><br><span class="line">channel.basic_publish(exchange=&apos;&apos;,</span><br><span class="line">                      routing_key=&apos;task_queue&apos;,</span><br><span class="line">                      body=message,</span><br><span class="line">                      properties=pika.BasicProperties(</span><br><span class="line">                         delivery_mode = 2, # make message persistent</span><br><span class="line">                      ))</span><br><span class="line">print(&quot; [x] Sent %r&quot; % (message,))</span><br><span class="line">connection.close()</span><br></pre></td></tr></table></figure><p>(<a href="https://github.com/rabbitmq/rabbitmq-tutorials/blob/master/python/new_task.py" target="_blank" rel="noopener">new_task.py</a>源码)</p><p>我们的worker：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line">import pika</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line">connection = pika.BlockingConnection(pika.ConnectionParameters(</span><br><span class="line">        host=&apos;localhost&apos;))</span><br><span class="line">channel = connection.channel()</span><br><span class="line"></span><br><span class="line">channel.queue_declare(queue=&apos;task_queue&apos;, durable=True)</span><br><span class="line">print(&apos; [*] Waiting for messages. To exit press CTRL+C&apos;)</span><br><span class="line"></span><br><span class="line">def callback(ch, method, properties, body):</span><br><span class="line">    print(&quot; [x] Received %r&quot; % (body,))</span><br><span class="line">    time.sleep( body.count(&apos;.&apos;) )</span><br><span class="line">    print(&quot; [x] Done&quot;)</span><br><span class="line">    ch.basic_ack(delivery_tag = method.delivery_tag)</span><br><span class="line"></span><br><span class="line">channel.basic_qos(prefetch_count=1)</span><br><span class="line">channel.basic_consume(callback,</span><br><span class="line">                      queue=&apos;task_queue&apos;)</span><br><span class="line"></span><br><span class="line">channel.start_consuming()</span><br></pre></td></tr></table></figure><p>(<a href="http://github.com/rabbitmq/rabbitmq-tutorials/blob/master/python/worker.py" target="_blank" rel="noopener">worker.py</a> source)</p><p>使用消息响应和prefetch_count你就可以搭建起一个工作队列了。这些持久化的选项使得在RabbitMQ重启之后仍然能够恢复。</p>]]></content>
      
      <categories>
          
          <category> RabbitMQ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> RabbitMQ </tag>
            
            <tag> 消息队列 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Python版RabbitMQ消息队列之Hello World（一）</title>
      <link href="/post/79b12668.html"/>
      <url>/post/79b12668.html</url>
      <content type="html"><![CDATA[<h2 id="RabbitMQ安装"><a href="#RabbitMQ安装" class="headerlink" title="RabbitMQ安装"></a>RabbitMQ安装</h2><p>请移步<a href="http://www.cnblogs.com/nulige/p/6351318.html" target="_blank" rel="noopener">努力哥</a>博客！！！</p><h2 id="RabbitMQ队列"><a href="#RabbitMQ队列" class="headerlink" title="RabbitMQ队列"></a>RabbitMQ队列</h2><p>RabbitMQ是一个消息代理。它的工作就是接收和转发消息。你可以把它想像成一个邮局：你把信件放入邮箱，邮递员就会把信件投递到你的收件人处。在这个比喻中，RabbitMQ就扮演着邮箱、邮局以及邮递员的角色。</p><p>RabbitMQ和邮局的主要区别在于，它处理纸张，而是接收、存储和发送消息（message）这种二进制数据。</p><p>下面是RabbitMQ和消息所涉及到的一些术语。</p><ul><li>生产(Producing)的意思就是发送。发送消息的程序就是一个生产者(producer)。我们一般用”P”来表示:<br><img src="http://www.rabbitmq.com/img/tutorials/producer.png" alt="img"></li><li>队列(queue)就是存在于RabbitMQ中邮箱的名称。虽然消息的传输经过了RabbitMQ和你的应用程序，但是它只能被存储于队列当中。实质上队列就是个巨大的消息缓冲区，它的大小只受主机内存和硬盘限制。多个生产者（producers）可以把消息发送给同一个队列，同样，多个消费者（consumers）也能够从同一个队列（queue）中获取数据。队列可以绘制成这样（图上是队列的名称）：<br><img src="http://www.rabbitmq.com/img/tutorials/queue.png" alt="img"></li><li>在这里，消费（Consuming）和接收(receiving)是同一个意思。一个消费者（consumer）就是一个等待获取消息的程序。我们把它绘制为”C”：<br><img src="http://www.rabbitmq.com/img/tutorials/consumer.png" alt="img"></li></ul><p>需要指出的是生产者、消费者、代理需不要待在同一个设备上；事实上大多数应用也确实不在会将他们放在一台机器上。</p><h2 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h2><p>接下来我们用Python写两个小程序。一个发送单条消息的生产者（producer）和一个接收消息并将其输出的消费者（consumer）。传递的消息是”Hello World”。</p><p>下图中，“P”代表生产者，“C”代表消费者，中间的盒子代表为消费者保留的消息缓冲区，也就是我们的队列。</p><p><img src="http://www.rabbitmq.com/img/tutorials/python-one-overall.png" alt="img"></p><p>生产者（producer）把消息发送到一个名为“hello”的队列中。消费者（consumer）从这个队列中获取消息。</p><blockquote><h4 id="RabbitMQ库"><a href="#RabbitMQ库" class="headerlink" title="RabbitMQ库"></a>RabbitMQ库</h4><p>RabbitMQ使用的是AMQP 0.9.1协议。这是一个用于消息传递的开放、通用的协议。针对<a href="https://www.rabbitmq.com/devtools.html" target="_blank" rel="noopener">不同编程语言</a>有大量的RabbitMQ客户端可用。在这个系列教程中，RabbitMQ团队推荐使用<a href="https://pika.readthedocs.org/en/0.10.0/#" target="_blank" rel="noopener">Pika</a>这个Python客户端。大家可以通过<a href="https://pip.pypa.io/en/stable/quickstart/" target="_blank" rel="noopener">pip</a>这个包管理工具进行安装：</p></blockquote><h3 id="发送"><a href="#发送" class="headerlink" title="发送"></a>发送</h3><p><img src="http://www.rabbitmq.com/img/tutorials/sending.png" alt="img"></p><p>我们第一个程序<code>send.py</code>会发送一个消息到队列中。首先要做的事情就是建立一个到RabbitMQ服务器的连接。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import pika</span><br><span class="line"></span><br><span class="line">connection = pika.BlockingConnection(pika.ConnectionParameters(&apos;localhost&apos;))</span><br><span class="line">channel = connection.channel()</span><br></pre></td></tr></table></figure><p>现在我们已经跟本地机器的代理建立了连接。如果你想连接到其他机器的代理上，需要把代表本地的<code>localhost</code>改为指定的名字或IP地址。</p><p>接下来，在发送消息之前，我们需要确认服务于消费者的队列已经存在。如果将消息发送给一个不存在的队列，RabbitMQ会将消息丢弃掉。下面我们创建一个名为”hello”的队列用来将消息投递进去。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.queue_declare(queue=&apos;hello&apos;)</span><br></pre></td></tr></table></figure><p>这时候我们就可以发送消息了，我们第一条消息只包含了Hello World!字符串，我们打算把它发送到hello队列。</p><p>在RabbitMQ中，消息是不能直接发送到队列中的，这个过程需要通过交换机（exchange）来进行。但是为了不让细节拖累我们的进度，这里我们只需要知道如何使用由空字符串表示的默认交换机即可。如果你想要详细了解交换机，可以查看我们<a href="https://www.rabbitmq.com/tutorials/tutorial-three-python.html" target="_blank" rel="noopener">教程的第三部分</a>来获取更多细节。默认交换机比较特别，它允许我们指定消息究竟需要投递到哪个具体的队列中，队列名字需要在<code>routing_key</code>参数中指定。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">channel.basic_publish(exchange=&apos;&apos;, routing_key=&apos;hello&apos;, body=&apos;Hello World!&apos;)</span><br><span class="line">print(&quot; [x] Sent &apos;Hello World!&apos;&quot;)</span><br></pre></td></tr></table></figure><p>在退出程序之前，我们需要确认网络缓冲已经被刷写、消息已经投递到RabbitMQ。通过安全关闭连接可以做到这一点。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">connection.close()</span><br></pre></td></tr></table></figure><blockquote><p>发送不成功！</p><p>如果这是你第一次使用RabbitMQ，并且没有看到“Sent”消息出现在屏幕上，你可能会抓耳挠腮不知所以。这也许是因为没有足够的磁盘空间给代理使用所造成的（代理默认需要200MB的空闲空间），所以它才会拒绝接收消息。查看一下代理的日志文件进行确认，如果需要的话也可以减少限制。<a href="http://www.rabbitmq.com/configure.html#config-items" target="_blank" rel="noopener">配置文件文档</a>会告诉你如何更改磁盘空间限制（disk_free_limit）。</p></blockquote><h3 id="接收"><a href="#接收" class="headerlink" title="接收"></a>接收</h3><p><img src="https://www.rabbitmq.com/img/tutorials/receiving.png" alt="img"></p><p>我们的第二个程序<code>receive.py</code>，将会从队列中获取消息并将其打印到屏幕上。</p><p>这次我们还是需要要先连接到RabbitMQ服务器。连接服务器的代码和之前是一样的。</p><p>下一步也和之前一样，我们需要确认队列是存在的。我们可以多次使用<code>queue_declare</code>命令来创建同一个队列，但是只有一个队列会被真正的创建。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.queue_declare(queue=&apos;hello&apos;)</span><br></pre></td></tr></table></figure><p>你也许要问: 为什么要重复声明队列呢 —— 我们已经在前面的代码中声明过它了。如果我们确定了队列是已经存在的，那么我们可以不这么做，比如此前预先运行了send.py程序。可是我们并不确定哪个程序会首先运行。这种情况下，在程序中重复将队列重复声明一下是种值得推荐的做法。</p><blockquote><h4 id="列出所有队列"><a href="#列出所有队列" class="headerlink" title="列出所有队列"></a>列出所有队列</h4><p>你也许希望查看RabbitMQ中有哪些队列、有多少消息在队列中。此时你可以使用rabbitmqctl工具（使用有权限的用户）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; sudo rabbitmqctl list_queues</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><p>（在Windows中不需要sudo命令）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; rabbitmqctl list_queues</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>从队列中获取消息相对来说稍显复杂。需要为队列定义一个回调（callback）函数。当我们获取到消息的时候，Pika库就会调用此回调函数。这个回调函数会将接收到的消息内容输出到屏幕上。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def callback(ch, method, properties, body):</span><br><span class="line">    print(&quot; [x] Received %r&quot; % body)</span><br></pre></td></tr></table></figure><p>下一步，我们需要告诉RabbitMQ这个回调函数将会从名为”hello”的队列中接收消息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.basic_consume(callback, queue=&apos;hello&apos;, no_ack=True)</span><br></pre></td></tr></table></figure><p>要成功运行这些命令，我们必须保证队列是存在的，我们的确可以确保它的存在——因为我们之前已经使用<code>queue_declare</code>将其声明过了。</p><p><code>no_ack</code>参数<a href="https://www.rabbitmq.com/tutorials/tutorial-two-python.html" target="_blank" rel="noopener">稍后</a>会进行介绍。</p><p>最后，我们运行一个用来等待消息数据并且在需要的时候运行回调函数的无限循环。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(&apos; [*] Waiting for messages. To exit press CTRL+C&apos;)</span><br><span class="line">channel.start_consuming()</span><br></pre></td></tr></table></figure><h3 id="将代码整合到一起"><a href="#将代码整合到一起" class="headerlink" title="将代码整合到一起"></a>将代码整合到一起</h3><p><strong>send.py的完整代码：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import pika</span><br><span class="line"></span><br><span class="line">connection =</span><br><span class="line">pika.BlockingConnection(pika.ConnectionParameters(host=&apos;localhost&apos;))</span><br><span class="line">channel = connection.channel()</span><br><span class="line"></span><br><span class="line">channel.queue_declare(queue=&apos;hello&apos;)</span><br><span class="line"></span><br><span class="line">channel.basic_publish(exchange=&apos;&apos;,</span><br><span class="line">                      routing_key=&apos;hello&apos;,</span><br><span class="line">                      body=&apos;Hello World!&apos;)</span><br><span class="line">print(&quot; [x] Sent &apos;Hello World!&apos;&quot;)</span><br><span class="line">connection.close()</span><br></pre></td></tr></table></figure><p>(<a href="http://github.com/rabbitmq/rabbitmq-tutorials/blob/master/python/send.py" target="_blank" rel="noopener">send.py源码</a>)</p><p><strong>receive.py的完整代码：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import pika</span><br><span class="line"></span><br><span class="line">connection =</span><br><span class="line">pika.BlockingConnection(pika.ConnectionParameters(host=&apos;localhost&apos;))</span><br><span class="line">channel = connection.channel()</span><br><span class="line"></span><br><span class="line">channel.queue_declare(queue=&apos;hello&apos;)</span><br><span class="line"></span><br><span class="line">def callback(ch, method, properties, body):</span><br><span class="line">    print(&quot; [x] Received %r&quot; % body)</span><br><span class="line"></span><br><span class="line">channel.basic_consume(callback,</span><br><span class="line">                      queue=&apos;hello&apos;,</span><br><span class="line">                      no_ack=True)</span><br><span class="line"></span><br><span class="line">print(&apos; [*] Waiting for messages. To exit press CTRL+C&apos;)</span><br><span class="line">channel.start_consuming()</span><br></pre></td></tr></table></figure><p>(<a href="http://github.com/rabbitmq/rabbitmq-tutorials/blob/master/python/receive.py" target="_blank" rel="noopener">receive.py源码</a>)</p><p>现在我们可以在终端中尝试一下我们的程序了。<br>首先我们启动一个消费者，它会持续的运行来等待投递到达。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">python receive.py</span><br><span class="line"># =&gt; [*] Waiting for messages. To exit press CTRL+C</span><br><span class="line"># =&gt; [x] Received &apos;Hello World!&apos;</span><br></pre></td></tr></table></figure><p>然后启动生产者，生产者程序每次执行后都会停止运行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python send.py</span><br><span class="line"># =&gt; [x] Sent &apos;Hello World!&apos;</span><br></pre></td></tr></table></figure><p><strong>成功了！</strong>我们已经通过RabbitMQ发送第一条消息。你也许已经注意到了，receive.py程序并没有退出。它一直在准备获取消息，你可以通过Ctrl-C来中止它。</p><p>试下在新的终端中再次运行<code>send.py</code>。</p>]]></content>
      
      <categories>
          
          <category> RabbitMQ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> RabbitMQ </tag>
            
            <tag> 消息队列 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Python之concurrent.futures</title>
      <link href="/post/b1bc006d.html"/>
      <url>/post/b1bc006d.html</url>
      <content type="html"><![CDATA[<h3 id="concurrent-futures"><a href="#concurrent-futures" class="headerlink" title="concurrent.futures"></a>concurrent.futures</h3><h4 id="ProcessPoolExecutor"><a href="#ProcessPoolExecutor" class="headerlink" title="ProcessPoolExecutor"></a>ProcessPoolExecutor</h4><p>进程池，提供异步调用</p><h5 id="基本方法"><a href="#基本方法" class="headerlink" title="基本方法"></a>基本方法</h5><ul><li><p>submit(fn, <em>args, *</em>kwargs) 异步提交任务</p></li><li><p>map(func, *iterables, timeout=None, chunksize=1) 取代for循环submit的操作</p></li><li><p>shutdown(wait=True) 相当于进程池的pool.close()+pool.join()操作</p><p>wait=True，等待池内所有任务执行完毕回收完资源后才继续<br>wait=False，立即返回，并不会等待池内的任务执行完毕<br>但不管wait参数为何值，整个程序都会等到所有任务执行完毕<br>submit和map必须在shutdown之前</p></li><li><p>result(timeout=None)取得结果</p></li><li><p>add_done_callback(fn)回调函数</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ThreadPoolExecutor, ProcessPoolExecutor</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> os, time, random</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task</span><span class="params">(n)</span>:</span></span><br><span class="line">    print(<span class="string">'%s is runing'</span> % os.getpid())</span><br><span class="line">    time.sleep(random.randint(<span class="number">1</span>, <span class="number">3</span>))</span><br><span class="line">    <span class="keyword">return</span> n ** <span class="number">2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line"></span><br><span class="line">    executor = ProcessPoolExecutor(max_workers=<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">    futures = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">11</span>):</span><br><span class="line">        future = executor.submit(task, i)</span><br><span class="line">        futures.append(future)</span><br><span class="line">    executor.shutdown(<span class="keyword">True</span>)</span><br><span class="line">    print(<span class="string">'+++&gt;'</span>)</span><br><span class="line">    <span class="keyword">for</span> future <span class="keyword">in</span> futures:</span><br><span class="line">        print(future.result())</span><br></pre></td></tr></table></figure><h4 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h4><p>线程池，提供异步调用，用法与ProcessPoolExecutor相同，只需要将ProcessPoolExecutor换成ThreadPoolExecutor</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ThreadPoolExecutor</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(n)</span>:</span></span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    print(n)</span><br><span class="line">    <span class="keyword">return</span> n * n</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">call_back</span><span class="params">(m)</span>:</span></span><br><span class="line">    print(<span class="string">'结果是 %s'</span> % m.result())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    tpool = ThreadPoolExecutor(max_workers=<span class="number">5</span>)  <span class="comment"># 默认 不要超过cpu个数*5</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">20</span>):</span><br><span class="line">        tpool.submit(func, i).add_done_callback(call_back)</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Python线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 进程池 </tag>
            
            <tag> 线程池 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Python线程——信号量（Semaphore）、队列（Queue）</title>
      <link href="/post/d068a68c.html"/>
      <url>/post/d068a68c.html</url>
      <content type="html"><![CDATA[<h3 id="信号量（Semaphore）"><a href="#信号量（Semaphore）" class="headerlink" title="信号量（Semaphore）"></a>信号量（Semaphore）</h3><p>之前讲的线程锁（互斥锁）同时只允许一个线程更改数据，而Semaphore是同时允许一定数量的线程更改数据 ，比如厕所有4个坑，那最多只允许4个人上厕所，后面的人只能等里面有人出来了才能再进去。 说白了就是在同一时间，可以只允许设定的数量的线程去执行 。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Semaphore, Thread</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(sem, a, b)</span>:</span></span><br><span class="line">    sem.acquire()</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    print(a + b)</span><br><span class="line">    sem.release()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sem = Semaphore(<span class="number">4</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">    t = Thread(target=func, args=(sem, i, i + <span class="number">5</span>))</span><br><span class="line">    t.start()</span><br></pre></td></tr></table></figure><h3 id="队列（Queue）"><a href="#队列（Queue）" class="headerlink" title="队列（Queue）"></a>队列（Queue）</h3><p>queue队列 ：使用import queue，用法与<a href="https://gavinliu4011.github.io/post/58b02bea.html#more">进程Queue</a>一样 </p><p>####class queue.Queue(maxsize=0) 先进先出</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> queue</span><br><span class="line"></span><br><span class="line">q=queue.Queue()</span><br><span class="line">q.put(<span class="string">'first'</span>)</span><br><span class="line">q.put(<span class="string">'second'</span>)</span><br><span class="line">q.put(<span class="string">'third'</span>)</span><br><span class="line"></span><br><span class="line">print(q.get())</span><br><span class="line">print(q.get())</span><br><span class="line">print(q.get())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行结果</span></span><br><span class="line">结果(先进先出):</span><br><span class="line">first</span><br><span class="line">second</span><br><span class="line">third</span><br></pre></td></tr></table></figure><h4 id="class-queue-LifoQueue-maxsize-0-后进先出"><a href="#class-queue-LifoQueue-maxsize-0-后进先出" class="headerlink" title="class queue.LifoQueue(maxsize=0) 后进先出"></a>class queue.LifoQueue(maxsize=0) 后进先出</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> queue</span><br><span class="line"></span><br><span class="line">q=queue.LifoQueue()</span><br><span class="line">q.put(<span class="string">'first'</span>)</span><br><span class="line">q.put(<span class="string">'second'</span>)</span><br><span class="line">q.put(<span class="string">'third'</span>)</span><br><span class="line"></span><br><span class="line">print(q.get())</span><br><span class="line">print(q.get())</span><br><span class="line">print(q.get())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行结果</span></span><br><span class="line">结果(后进先出):</span><br><span class="line">third</span><br><span class="line">second</span><br><span class="line">first</span><br></pre></td></tr></table></figure><h4 id="class-queue-PriorityQueue-maxsize-0"><a href="#class-queue-PriorityQueue-maxsize-0" class="headerlink" title="class queue.PriorityQueue(maxsize=0)"></a>class queue.PriorityQueue(maxsize=0)</h4><p>根据优先级来取数据。存放数据的格式  : Queue.put((priority_number,data))，priority_number越小，优先级越高，data代表存入的值 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> queue</span><br><span class="line">q = queue.PriorityQueue()</span><br><span class="line">q.put((<span class="number">1</span>, <span class="string">"d1"</span>))</span><br><span class="line">q.put((<span class="number">-1</span>, <span class="string">"d2"</span>))</span><br><span class="line">q.put((<span class="number">6</span>, <span class="string">"d3"</span>))</span><br><span class="line">print(q.get())</span><br><span class="line">print(q.get())</span><br><span class="line">print(q.get())</span><br><span class="line"> </span><br><span class="line"><span class="comment">#执行结果</span></span><br><span class="line">(<span class="number">-1</span>, <span class="string">'d2'</span>)</span><br><span class="line">(<span class="number">1</span>, <span class="string">'d1'</span>)</span><br><span class="line">(<span class="number">6</span>, <span class="string">'d3'</span>)</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意：</strong>maxsize代表这个队列最大能够put的长度 </p></blockquote>]]></content>
      
      <categories>
          
          <category> Python线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 线程 </tag>
            
            <tag> 队列 </tag>
            
            <tag> 信号量 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Python线程——GIL锁、线程锁（互斥锁）、递归锁（RLock）</title>
      <link href="/post/5b18ac8.html"/>
      <url>/post/5b18ac8.html</url>
      <content type="html"><![CDATA[<h3 id="GIL锁"><a href="#GIL锁" class="headerlink" title="GIL锁"></a>GIL锁</h3><p>​    计算机有4核，代表着同一时间，可以干4个任务。如果单核cpu的话，我启动10个线程，我看上去也是并发的，因为是执行了上下文的切换，让看上去是并发的。但是单核永远肯定时串行的，它肯定是串行的，cpu真正执行的时候，因为一会执行1，一会执行2.。。。。正常的线程就是这个样子的。但是，在python中，无论有多少核，永远都是假象。无论是4核，8核，还是16核…….不好意思，同一时间执行的线程只有一个(线程)，它就是这个样子的。</p><h4 id="全局解释器锁-GIL"><a href="#全局解释器锁-GIL" class="headerlink" title="全局解释器锁(GIL)"></a>全局解释器锁(GIL)</h4><p>​    Python代码的执行由Python虚拟机(也叫解释器主循环)来控制。Python在设计之初就考虑到要在主循环中，同时只有一个线程在执行。虽然 Python 解释器中可以“运行”多个线程，但在任意时刻只有一个线程在解释器中运行。<br>　　对Python虚拟机的访问由全局解释器锁(GIL)来控制，正是这个锁能保证同一时刻只有一个线程在运行。</p><p>　　在多线程环境中，Python 虚拟机按以下方式执行：</p><p>　　1、设置 GIL；</p><p>　　2、切换到一个线程去运行；</p><p>　　3、运行指定数量的字节码指令或者线程主动让出控制(可以调用 time.sleep(0))；</p><p>　　4、把线程设置为睡眠状态；</p><p>　　5、解锁 GIL；</p><p>　　6、再次重复以上所有步骤。<br>　　在调用外部代码(如 C/C++扩展函数)的时候，GIL将会被锁定，直到这个函数结束为止(由于在这期间没有Python的字节码被运行，所以不会做线程切换)编写扩展的程序员可以主动解锁GIL。</p><h4 id="GIL锁关系图"><a href="#GIL锁关系图" class="headerlink" title="GIL锁关系图"></a>GIL锁关系图</h4><p>GIL(全局解释器锁)是加在python解释器里面的，效果如图 :</p><p><img src="..\img\thread\1449713172.png" alt=""></p><h5 id="为什么GIL锁要加在python解释器这一层，而却不加在其他地方？"><a href="#为什么GIL锁要加在python解释器这一层，而却不加在其他地方？" class="headerlink" title="为什么GIL锁要加在python解释器这一层，而却不加在其他地方？"></a>为什么GIL锁要加在python解释器这一层，而却不加在其他地方？</h5><p>​    很多资料说是因为python调用的所有线程都是原生线程。原生线程是通过C语言提供原生接口，相当于C语言的一个函数。你一调它，你就控制不了了它了，就必须等它给你返回结果。只要已通过python虚拟机，再往下就不受python控制了，就是C语言自己控制了。你加在python虚拟机以下，你是加不上去的。同一时间，只有一个线程穿过这个锁去真正执行。其他的线程，只能在python虚拟机这边等待。 </p><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>​    需要明确的一点是<code>GIL</code>并不是Python的特性，它是在实现Python解析器(CPython)时所引入的一个概念。就好比C++是一套语言（语法）标准，但是可以用不同的编译器来编译成可执行代码。有名的编译器例如GCC，INTEL C++，Visual C++等。Python也一样，同样一段代码可以通过CPython，JPython，PyPy，Psyco等不同的Python执行环境来执行。而JPython就没有GIL。然而因为CPython是大部分环境下默认的Python执行环境。所以在很多人的概念里CPython就是Python，也就想当然的把<code>GIL</code>归结为Python语言的缺陷。所以这里要先明确一点：<strong>GIL并不是Python的特性，Python完全可以不依赖于GIL</strong>。 </p><h3 id="线程锁（互斥锁）"><a href="#线程锁（互斥锁）" class="headerlink" title="线程锁（互斥锁）"></a>线程锁（互斥锁）</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">work</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 在这里模拟一个底层做运算的过程，具体为什么这个我不知道，看某资料写的，</span></span><br><span class="line">    <span class="comment"># 如果这里直接对num进行运算很难出现数据不安全的结果</span></span><br><span class="line">    <span class="keyword">global</span> num  <span class="comment"># 把num变成全局变量</span></span><br><span class="line">    temp = num</span><br><span class="line">    time.sleep(<span class="number">1</span>)  <span class="comment"># 注意了sleep的时候是不占有cpu的，这个时候cpu直接把这个线程挂起了，此时cpu去干别的事情去了</span></span><br><span class="line">    num = temp + <span class="number">1</span>  <span class="comment"># 所有的线程都做+1操作</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line"></span><br><span class="line">    num = <span class="number">0</span>  <span class="comment"># 初始化num为0</span></span><br><span class="line">    t_obj = list()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">100</span>):</span><br><span class="line">        t = Thread(target=work)</span><br><span class="line">        t.start()</span><br><span class="line">        t_obj.append(t)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> t <span class="keyword">in</span> t_obj:</span><br><span class="line">        t.join()</span><br><span class="line">    print(<span class="string">"num:"</span>, num)  <span class="comment"># 输出最后的num值，可能是1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 执行结果</span></span><br><span class="line">    num: <span class="number">1</span></span><br></pre></td></tr></table></figure><p>下面我们就用一张图来解释一下这个原因 ：</p><p><img src="..\img\thread\80064182.png" alt=""></p><p>上面的例子中出现数据不安全问题，那么我们应该怎么解决呢？在这里我们引用线程锁来解决这个问题</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Lock,Thread</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">work</span><span class="params">(lock)</span>:</span></span><br><span class="line">    <span class="comment"># 在这里模拟一个底层做运算的过程，具体为什么这个我不知道，看某资料写的，</span></span><br><span class="line">    <span class="comment"># 如果这里直接对num进行运算很难出现数据不安全的结果</span></span><br><span class="line">    <span class="keyword">global</span> num  <span class="comment"># 把num变成全局变量</span></span><br><span class="line">    lock.acquire()</span><br><span class="line">    temp = num</span><br><span class="line">    time.sleep(<span class="number">0.1</span>)  <span class="comment"># 注意了sleep的时候是不占有cpu的，这个时候cpu直接把这个线程挂起了，此时cpu去干别的事情去了</span></span><br><span class="line">    num = temp + <span class="number">1</span>  <span class="comment"># 所有的线程都做+1操作</span></span><br><span class="line">    lock.release()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line"></span><br><span class="line">    num = <span class="number">0</span>  <span class="comment"># 初始化num为0</span></span><br><span class="line">    t_obj = list()</span><br><span class="line">    lock = Lock()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">100</span>):</span><br><span class="line">        t = Thread(target=work, args=(lock,))</span><br><span class="line">        t.start()</span><br><span class="line">        t_obj.append(t)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> t <span class="keyword">in</span> t_obj:</span><br><span class="line">        t.join()</span><br><span class="line">    print(<span class="string">"num:"</span>, num)  <span class="comment"># 输出最后的num值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 执行结果</span></span><br><span class="line">    num: <span class="number">100</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>注意：</strong>这里的Lock创建的锁和GIL没有关系 ，</p></blockquote><h3 id="递归锁（RLock）"><a href="#递归锁（RLock）" class="headerlink" title="递归锁（RLock）"></a>递归锁（RLock）</h3><h4 id="线程死锁"><a href="#线程死锁" class="headerlink" title="线程死锁"></a>线程死锁</h4><p>​    所谓死锁： 是指两个或两个以上的进程或线程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程，比如下面例子中“科学家吃面”：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Lock, Thread</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">noodle_lock = Lock()</span><br><span class="line">fork_lock = Lock()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">eat1</span><span class="params">(name)</span>:</span></span><br><span class="line">    noodle_lock.acquire()</span><br><span class="line">    print(<span class="string">'%s拿到面条啦'</span> % name)</span><br><span class="line">    fork_lock.acquire()</span><br><span class="line">    print(<span class="string">'%s拿到叉子了'</span> % name)</span><br><span class="line">    print(<span class="string">'%s吃面'</span> % name)</span><br><span class="line">    fork_lock.release()</span><br><span class="line">    noodle_lock.release()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">eat2</span><span class="params">(name)</span>:</span></span><br><span class="line">    fork_lock.acquire()</span><br><span class="line">    print(<span class="string">'%s拿到叉子了'</span> % name)</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    noodle_lock.acquire()</span><br><span class="line">    print(<span class="string">'%s拿到面条啦'</span> % name)</span><br><span class="line">    print(<span class="string">'%s吃面'</span> % name)</span><br><span class="line">    noodle_lock.release()</span><br><span class="line">    fork_lock.release()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    Thread(target=eat1, args=(<span class="string">'张三'</span>,)).start()</span><br><span class="line">    Thread(target=eat2, args=(<span class="string">'李四'</span>,)).start()</span><br><span class="line">    Thread(target=eat1, args=(<span class="string">'王五'</span>,)).start()</span><br><span class="line">    Thread(target=eat2, args=(<span class="string">'赵六'</span>,)).start()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行结果</span></span><br><span class="line">张三拿到面条啦</span><br><span class="line">张三拿到叉子了</span><br><span class="line">张三吃面</span><br><span class="line">李四拿到叉子了</span><br><span class="line">王五拿到面条啦</span><br></pre></td></tr></table></figure><p>上面例子中情况是在线程间共享多个资源的时候，如果两个线程分别占有一部分资源并且同时等待对方的资源，就会造成死锁，因为系统判断这部分资源都正在使用，所有这两个线程在无外力作用下将一直等待下去。执行结果，是无限的进入死循环，所以不能这么加，这个时候就需要用到递归锁。 </p><h4 id="递归锁-RLock"><a href="#递归锁-RLock" class="headerlink" title="递归锁(RLock)"></a>递归锁(RLock)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread, RLock  <span class="comment"># 递归锁</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">fork_lock = noodle_lock = RLock()  <span class="comment"># 一个钥匙串上的两把钥匙</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">eat1</span><span class="params">(name)</span>:</span></span><br><span class="line">    noodle_lock.acquire()  <span class="comment"># 一把钥匙</span></span><br><span class="line">    print(<span class="string">'%s拿到面条啦'</span> % name)</span><br><span class="line">    fork_lock.acquire()</span><br><span class="line">    print(<span class="string">'%s拿到叉子了'</span> % name)</span><br><span class="line">    print(<span class="string">'%s吃面'</span> % name)</span><br><span class="line">    fork_lock.release()</span><br><span class="line">    noodle_lock.release()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">eat2</span><span class="params">(name)</span>:</span></span><br><span class="line">    fork_lock.acquire()</span><br><span class="line">    print(<span class="string">'%s拿到叉子了'</span> % name)</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    noodle_lock.acquire()</span><br><span class="line">    print(<span class="string">'%s拿到面条啦'</span> % name)</span><br><span class="line">    print(<span class="string">'%s吃面'</span> % name)</span><br><span class="line">    noodle_lock.release()</span><br><span class="line">    fork_lock.release()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    Thread(target=eat1, args=(<span class="string">'张三'</span>,)).start()</span><br><span class="line">    Thread(target=eat2, args=(<span class="string">'李四'</span>,)).start()</span><br><span class="line">    Thread(target=eat1, args=(<span class="string">'王五'</span>,)).start()</span><br><span class="line">    Thread(target=eat2, args=(<span class="string">'赵六'</span>,)).start()</span><br></pre></td></tr></table></figure><p>自我理解递归锁原理其实很简单：就是每开一把门，在字典里面存一份数据，退出的时候去到door1或者door2里面找到这个钥匙退出 </p><p><img src="..\img\thread\1032923525.png" alt=""></p><blockquote><p><strong>注意：</strong>递归锁用于多重锁的情况，如果只是一层锁，就用不上递归锁</p></blockquote>]]></content>
      
      <categories>
          
          <category> Python线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 线程 </tag>
            
            <tag> 锁 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Python进程——守护线程</title>
      <link href="/post/5965383b.html"/>
      <url>/post/5965383b.html</url>
      <content type="html"><![CDATA[<h3 id="守护进程"><a href="#守护进程" class="headerlink" title="守护进程"></a>守护进程</h3><p>在上一遍文章中我们已经介绍了创建线程，对线程也有一些了解，现在一起来看看守护进程。</p><blockquote><p><strong>无论是进程还是线程，都遵循：守护xx会等待主xx运行完毕后被销毁。需要强调的是：运行完毕并非终止运行</strong> </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- 主进程在其代码结束后就已经算运行完毕了（守护进程在此时就被回收）,然后主进程会一直等非守护的子进程都运行完毕后回收子进程的资源(否则会产生僵尸进程)，才会结束。</span><br><span class="line">- 主线程在其他非守护线程运行完毕后才算运行完毕（守护线程在此时就被回收）。因为主线程的结束意味着进程的结束，进程整体的资源都将被回收，而进程必须保证非守护线程都运行完毕后才能结束。</span><br></pre></td></tr></table></figure><p>举个例，设置一个主人，在设置几个仆人，这几个仆人都是为主人服务的。可以帮主人做很多事情，一个主人（主线程）可以有多个仆人（守护线程），服务的前提是，主线程必须存在，如果主线程不存在，则守护进程也没了。那守护进程是干嘛的呢？可以管理一些资源，打开一些文件，监听一些端口，监听一些资源，把一些垃圾资源回收，可以干很多事情，可以随便定义。 </p><h4 id="守护线程设置"><a href="#守护线程设置" class="headerlink" title="守护线程设置"></a>守护线程设置</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(n)</span>:</span></span><br><span class="line">    print(<span class="string">'task:'</span>, n)</span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    print(<span class="string">'task done'</span>, n)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">start_time = time.time()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">    t = threading.Thread(target=run, args=(<span class="string">'t-&#123;0&#125;'</span>.format(i),))</span><br><span class="line">    t.setDaemon(<span class="keyword">True</span>)  <span class="comment"># Daemon意思是守护进程，这边是把当前线程设置为守护线程</span></span><br><span class="line">    t.start()</span><br><span class="line"></span><br><span class="line">print(<span class="string">"所有线程已经完成"</span>)</span><br><span class="line">print(<span class="string">'cost:'</span>, time.time() - start_time)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行结果</span></span><br><span class="line">task: t<span class="number">-0</span></span><br><span class="line">task: t<span class="number">-1</span></span><br><span class="line">task: t<span class="number">-2</span></span><br><span class="line">task: t<span class="number">-3</span></span><br><span class="line">task: t<span class="number">-4</span></span><br><span class="line">所有线程已经完成</span><br><span class="line">cost: <span class="number">0.0019915103912353516</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>注意：</strong>守护进程一定要在start之前设置，start之后就不能设置了，之后设置会报错，所以必须在start之前设置</p></blockquote><h4 id="统计线程数-补充点"><a href="#统计线程数-补充点" class="headerlink" title="统计线程数(补充点)"></a>统计线程数(补充点)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading, time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(n)</span>:</span></span><br><span class="line">    print(<span class="string">'task:'</span>, n)</span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    print(<span class="string">'task done'</span>, n, threading.current_thread())  <span class="comment"># 查看每个子线程</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">start_time = time.time()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">    t = threading.Thread(target=run, args=(<span class="string">'t-&#123;0&#125;'</span>.format(i),))</span><br><span class="line">    t.start()</span><br><span class="line"></span><br><span class="line">print(<span class="string">'--------'</span>, threading.current_thread(), threading.active_count())  <span class="comment"># 查看主线程和当前活动的所有线程数</span></span><br><span class="line">print(<span class="string">'cost:'</span>, time.time() - start_time)</span><br></pre></td></tr></table></figure><p>上面例子是查看当前线程和统计活动线程个数，用<strong>theading.current_thead()</strong> <em>查看当前线程</em>；用<strong>theading.active_count()</strong>来统计<em>当前活动的线程数</em>，<strong>线程个数=子线程数+主线程数</strong> </p>]]></content>
      
      <categories>
          
          <category> Python线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 守护线程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Python之线程</title>
      <link href="/post/c52e9d45.html"/>
      <url>/post/c52e9d45.html</url>
      <content type="html"><![CDATA[<h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><ul><li>CPU上的执行单位，线程也是程序运行过程中的一个抽象。</li><li>一个进程下可以有多个线程。</li><li>主线程：操作系统中的每一个进程都会对应一个地址空间。每一个进程中都会默认有一个控制线程，主线程随着进程的创建而出现。所以一个进程中主线程存在就代表了这个进程的存在，当进程中的主线程结束的时候，操作系统就会将该进程回收</li></ul><h4 id="有了进程为什么还要线程"><a href="#有了进程为什么还要线程" class="headerlink" title="有了进程为什么还要线程?"></a>有了进程为什么还要线程?</h4><p>进程有很多优点，它提供了多道编程，让我们感觉我们每个人都拥有自己的CPU和其他资源，可以提高计算机的利用率。很多人就不理解了，既然进程这么优秀，为什么还要线程呢？其实，仔细观察就会发现进程还是有很多缺陷的，主要体现在两点上：</p><ul><li>进程只能在一个时间干一件事，如果想同时干两件事或多件事，进程就无能为力了。</li><li>进程在执行的过程中如果阻塞，例如等待输入，整个进程就会挂起，即使进程中有些工作不依赖于输入的数据，也将无法执行。</li></ul><p>例如，我们在使用qq聊天， qq做为一个独立进程如果同一时间只能干一件事，那他如何实现在同一时刻 即能监听键盘输入、又能监听其它人给你发的消息、同时还能把别人发的消息显示在屏幕上呢？你会说，操作系统不是有分时么？但是分时是指在不同进程间的分时， 即操作系统处理一会你的qq任务，又切换到word文档任务上了，每个cpu时间片分给你的qq程序时，事实上，你的qq还是同一时间只能干一件事情。</p><p>再直白一点， 一个操作系统就像是一个工厂，工厂里面有很多个生产车间，不同的车间生产不同的产品，每个车间就相当于一个进程，且你的工厂又穷，供电不足，同一时间只能给一个车间供电，为了能让所有车间都能同时生产，你的工厂的电工只能给不同的车间分时供电，但是轮到你的qq车间时，发现只有一个干活的工人，结果生产效率极低，为了解决这个问题，就需要多加几个工人，让几个人工人并行工作，这每个工人，就是线程！</p><h4 id="线程的特点"><a href="#线程的特点" class="headerlink" title="线程的特点"></a>线程的特点</h4><p>在多线程的操作系统中，通常是在一个进程中包括多个线程，每个线程都是作为利用CPU的基本单位，是花费最小开销的实体。线程具有以下属性。</p><p>　　1）轻型实体</p><p>　　线程中的实体基本上不拥有系统资源，只是有一点必不可少的、能保证独立运行的资源。</p><p>　　线程的实体包括程序、数据和TCB。线程是动态概念，它的动态特性由线程控制块TCB（Thread Control Block）描述。</p><p>​    2）独立调度和分派的基本单位</p><p>　　在多线程OS中，线程是能独立运行的基本单位，因而也是独立调度和分派的基本单位。由于线程很“轻”，故线程的切换非常迅速且开销小（在同一进程中的）。</p><p>​    3）共享进程资源</p><p>　　线程在同一进程中的各个线程，都可以共享该进程所拥有的资源，这首先表现在：所有线程都具有相同的进程id，这意味着，线程可以访问该进程的每一个内存资源；此外，还可以访问进程所拥有的已打开文件、定时器、信号量机构等。由于同一个进程内的线程共享内存和文件，所以线程之间互相通信不必调用内核。</p><p>　　4）可并发执行</p><p>　　<em>在一个进程中的多个线程之间，可以并发执行，甚至允许在一个进程中所有线程都能并发执行；同样，不同进程中的线程也能并发执行，充分利用和发挥了处理机与外围设备并行工作的能力。</em></p><blockquote><p>TCB包括以下信息：<br>（1）线程状态。<br>（2）当线程不运行时，被保存的现场资源。<br>（3）一组执行堆栈。<br>（4）存放每个线程的局部变量主存区。<br>（5）访问同一个进程中的主存和其它资源。<br>用于指示被执行指令序列的程序计数器、保留局部变量、少数状态参数和返回地址等的一组寄存器和堆栈。</p></blockquote><h4 id="进程和线程的区别"><a href="#进程和线程的区别" class="headerlink" title="进程和线程的区别"></a>进程和线程的区别</h4><ol><li>线程是共享内存空间的；进程的内存是独立的。</li><li>线程可以直接访问此进程中的数据部分；进程有他们独立拷贝自己父进程的数据部分，每个进程是独立的</li><li>同一进程的线程之间直接交流(直接交流涉及到数据共享，信息传递)；两个进程想通信，必须通过一个中间代理来实现。</li><li>创建一个新的线程很容易；创建新的进程需要对其父进程进行一次克隆。</li><li>一个线程可以控制和操作同一进程里的其他线程；但是进程只能操作子进程。</li><li>对主线程的修改，可能会影响到进程中其他线程的修改；对于一个父进程的修改不会影响其他子进程(只要不删除父进程即可)</li></ol><h5 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a><strong>疑问</strong></h5><p>进程和线程那个运行快？</p><p>它俩是没有可比性的，线程是寄生在进程中的，你问它俩谁快。说白了，就是问在问两个线程谁快。因为进程只是资源的集合，进程也是要起一个线程的，它俩没有可比性。</p><p>进程和线程那个启动快？</p><p>答案是：线程快。因为进程相当于在修一个屋子。线程只是一下把一个来过来就行了。进程是一堆资源的集合。它要去内存里面申请空间，它要各种各样的东西去跟OS去申请。但是启动起来一运行，它俩是一样的，因为进程也是通过线程来运行的。</p><h4 id="自己理解"><a href="#自己理解" class="headerlink" title="自己理解"></a>自己理解</h4><ol><li>线程是操作系统最小的调度单位，是一串指令的集合。</li><li>进程要操作CPU，必须先创建一个线程。</li><li>进程本身是不可以执行的，操作cpu是通过线程实现的，因为它是一堆执行，而进程是不具备执行概念的。就像一个屋子，屋子就是进程，但是屋子里面的每一个人就是线程，屋子就是内存空间。</li><li>单核CPU只能同时干一件事，但是为什么给我们的感觉是在干了很多件事？因为上线的切换，刚才也说了跟读书那个例子一样。因为CPU太快了，可以有N多次切换，其实它都是在排着队呐。</li><li>寄存器是存上下文关系的。</li><li>进程是通过PID来区分的，并不是通过进程名来区分的。进程里面的第一个线程就是主线程，父线程和子线程是相互独立的，只是父线程创建了子线程，父线程down了，子线程不会受到影响的。</li><li>主线程修改影响其他线程的行文，因为它们是共享数据的。</li></ol><h4 id="线程的创建Threading-Thread类"><a href="#线程的创建Threading-Thread类" class="headerlink" title="线程的创建Threading.Thread类"></a>线程的创建Threading.Thread类</h4><h5 id="线程的创建"><a href="#线程的创建" class="headerlink" title="线程的创建"></a>线程的创建</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sayhi</span><span class="params">(name)</span>:</span></span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    print(<span class="string">'%s say hello'</span> %name)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    t=Thread(target=sayhi,args=(<span class="string">'egon'</span>,))</span><br><span class="line">    t.start()</span><br><span class="line">    print(<span class="string">'主线程'</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sayhi</span><span class="params">(Thread)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,name)</span>:</span></span><br><span class="line">        super().__init__()</span><br><span class="line">        self.name=name</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        time.sleep(<span class="number">2</span>)</span><br><span class="line">        print(<span class="string">'%s say hello'</span> % self.name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    t = Sayhi(<span class="string">'egon'</span>)</span><br><span class="line">    t.start()</span><br><span class="line">    print(<span class="string">'主线程'</span>)</span><br></pre></td></tr></table></figure><h5 id="多线程与多进程"><a href="#多线程与多进程" class="headerlink" title="多线程与多进程"></a>多线程与多进程</h5><h6 id="pid的比较"><a href="#pid的比较" class="headerlink" title="pid的比较"></a>pid的比较</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">work</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'hello'</span>,os.getpid())</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment">#part1:在主进程下开启多个线程,每个线程都跟主进程的pid一样</span></span><br><span class="line">    t1=Thread(target=work)</span><br><span class="line">    t2=Thread(target=work)</span><br><span class="line">    t1.start()</span><br><span class="line">    t2.start()</span><br><span class="line">    print(<span class="string">'主线程/主进程pid'</span>,os.getpid())</span><br><span class="line"></span><br><span class="line">    <span class="comment">#part2:开多个进程,每个进程都有不同的pid</span></span><br><span class="line">    p1=Process(target=work)</span><br><span class="line">    p2=Process(target=work)</span><br><span class="line">    p1.start()</span><br><span class="line">    p2.start()</span><br><span class="line">    print(<span class="string">'主线程/主进程pid'</span>,os.getpid())</span><br></pre></td></tr></table></figure><h6 id="开启效率的较量"><a href="#开启效率的较量" class="headerlink" title="开启效率的较量"></a>开启效率的较量</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">work</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'hello'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment">#在主进程下开启线程</span></span><br><span class="line">    t=Thread(target=work)</span><br><span class="line">    t.start()</span><br><span class="line">    print(<span class="string">'主线程/主进程'</span>)</span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    打印结果:</span></span><br><span class="line"><span class="string">    hello</span></span><br><span class="line"><span class="string">    主线程/主进程</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#在主进程下开启子进程</span></span><br><span class="line">    t=Process(target=work)</span><br><span class="line">    t.start()</span><br><span class="line">    print(<span class="string">'主线程/主进程'</span>)</span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    打印结果:</span></span><br><span class="line"><span class="string">    主线程/主进程</span></span><br><span class="line"><span class="string">    hello</span></span><br><span class="line"><span class="string">    '''</span></span><br></pre></td></tr></table></figure><h6 id="内存数据的共享问题"><a href="#内存数据的共享问题" class="headerlink" title="内存数据的共享问题"></a>内存数据的共享问题</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span>  threading <span class="keyword">import</span> Thread</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">work</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> n</span><br><span class="line">    n=<span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment"># n=100</span></span><br><span class="line">    <span class="comment"># p=Process(target=work)</span></span><br><span class="line">    <span class="comment"># p.start()</span></span><br><span class="line">    <span class="comment"># p.join()</span></span><br><span class="line">    <span class="comment"># print('主',n) #毫无疑问子进程p已经将自己的全局的n改成了0,但改的仅仅是它自己的,查看父进程的n仍然为100</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    n=<span class="number">1</span></span><br><span class="line">    t=Thread(target=work)</span><br><span class="line">    t.start()</span><br><span class="line">    t.join()</span><br><span class="line">    print(<span class="string">'主'</span>,n) <span class="comment">#查看结果为0,因为同一进程内的线程之间共享进程内的数据</span></span><br></pre></td></tr></table></figure><p>上面的例子中最多只启动了一个2个线程，还是用那种古老的方式t1,t2。要是一下子起10个或者100个线程，这种方式就不适用了，其实可以在启动线程的时候，把它加到循环里面去，并且来计算一下它的时间 ：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading,time</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(n)</span>:</span>   <span class="comment">#这边的run方法的名字是自行定义的，跟继承式多线程不一样，那个是强制的</span></span><br><span class="line">    print(<span class="string">"task:"</span>,n)</span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    print(<span class="string">"task done"</span>,n)</span><br><span class="line">  </span><br><span class="line">start_time = time.time()  <span class="comment">#开始时间</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):   <span class="comment">#一次性启动5个线程</span></span><br><span class="line">    t = threading.Thread(target=run,args=(<span class="string">"t-&#123;0&#125;"</span>.format(i),))</span><br><span class="line">    t.start()</span><br><span class="line">  </span><br><span class="line">print(<span class="string">"--------all thead has finished"</span>)</span><br><span class="line">print(<span class="string">"cost:"</span>,time.time()-start_time)  <span class="comment">#计算总耗时</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">#执行结果</span></span><br><span class="line">task: t<span class="number">-0</span></span><br><span class="line">task: t<span class="number">-1</span></span><br><span class="line">task: t<span class="number">-2</span></span><br><span class="line">task: t<span class="number">-3</span></span><br><span class="line">task: t<span class="number">-4</span></span><br><span class="line">--------all thead has finished</span><br><span class="line">cost: <span class="number">0.00096893310546875</span></span><br><span class="line">task done t<span class="number">-1</span></span><br><span class="line">task done t<span class="number">-2</span></span><br><span class="line">task done t<span class="number">-0</span></span><br><span class="line">task done t<span class="number">-4</span></span><br><span class="line">task done t<span class="number">-3</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>这里设置成启动5个线程，并且计算一下时间。这里有个疑问，为什么不启动1000个线程或者更多一点的线程？这是因为：计算机是4核的，它能干的事情，就是4个任务。启动的线程越多，就代表着要在这个很多线程之间进行上下文切换。相当于教室里有一本书，某个人只看了半页，因为cpu要确保每个人都能执行，也就是这本是要确保教室每个同学都能看到，那就相当于每个人看书的时间非常少。也就是说某个同学刚刚把这本书拿过来，一下子又被第二个人，第三个人拿走了。所以就导致所有的人都慢了，所以说如果线程启动1000就没有意义了，导致机器越来越慢，所以要适当设置</strong> </p></blockquote><p>从上面的程序发现，就是我主线程没有等其他的子线程执行完毕，就直接往下执行了，这是为什么呢？而且这个计算的时间根本不是我们想要的时间，中间的sleep 2秒哪里去了?</p><p>其实一个程序至少有一个线程，那先往下走的，没有等的就是主线程，主线程启动了子线程之后，子线程就是独立的，跟主线程就没有关系了。主线程和它启动的子线程是并行关系，这就解释了为什么我的主线程启动子线程之后，没有等子线程，而继续往下走了。所以计算不出来线程总共耗时时间，因为程序已经不是串行的了。程序本身就是一个线程，就是主线程。如果要想测试这五个线程总共花了多长时间，就需要用到线程的join()方法</p><h5 id="join"><a href="#join" class="headerlink" title="join"></a>join</h5><p><img src="..\img\thread\2062170187.png" alt=""></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span><span class="params">(threading.Thread)</span>:</span>  <span class="comment"># 继承threading.Thread</span></span><br><span class="line">    <span class="string">"""继承式多线程"""</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, n, sleep_time)</span>:</span>  <span class="comment"># 增加时间属性</span></span><br><span class="line">        threading.Thread.__init__(self)  <span class="comment"># 也可以写成这样super(MyThread,self).__init__()</span></span><br><span class="line">        self.n = n</span><br><span class="line">        self.sleep_time = sleep_time</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span>  <span class="comment"># 重写run方法</span></span><br><span class="line">        print(<span class="string">'run task'</span>, self.n)</span><br><span class="line">        time.sleep(self.sleep_time)  <span class="comment"># 每个线程可以传入不不同的时间</span></span><br><span class="line">        print(<span class="string">'task done,'</span>, self.n)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">t1 = MyThread(<span class="string">'t1'</span>, <span class="number">2</span>)  <span class="comment"># 实例化</span></span><br><span class="line">t2 = MyThread(<span class="string">'t2'</span>, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">t1.start()  <span class="comment"># 启动一个多线程</span></span><br><span class="line">t2.start()</span><br><span class="line"></span><br><span class="line">t1.join()  <span class="comment"># 把t1.join()放在线程启动之后</span></span><br><span class="line">print(<span class="string">"main thread....."</span>)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">#执行结果</span></span><br><span class="line">run task t1</span><br><span class="line">run task t2</span><br><span class="line">task done, t1</span><br><span class="line">main thread.....</span><br><span class="line">task done, t2</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意：</strong>t1.join() 只等t1的结果，然后主线程继续往下走，因为t2需要等4秒，所以，最后打出来的是t2的执行结果。t1的结果到了，就立刻算结果。这边只计算了t1的结果，没有t2的结果 </p></blockquote><p>那我们怎么计算多个线程的执行时间呢？来我们一起看一下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(n)</span>:</span>  <span class="comment"># 这边的run方法的名字是自行定义的，跟继承式多线程不一样，那个是强制的</span></span><br><span class="line">    print(<span class="string">'task:'</span>, n)</span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    print(<span class="string">'task done'</span>, n)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">start_time = time.time()  <span class="comment"># 开始时间</span></span><br><span class="line">t_obj = []  <span class="comment"># 存放子线程实例</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):  <span class="comment"># 一次性启动10个线程</span></span><br><span class="line">    t = threading.Thread(target=run, args=(<span class="string">'t-&#123;0&#125;'</span>.format(i),))</span><br><span class="line">    t.start()</span><br><span class="line">    t_obj.append(t)  <span class="comment"># 为了不阻塞后面线程的启动，不在这里join，先放到一个列表中</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> t <span class="keyword">in</span> t_obj:  <span class="comment"># 循环线程实例列表，等待所有线程执行完毕</span></span><br><span class="line">    t.join()</span><br><span class="line"></span><br><span class="line">print(<span class="string">'所有线程已经完成'</span>)</span><br><span class="line">print(<span class="string">'cost:'</span>, time.time() - start_time)  <span class="comment"># 计算总耗时</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 执行结果</span></span><br><span class="line">task: t<span class="number">-0</span></span><br><span class="line">task: t<span class="number">-1</span></span><br><span class="line">task: t<span class="number">-2</span></span><br><span class="line">task: t<span class="number">-3</span></span><br><span class="line">task: t<span class="number">-4</span></span><br><span class="line">task: t<span class="number">-5</span></span><br><span class="line">task: t<span class="number">-6</span></span><br><span class="line">task: t<span class="number">-7</span></span><br><span class="line">task: t<span class="number">-8</span></span><br><span class="line">task: t<span class="number">-9</span></span><br><span class="line">task done t<span class="number">-0</span></span><br><span class="line">task done t<span class="number">-1</span></span><br><span class="line">task done t<span class="number">-2</span></span><br><span class="line">task done t<span class="number">-4</span></span><br><span class="line">task done t<span class="number">-3</span></span><br><span class="line">task done t<span class="number">-5</span></span><br><span class="line">task done t<span class="number">-6</span></span><br><span class="line">task done t<span class="number">-9</span></span><br><span class="line">task done t<span class="number">-7</span></span><br><span class="line">task done t<span class="number">-8</span></span><br><span class="line">所有线程已经完成</span><br><span class="line">cost: <span class="number">2.007737159729004</span></span><br></pre></td></tr></table></figure><p>上面的例子在不加join的时候，主线程和子线程完全是并行的，没有了依赖关系，主线程执行了，子线程也执行了。但是加了join之后，主线程依赖子线程执行完毕才往下走。 下面将介绍守护线程</p>]]></content>
      
      <categories>
          
          <category> Python线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 线程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>用Python操作Redis</title>
      <link href="/post/9f312a12.html"/>
      <url>/post/9f312a12.html</url>
      <content type="html"><![CDATA[<h3 id="Redis安装和使用"><a href="#Redis安装和使用" class="headerlink" title="Redis安装和使用"></a>Redis安装和使用</h3><h4 id="Window-下安装"><a href="#Window-下安装" class="headerlink" title="Window 下安装"></a>Window 下安装</h4><p><strong>下载地址：</strong><a href="https://github.com/MSOpenTech/redis/releases" target="_blank" rel="noopener">https://github.com/MSOpenTech/redis/releases</a>。</p><p>Redis 支持 32 位和 64 位。这个需要根据你系统平台的实际情况选择，这里我们下载 <strong>Redis-x64-xxx.zip</strong>压缩包到 C 盘，解压后，将文件夹重新命名为 <strong>redis</strong>。</p><p><img src="http://www.runoob.com/wp-content/uploads/2014/11/3B8D633F-14CE-42E3-B174-FCCD48B11FF3.jpg" alt="img"></p><p>打开一个 <strong>cmd</strong> 窗口 使用cd命令切换目录到 <strong>C:\redis</strong> 运行 <strong>redis-server.exe redis.windows.conf</strong> 。</p><p>如果想方便的话，可以把 redis 的路径加到系统的环境变量里，这样就省得再输路径了，后面的那个 redis.windows.conf 可以省略，如果省略，会启用默认的。输入之后，会显示如下界面：</p><p>这时候另启一个cmd窗口，原来的不要关闭，不然就无法访问服务端了。</p><p>切换到redis目录下运行 <strong>redis-cli.exe -h 127.0.0.1 -p 6379</strong> 。</p><p>设置键值对 <strong>set myKey abc</strong></p><p>取出键值对 <strong>get myKey</strong></p><p><img src="http://www.runoob.com/wp-content/uploads/2014/11/redis-install2.jpg" alt="Redis 安装"></p><hr><h4 id="Linux-下安装"><a href="#Linux-下安装" class="headerlink" title="Linux 下安装"></a>Linux 下安装</h4><p><strong>下载地址：</strong><a href="http://redis.io/download" target="_blank" rel="noopener">http://redis.io/download</a>，下载最新稳定版本。</p><p>本文档使用3.2.11,下载并安装:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ wget http://download.redis.io/releases/redis-3.2.11.tar.gz</span><br><span class="line">$ tar -xvf redis-3.2.11.tar.gz</span><br><span class="line">$ <span class="built_in">cd</span> redis-3.2.11</span><br><span class="line">$ make &amp;&amp; make install</span><br></pre></td></tr></table></figure><p>安装完成后,我们先改一下redis.conf的配置:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ cp redis.conf ../myredis.conf <span class="comment"># 将文件redis.conf复制到上以及文件夹下并命名为myredis.conf</span></span><br><span class="line">$ <span class="built_in">cd</span> ..</span><br><span class="line">$ vim myredis.conf</span><br><span class="line"><span class="comment"># redis.conf是一个默认的配置文件。我们可以根据需要使用自己的配置文件。</span></span><br><span class="line"><span class="comment"># 建议修改以下地方:</span></span><br><span class="line"><span class="comment"># 找到bind这个地方并修改成[bind 本机内网地址]</span></span><br><span class="line"><span class="comment"># 再找到requirepass这个地方,这里是修改redis的密码</span></span><br><span class="line"><span class="comment"># 完成上述操作后保存退出</span></span><br><span class="line">$ redis-server myredis.conf</span><br></pre></td></tr></table></figure><p>启动redis服务进程后，就可以使用测试客户端程序redis-cli和redis服务交互了,如:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ redis-cli -h host -p port</span><br><span class="line">$ auth [password] <span class="comment"># 这里输入的密码就是你上面设置的密码,如果没有则跳过此步骤</span></span><br><span class="line">redis 127.0.0.1:6379&gt; ping</span><br><span class="line">PONG</span><br><span class="line">$ redis-cli -h host -p port -a password <span class="comment"># 这个命令也能登录</span></span><br></pre></td></tr></table></figure><h4 id="用Python连接Redis"><a href="#用Python连接Redis" class="headerlink" title="用Python连接Redis"></a>用Python连接Redis</h4><p>当前在本地我已经安装了 Redis 并运行在 9736 端口，密码设置为 123456</p><p>用下面例子连接Redis进行测试:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> redis</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    config = &#123;</span><br><span class="line">        <span class="string">'host'</span>: <span class="string">'localhost'</span>,</span><br><span class="line">        <span class="string">'port'</span>: <span class="number">9736</span>,</span><br><span class="line">        <span class="string">'db'</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="string">'password'</span>: <span class="string">'123456'</span></span><br><span class="line">    &#125;</span><br><span class="line">    client = redis.Redis(**config)</span><br><span class="line">    <span class="keyword">if</span> client.ping():</span><br><span class="line">        client.set(<span class="string">'name'</span>, <span class="string">'gavinliu'</span>)</span><br><span class="line">        print(client.get(<span class="string">'name'</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>在这里我们使用redis.Redis传入参数连接本地Redis服务,传入的四个参数分别为<code>Redis的地址</code>、<code>运行端口</code>、<code>使用的数据库</code>、<code>密码</code>，我们这里使用的Redis其实是继承了StrictRedis，所以在默认情况下不传这四个参数时，参数值会有默认值分别为localhost、6379、0、None。</p><p>上面运行的结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">b'gavinliu'</span></span><br></pre></td></tr></table></figure><p>在Python中使用Redis其实很方便，Redis的命令(命令详细情况可以参照<a href="http://redisdoc.com/" target="_blank" rel="noopener">Redis命令参考</a>)在Python中都能找到相应的方法，这里引用<a href="https://cuiqingcai.com/" target="_blank" rel="noopener">崔庆才老师</a>对Redis总结介绍一下Key(键)、String(字符串)、Hash(哈希表)、List(列表)、Set(集合)、SortedSet(有序集合)</p><blockquote><p><strong>Key(键)</strong></p></blockquote><table><thead><tr><th>方法</th><th>作用</th><th>参数说明</th><th>示例</th><th>示例说明</th><th>示例结果</th></tr></thead><tbody><tr><td>exists(name)</td><td>判断一个key是否存在</td><td>name: key名</td><td>redis.exists(‘name’)</td><td>是否存在name这个key</td><td>True</td></tr><tr><td>delete(name)</td><td>删除一个key</td><td>name: key名</td><td>redis.delete(‘name’)</td><td>删除name这个key</td><td>1</td></tr><tr><td>type(name)</td><td>判断key类型</td><td>name: key名</td><td>redis.type(‘name’)</td><td>判断name这个key类型</td><td>b’string’</td></tr><tr><td>keys(pattern)</td><td>获取所有符合规则的key</td><td>pattern: 匹配规则</td><td>redis.keys(‘n*’)</td><td>获取所有以n开头的key</td><td>[b’name’]</td></tr><tr><td>randomkey()</td><td>获取随机的一个key</td><td></td><td>randomkey()</td><td>获取随机的一个key</td><td>b’name’</td></tr><tr><td>rename(src, dst)</td><td>将key重命名</td><td>src: 原key名 dst: 新key名</td><td>redis.rename(‘name’, ‘nickname’)</td><td>将name重命名为nickname</td><td>True</td></tr><tr><td>dbsize()</td><td>获取当前数据库中key的数目</td><td></td><td>dbsize()</td><td>获取当前数据库中key的数目</td><td>100</td></tr><tr><td>expire(name, time)</td><td>设定key的过期时间，单位秒</td><td>name: key名 time: 秒数</td><td>redis.expire(‘name’, 2)</td><td>将name这key的过期时间设置2秒</td><td>True</td></tr><tr><td>ttl(name)</td><td>获取key的过期时间，单位秒，-1为永久不过期</td><td>name: key名</td><td>redis.ttl(‘name’)</td><td>获取name这key的过期时间</td><td>-1</td></tr><tr><td>move(name, db)</td><td>将key移动到其他数据库</td><td>name: key名 db: 数据库代号</td><td>move(‘name’, 2)</td><td>将name移动到2号数据库</td><td>True</td></tr><tr><td>flushdb()</td><td>删除当前选择数据库中的所有key</td><td></td><td>flushdb()</td><td>删除当前选择数据库中的所有key</td><td>True</td></tr><tr><td>flushall()</td><td>删除所有数据库中的所有key</td><td></td><td>flushall()</td><td>删除所有数据库中的所有key</td><td>True</td></tr></tbody></table><blockquote><p><strong>String(字符串)</strong></p></blockquote><table><thead><tr><th>方法</th><th>作用</th><th>参数说明</th><th>示例</th><th>示例说明</th><th>示例结果</th></tr></thead><tbody><tr><td>set(name, value)</td><td>给数据库中key为name的string赋予值value</td><td>name: key名 value: 值</td><td>redis.set(‘name’, ‘Bob’)</td><td>给name这个key的value赋值为Bob</td><td>True</td></tr><tr><td>get(name)</td><td>返回数据库中key为name的string的value</td><td>name: key名</td><td>redis.get(‘name’)</td><td>返回name这个key的value</td><td>b’Bob’</td></tr><tr><td>getset(name, value)</td><td>给数据库中key为name的string赋予值value并返回上次的value</td><td>name: key名 value: 新值</td><td>redis.getset(‘name’, ‘Mike’)</td><td>赋值name为Mike并得到上次的value</td><td>b’Bob’</td></tr><tr><td>mget(keys, *args)</td><td>返回多个key对应的value</td><td>keys: key的列表</td><td>redis.mget([‘name’, ‘nickname’])</td><td>返回name和nickname的value</td><td>[b’Mike’, b’Miker’]</td></tr><tr><td>setnx(name, value)</td><td>如果key不存在才设置value</td><td>name: key名</td><td>redis.setnx(‘newname’, ‘James’)</td><td>如果newname这key不存在则设置值为James</td><td>第一次运行True，第二次False</td></tr><tr><td>setex(name, time, value)</td><td>设置可以对应的值为string类型的value，并指定此键值对应的有效期</td><td>name: key名 time: 有效期 value: 值</td><td>redis.setex(‘name’, 1, ‘James’)</td><td>将name这key的值设为James，有效期1秒</td><td>True</td></tr><tr><td>setrange(name, offset, value)</td><td>设置指定key的value值的子字符串</td><td>name: key名 offset: 偏移量 value: 值</td><td>redis.set(‘name’, ‘Hello’) redis.setrange(‘name’, 6, ‘World’)</td><td>设置name为Hello字符串，并在index为6的位置补World</td><td>11，修改后的字符串长度</td></tr><tr><td>mset(mapping)</td><td>批量赋值</td><td>mapping: 字典</td><td>redis.mset({‘name1’: ‘Durant’, ‘name2’: ‘James’})</td><td>将name1设为Durant，name2设为James</td><td>True</td></tr><tr><td>msetnx(mapping)</td><td>key均不存在时才批量赋值</td><td>mapping: 字典</td><td>redis.msetnx({‘name3’: ‘Smith’, ‘name4’: ‘Curry’})</td><td>在name3和name4均不存在的情况下才设置二者值</td><td>True</td></tr><tr><td>incr(name, amount=1)</td><td>key为name的value增值操作，默认1，key不存在则被创建并设为amount</td><td>name: key名 amount:增长的值</td><td>redis.incr(‘age’, 1)</td><td>age对应的值增1，若不存在则会创建并设置为1</td><td>1，即修改后的值</td></tr><tr><td>decr(name, amount=1)</td><td>key为name的value减值操作，默认1，key不存在则被创建并设置为-amount</td><td>name: key名 amount:减少的值</td><td>redis.decr(‘age’, 1)</td><td>age对应的值减1，若不存在则会创建并设置为-1</td><td>-1，即修改后的值</td></tr><tr><td>append(key, value)</td><td>key为name的string的值附加value</td><td>key: key名</td><td>redis.append(‘nickname’, ‘OK’)</td><td>向key为nickname的值后追加OK</td><td>13，即修改后的字符串长度</td></tr><tr><td>substr(name, start, end=-1)</td><td>返回key为name的string的value的子串</td><td>name: key名 start: 起始索引 end: 终止索引，默认-1截取到末尾</td><td>redis.substr(‘name’, 1, 4)</td><td>返回key为name的值的字符串，截取索引为1-4的字符</td><td>b’ello’</td></tr><tr><td>getrange(key, start, end)</td><td>获取key的value值从start到end的子字符串</td><td>key: key名 start: 起始索引 end: 终止索引</td><td>redis.getrange(‘name’, 1, 4)</td><td>返回key为name的值的字符串，截取索引为1-4的字符</td><td>b’ello’</td></tr></tbody></table><blockquote><p><strong>Hash(哈希表)</strong></p></blockquote><p>Hash，即哈希。Redis 还提供了哈希表的数据结构，我们可以用name指定一个哈希表的名称，然后表内存储了各个键值对，用法总结如下：</p><table><thead><tr><th>方法</th><th>作用</th><th>参数说明</th><th>示例</th><th>示例说明</th><th>示例结果</th></tr></thead><tbody><tr><td>hset(name, key, value)</td><td>向key为name的hash中添加映射</td><td>name: key名 key: 映射键名 value: 映射键值</td><td>hset(‘price’, ‘cake’, 5)</td><td>向key为price的hash中添加映射关系，cake的值为5</td><td>1，即添加的映射个数</td></tr><tr><td>hsetnx(name, key, value)</td><td>向key为name的hash中添加映射，如果映射键名不存在</td><td>name: key名 key: 映射键名 value: 映射键值</td><td>hsetnx(‘price’, ‘book’, 6)</td><td>向key为price的hash中添加映射关系，book的值为6</td><td>1，即添加的映射个数</td></tr><tr><td>hget(name, key)</td><td>返回key为name的hash中field对应的value</td><td>name: key名 key: 映射键名</td><td>redis.hget(‘price’, ‘cake’)</td><td>获取key为price的hash中键名为cake的value</td><td>5</td></tr><tr><td>hmget(name, keys, *args)</td><td>返回key为name的hash中各个键对应的value</td><td>name: key名 keys: 映射键名列表</td><td>redis.hmget(‘price’, [‘apple’, ‘orange’])</td><td>获取key为price的hash中apple和orange的值</td><td>[b’3’, b’7’]</td></tr><tr><td>hmset(name, mapping)</td><td>向key为name的hash中批量添加映射</td><td>name: key名 mapping: 映射字典</td><td>redis.hmset(‘price’, {‘banana’: 2, ‘pear’: 6})</td><td>向key为price的hash中批量添加映射</td><td>True</td></tr><tr><td>hincrby(name, key, amount=1)</td><td>将key为name的hash中映射的value增加amount</td><td>name: key名 key: 映射键名 amount: 增长量</td><td>redis.hincrby(‘price’, ‘apple’, 3)</td><td>key为price的hash中apple的值增加3</td><td>6，修改后的值</td></tr><tr><td>hexists(name, key)</td><td>key为namehash中是否存在键名为key的映射</td><td>name: key名 key: 映射键名</td><td>redis.hexists(‘price’, ‘banana’)</td><td>key为price的hash中banana的值是否存在</td><td>True</td></tr><tr><td>hdel(name, *keys)</td><td>key为namehash中删除键名为key的映射</td><td>name: key名 key: 映射键名</td><td>redis.hdel(‘price’, ‘banana’)</td><td>从key为price的hash中删除键名为banana的映射</td><td>True</td></tr><tr><td>hlen(name)</td><td>从key为name的hash中获取映射个数</td><td>name: key名</td><td>redis.hlen(‘price’)</td><td>从key为price的hash中获取映射个数</td><td>6</td></tr><tr><td>hkeys(name)</td><td>从key为name的hash中获取所有映射键名</td><td>name: key名</td><td>redis.hkeys(‘price’)</td><td>从key为price的hash中获取所有映射键名</td><td>[b’cake’, b’book’, b’banana’, b’pear’]</td></tr><tr><td>hvals(name)</td><td>从key为name的hash中获取所有映射键值</td><td>name: key名</td><td>redis.hvals(‘price’)</td><td>从key为price的hash中获取所有映射键值</td><td>[b’5’, b’6’, b’2’, b’6’]</td></tr><tr><td>hgetall(name)</td><td>从key为name的hash中获取所有映射键值对</td><td>name: key名</td><td>redis.hgetall(‘price’)</td><td>从key为price的hash中获取所有映射键值对</td><td>{b’cake’: b’5’, b’book’: b’6’, b’orange’: b’7’, b’pear’: b’6’}</td></tr></tbody></table><blockquote><p><strong>List(列表)</strong></p></blockquote><p>Redis 还提供了列表存储，列表内的元素可以重复，而且可以从两端存储</p><table><thead><tr><th>方法</th><th>作用</th><th>参数说明</th><th>示例</th><th>示例说明</th><th>示例结果</th></tr></thead><tbody><tr><td>rpush(name, *values)</td><td>在key为name的list尾添加值为value的元素，可以传多个</td><td>name: key名 values: 值</td><td>redis.rpush(‘list’, 1, 2, 3)</td><td>给list这个key的list尾添加1、2、3</td><td>3，list大小</td></tr><tr><td>lpush(name, *values)</td><td>在key为name的list头添加值为value的元素，可以传多个</td><td>name: key名 values: 值</td><td>redis.lpush(‘list’, 0)</td><td>给list这个key的list头添加0</td><td>4，list大小</td></tr><tr><td>llen(name)</td><td>返回key为name的list的长度</td><td>name: key名</td><td>redis.llen(‘list’)</td><td>返回key为list的列表的长度</td><td>4</td></tr><tr><td>lrange(name, start, end)</td><td>返回key为name的list中start至end之间的元素</td><td>name: key名 start: 起始索引 end: 终止索引</td><td>redis.lrange(‘list’, 1, 3)</td><td>返回起始为1终止为3的索引范围对应的list</td><td><code>[b&#39;3&#39;, b&#39;2&#39;, b&#39;1&#39;]</code></td></tr><tr><td>ltrim(name, start, end)</td><td>截取key为name的list，保留索引为start到end的内容</td><td>name:key名 start: 起始索引 end: 终止索引</td><td>ltrim(‘list’, 1, 3)</td><td>保留key为list的索引为1到3的元素</td><td>True</td></tr><tr><td>lindex(name, index)</td><td>返回key为name的list中index位置的元素</td><td>name: key名 index: 索引</td><td>redis.lindex(‘list’, 1)</td><td>返回key为list的列表index为1的元素</td><td>b’2’</td></tr><tr><td>lset(name, index, value)</td><td>给key为name的list中index位置的元素赋值，越界则报错</td><td>name: key名 index: 索引位置 value: 值</td><td>redis.lset(‘list’, 1, 5)</td><td>将key为list的list索引1位置赋值为5</td><td>True</td></tr><tr><td>lrem(name, count, value)</td><td>删除count个key的list中值为value的元素</td><td>name: key名 count: 删除个数 value: 值</td><td>redis.lrem(‘list’, 2, 3)</td><td>将key为list的列表删除2个3</td><td>1，即删除的个数</td></tr><tr><td>lpop(name)</td><td>返回并删除key为name的list中的首元素</td><td>name: key名</td><td>redis.lpop(‘list’)</td><td>返回并删除名为list的list第一个元素</td><td>b’5’</td></tr><tr><td>rpop(name)</td><td>返回并删除key为name的list中的尾元素</td><td>name: key名</td><td>redis.rpop(‘list’)</td><td>返回并删除名为list的list最后一个元素</td><td>b’2’</td></tr><tr><td>blpop(keys, timeout=0)</td><td>返回并删除名称为在keys中的list中的首元素，如果list为空，则会一直阻塞等待</td><td>keys: key列表 timeout: 超时等待时间，0为一直等待</td><td>redis.blpop(‘list’)</td><td>返回并删除名为list的list的第一个元素</td><td>[b’5’]</td></tr><tr><td>brpop(keys, timeout=0)</td><td>返回并删除key为name的list中的尾元素，如果list为空，则会一直阻塞等待</td><td>keys: key列表 timeout: 超时等待时间，0为一直等待</td><td>redis.brpop(‘list’)</td><td>返回并删除名为list的list的最后一个元素</td><td>[b’2’]</td></tr><tr><td>rpoplpush(src, dst)</td><td>返回并删除名称为src的list的尾元素，并将该元素添加到名称为dst的list的头部</td><td>src: 源list的key dst: 目标list的key</td><td>redis.rpoplpush(‘list’, ‘list2’)</td><td>将key为list的list尾元素删除并返回并将其添加到key为list2的list头部</td><td>b’2’</td></tr></tbody></table><blockquote><p><strong>Set(集合)</strong></p></blockquote><p>Redis 还提供了集合存储，集合中的元素都是不重复的</p><table><thead><tr><th>方法</th><th>作用</th><th>参数说明</th><th>示例</th><th>示例说明</th><th>示例结果</th></tr></thead><tbody><tr><td>sadd(name, *values)</td><td>向key为name的set中添加元素</td><td>name: key名 values: 值，可为多个</td><td>redis.sadd(‘tags’, ‘Book’, ‘Tea’, ‘Coffee’)</td><td>向key为tags的set中添加Book、Tea、Coffee三个内容</td><td>3，即插入的数据个数</td></tr><tr><td>srem(name, *values)</td><td>从key为name的set中删除元素</td><td>name: key名 values: 值，可为多个</td><td>redis.srem(‘tags’, ‘Book’)</td><td>从key为tags的set中删除Book</td><td>1，即删除的数据个数</td></tr><tr><td>spop(name)</td><td>随机返回并删除key为name的set中一个元素</td><td>name: key名</td><td>redis.spop(‘tags’)</td><td>从key为tags的set中随机删除并返回该元素</td><td>b’Tea’</td></tr><tr><td>smove(src, dst, value)</td><td>从src对应的set中移除元素并添加到dst对应的set中</td><td>src: 源set dst: 目标set value: 元素值</td><td>redis.smove(‘tags’, ‘tags2’, ‘Coffee’)</td><td>从key为tags的set中删除元素Coffee并添加到key为tags2的set</td><td>True</td></tr><tr><td>scard(name)</td><td>返回key为name的set的元素个数</td><td>name: key名</td><td>redis.scard(‘tags’)</td><td>获取key为tags的set中元素个数</td><td>3</td></tr><tr><td>sismember(name, value)</td><td>测试member是否是key为name的set的元素</td><td>name:key值</td><td>redis.sismember(‘tags’, ‘Book’)</td><td>判断Book是否为key为tags的set元素</td><td>True</td></tr><tr><td>sinter(keys, *args)</td><td>返回所有给定key的set的交集</td><td>keys: key列表</td><td>redis.sinter([‘tags’, ‘tags2’])</td><td>返回key为tags的set和key为tags2的set的交集</td><td>{b’Coffee’}</td></tr><tr><td>sinterstore(dest, keys, *args)</td><td>求交集并将交集保存到dest的集合</td><td>dest:结果集合 keys:key列表</td><td>redis.sinterstore(‘inttag’, [‘tags’, ‘tags2’])</td><td>求key为tags的set和key为tags2的set的交集并保存为inttag</td><td>1</td></tr><tr><td>sunion(keys, *args)</td><td>返回所有给定key的set的并集</td><td>keys: key列表</td><td>redis.sunion([‘tags’, ‘tags2’])</td><td>返回key为tags的set和key为tags2的set的并集</td><td>{b’Coffee’, b’Book’, b’Pen’}</td></tr><tr><td>sunionstore(dest, keys, *args)</td><td>求并集并将并集保存到dest的集合</td><td>dest:结果集合 keys:key列表</td><td>redis.sunionstore(‘inttag’, [‘tags’, ‘tags2’])</td><td>求key为tags的set和key为tags2的set的并集并保存为inttag</td><td>3</td></tr><tr><td>sdiff(keys, *args)</td><td>返回所有给定key的set的差集</td><td>keys: key列表</td><td>redis.sdiff([‘tags’, ‘tags2’])</td><td>返回key为tags的set和key为tags2的set的差集</td><td>{b’Book’, b’Pen’}</td></tr><tr><td>sdiffstore(dest, keys, *args)</td><td>求差集并将差集保存到dest的集合</td><td>dest:结果集合 keys:key列表</td><td>redis.sdiffstore(‘inttag’, [‘tags’, ‘tags2’])</td><td>求key为tags的set和key为tags2的set的差集并保存为inttag</td><td>3</td></tr><tr><td>smembers(name)</td><td>返回key为name的set的所有元素</td><td>name: key名</td><td>redis.smembers(‘tags’)</td><td>返回key为tags的set的所有元素</td><td>{b’Pen’, b’Book’, b’Coffee’}</td></tr><tr><td>srandmember(name)</td><td>随机返回key为name的set的一个元素，但不删除元素</td><td>name: key值</td><td>redis.srandmember(‘tags’)</td><td>随机返回key为tags的set的一个元素</td></tr></tbody></table><blockquote><p><strong>SortedSet(有序集合)</strong></p></blockquote><p>有序集合，它相比集合多了一个分数字段，利用它我们可以对集合中的数据进行排序</p><table><thead><tr><th>方法</th><th>作用</th><th>参数说明</th><th>示例</th><th>示例说明</th><th>示例结果</th></tr></thead><tbody><tr><td>zadd(name, <em>args, *</em>kwargs)</td><td>向key为name的zset中添加元素member，score用于排序。如果该元素存在，则更新其顺序</td><td>name: key名 args: 可变参数</td><td>redis.zadd(‘grade’, 100, ‘Bob’, 98, ‘Mike’)</td><td>向key为grade的zset中添加Bob，score为100，添加Mike，score为98</td><td>2，即添加的元素个数</td></tr><tr><td>zrem(name, *values)</td><td>删除key为name的zset中的元素</td><td>name: key名 values: 元素</td><td>redis.zrem(‘grade’, ‘Mike’)</td><td>从key为grade的zset中删除Mike</td><td>1，即删除的元素个数</td></tr><tr><td>zincrby(name, value, amount=1)</td><td>如果在key为name的zset中已经存在元素value，则该元素的score增加amount，否则向该集合中添加该元素，其score的值为amount</td><td>name: key名 value: 元素 amount: 增长的score值</td><td>redis.zincrby(‘grade’, ‘Bob’, -2)</td><td>key为grade的zset中Bob的score减2</td><td>98.0，即修改后的值</td></tr><tr><td>zrank(name, value)</td><td>返回key为name的zset中元素的排名（按score从小到大排序）即下标</td><td>name: key名 value: 元素值</td><td>redis.zrank(‘grade’, ‘Amy’)</td><td>得到key为grade的zset中Amy的排名</td><td>1</td></tr><tr><td>zrevrank(name, value)</td><td>返回key为name的zset中元素的倒数排名（按score从大到小排序）即下标</td><td>name: key名 value: 元素值</td><td>redis.zrevrank(‘grade’, ‘Amy’)</td><td>得到key为grade的zset中Amy的倒数排名</td><td>2</td></tr><tr><td>zrevrange(name, start, end, withscores=False)</td><td>返回key为name的zset（按score从大到小排序）中的index从start到end的所有元素</td><td>name: key值 start: 开始索引 end: 结束索引 withscores: 是否带score</td><td>redis.zrevrange(‘grade’, 0, 3)</td><td>返回key为grade的zset前四名元素</td><td>[b’Bob’, b’Mike’, b’Amy’, b’James’]</td></tr><tr><td>zrangebyscore(name, min, max, start=None, num=None, withscores=False)</td><td>返回key为name的zset中score在给定区间的元素</td><td>name:key名 min: 最低score max:最高score start: 起始索引 num: 个数 withscores: 是否带score</td><td>redis.zrangeby score(‘grade’, 80, 95)</td><td>返回key为grade的zset中score在80和95之间的元素</td><td>[b’Amy’, b’James’]</td></tr><tr><td>zcount(name, min, max)</td><td>返回key为name的zset中score在给定区间的数量</td><td>name:key名 min: 最低score max: 最高score</td><td>redis.zcount(‘grade’, 80, 95)</td><td>返回key为grade的zset中score在80到95的元素个数</td><td>2</td></tr><tr><td>zcard(name)</td><td>返回key为name的zset的元素个数</td><td>name: key名</td><td>redis.zcard(‘grade’)</td><td>获取key为grade的zset中元素个数</td><td>3</td></tr><tr><td>zremrangebyrank(name, min, max)</td><td>删除key为name的zset中排名在给定区间的元素</td><td>name:key名 min: 最低位次 max: 最高位次</td><td>redis.zremran gebyrank(‘grade’, 0, 0)</td><td>删除key为grade的zset中排名第一的元素</td><td>1，即删除的元素个数</td></tr><tr><td>zremrangebyscore(name, min, max)</td><td>删除key为name的zset中score在给定区间的元素</td><td>name:key名 min: 最低score max:最高score</td><td>redis.zremran gebyscore (‘grade’, 80, 90)</td><td>删除score在80到90之间的元素</td><td>1，即删除的元素个数</td></tr></tbody></table><blockquote><p>注意：上面代码中由于展示显示不完全，本人做了相应的处理，原本是一个方法名的可能方法名中间会出现空格</p></blockquote><p>以上便是用Python操作Redis的总结了，在后面的项目中会常用到Redis操作，所以我们还是需要掌握一些常用操作。</p>]]></content>
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Python进程池</title>
      <link href="/post/d1bc6a63.html"/>
      <url>/post/d1bc6a63.html</url>
      <content type="html"><![CDATA[<h3 id="进程池"><a href="#进程池" class="headerlink" title="进程池"></a>进程池</h3><p>为什么要有进程池?</p><p>在程序实际处理问题过程中，忙时会有成千上万的任务需要被执行，闲时可能只有零星任务。那么在成千上万个任务需要被执行的时候，我们就需要去创建成千上万个进程么？首先，创建进程需要消耗时间，销毁进程也需要消耗时间。第二即便开启了成千上万的进程，操作系统也不能让他们同时执行，这样反而会影响程序的效率。因此我们不能无限制的根据任务开启或者结束进程。那么我们要怎么做呢？</p><p>在这里，要给大家介绍一个进程池的概念，定义一个池子，在里面放上固定数量的进程，有需求来了，就拿一个池中的进程来处理任务，等到处理完毕，进程并不关闭，而是将进程再放回进程池中继续等待任务。如果有很多任务需要执行，池中的进程数量不够，任务就要等待之前的进程执行任务完毕归来，拿到空闲进程才能继续执行。也就是说，池中进程的数量是固定的，那么同一时间最多有固定数量的进程在运行。这样不会增加操作系统的调度难度，还节省了开闭进程的时间，也一定程度上能够实现并发效果。</p><h3 id="multiprocess-Pool模块"><a href="#multiprocess-Pool模块" class="headerlink" title="multiprocess.Pool模块"></a>multiprocess.Pool模块</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Pool([numprocess  [,initializer [, initargs]]]):创建进程池</span><br></pre></td></tr></table></figure><p>参数介绍 ：</p><ul><li>numprocess：要创建的进程数，如果省略，将默认使用cpu_count()的值</li><li>initializer：是每个工作进程启动时要执行的可调用对象，默认为None</li><li>initargs：是要传给initializer的参数组</li></ul><p>主要方法 ：</p><ul><li><p>p.apply(func [, args [, kwargs]]):在一个池工作进程中执行func(<em>args,*</em>kwargs),然后返回结果。</p><blockquote><p>注意：此操作并不会在所有池工作进程中并执行func函数。如果要通过不同参数并发地执行func函数，必须从不同线程调用p.apply()函数或者使用p.apply_async()</p></blockquote></li><li><p>p.apply_async(func [, args [, kwargs [, callback]]]):在一个池工作进程中执行func(<em>args,*</em>kwargs),然后返回结果。</p><blockquote><p>此方法的结果是AsyncResult类的实例，callback是可调用对象，接收输入参数。当func的结果变为可用时，将理解传递给callback。callback禁止执行任何阻塞操作，否则将接收其他异步操作中的结果。</p></blockquote></li><li><p>p.close():关闭进程池，防止进一步操作。如果所有操作持续挂起，它们将在工作进程终止前完成</p></li><li><p>P.jion():等待所有工作进程退出。此方法只能在close（）或teminate()之后调用</p></li></ul><p>其他方法：</p><p>​    方法apply_async()和map_async（）的返回值是AsyncResul的实例obj。实例具有以下方法</p><ul><li><ul><li>obj.get():返回结果，如果有必要则等待结果到达。timeout是可选的。如果在指定时间内还没有到达，将引发异常。如果远程操作中引发了异常，它将在调用此方法时再次被引发。</li><li>obj.ready():如果调用完成，返回True</li><li>obj.successful():如果调用完成且没有引发异常，返回True，如果在结果就绪之前调用此方法，引发异常</li><li>obj.wait([timeout]):等待结果变为可用</li><li>obj.terminate()：立即终止所有工作进程，同时不执行任何清理或结束任何挂起工作。如果p被垃圾回收，将自动调用此函数</li></ul></li></ul><h4 id="进程池的同步调用"><a href="#进程池的同步调用" class="headerlink" title="进程池的同步调用"></a>进程池的同步调用</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os,time</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">work</span><span class="params">(n)</span>:</span></span><br><span class="line">    print(<span class="string">'%s run'</span> %os.getpid())</span><br><span class="line">    time.sleep(<span class="number">3</span>)</span><br><span class="line">    <span class="keyword">return</span> n**<span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    p=Pool(<span class="number">3</span>)  <span class="comment"># 进程池中从无到有创建三个进程,以后一直是这三个进程在执行任务</span></span><br><span class="line">    res_l=[]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        res=p.apply(work,args=(i,))  <span class="comment"># 同步调用，直到本次任务执行完毕拿到res，等待任务work执行的过程中可能有阻塞也可能没有阻塞</span></span><br><span class="line">    <span class="comment"># 但不管该任务是否存在阻塞，同步调用都会在原地等着</span></span><br><span class="line">    print(res_l)</span><br></pre></td></tr></table></figure><h4 id="进程池的异步调用"><a href="#进程池的异步调用" class="headerlink" title="进程池的异步调用"></a>进程池的异步调用</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">work</span><span class="params">(n)</span>:</span></span><br><span class="line">    print(<span class="string">'%s run'</span> %os.getpid())</span><br><span class="line">    time.sleep(random.random())</span><br><span class="line">    <span class="keyword">return</span> n**<span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    p=Pool(<span class="number">3</span>)  <span class="comment"># 进程池中从无到有创建三个进程,以后一直是这三个进程在执行任务</span></span><br><span class="line">    res_l=[]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        res=p.apply_async(work,args=(i,))  <span class="comment"># 异步运行，根据进程池中有的进程数，每次最多3个子进程在异步执行</span></span><br><span class="line">                                           <span class="comment"># 返回结果之后，将结果放入列表，归还进程，之后再执行新的任务</span></span><br><span class="line">                                           <span class="comment"># 需要注意的是，进程池中的三个进程不会同时开启或者同时结束</span></span><br><span class="line">                                           <span class="comment"># 而是执行完一个就释放一个进程，这个进程就去接收新的任务。  </span></span><br><span class="line">        res_l.append(res)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 异步apply_async用法：如果使用异步提交的任务，主进程需要使用jion，等待进程池内任务都处理完，然后可以用get收集结果</span></span><br><span class="line">    <span class="comment"># 否则，主进程结束，进程池可能还没来得及执行，也就跟着一起结束了</span></span><br><span class="line">    p.close()</span><br><span class="line">    p.join()</span><br><span class="line">    <span class="keyword">for</span> res <span class="keyword">in</span> res_l:</span><br><span class="line">        print(res.get()) <span class="comment">#使用get来获取apply_aync的结果,如果是apply,则没有get方法,因为apply是同步执行,立刻获取结果,也根本无需get</span></span><br></pre></td></tr></table></figure><h4 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h4><p>需要回调函数的场景：进程池中任何一个任务一旦处理完了，就立即告知主进程：我好了额，你可以处理我的结果了。主进程则调用一个函数去处理该结果，该函数即回调函数</p><p>我们可以把耗时间（阻塞）的任务放到进程池中，然后指定回调函数（主进程负责执行），这样主进程在执行回调函数时就省去了I/O的过程，直接拿到的是任务的结果。</p><p>下面来看看实例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">from</span> urllib.request <span class="keyword">import</span> urlopen</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_page</span><span class="params">(url,pattern)</span>:</span></span><br><span class="line">    response=urlopen(url).read().decode(<span class="string">'utf-8'</span>)</span><br><span class="line">    <span class="keyword">return</span> pattern,response</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse_page</span><span class="params">(info)</span>:</span></span><br><span class="line">    pattern,page_content=info</span><br><span class="line">    res=re.findall(pattern,page_content)</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> res:</span><br><span class="line">        dic=&#123;</span><br><span class="line">            <span class="string">'index'</span>:item[<span class="number">0</span>].strip(),</span><br><span class="line">            <span class="string">'title'</span>:item[<span class="number">1</span>].strip(),</span><br><span class="line">            <span class="string">'actor'</span>:item[<span class="number">2</span>].strip(),</span><br><span class="line">            <span class="string">'time'</span>:item[<span class="number">3</span>].strip(),</span><br><span class="line">        &#125;</span><br><span class="line">        print(dic)</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    regex = <span class="string">r'&lt;dd&gt;.*?&lt;.*?class="board-index.*?&gt;(\d+)&lt;/i&gt;.*?title="(.*?)".*?class="movie-item-info".*?&lt;p class="star"&gt;(.*?)&lt;/p&gt;.*?&lt;p class="releasetime"&gt;(.*?)&lt;/p&gt;'</span></span><br><span class="line">    pattern1=re.compile(regex,re.S)</span><br><span class="line"></span><br><span class="line">    url_dic=&#123;</span><br><span class="line">        <span class="string">'http://maoyan.com/board/7'</span>:pattern1,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    p=Pool()</span><br><span class="line">    res_l=[]</span><br><span class="line">    <span class="keyword">for</span> url,pattern <span class="keyword">in</span> url_dic.items():</span><br><span class="line">        res=p.apply_async(get_page,args=(url,pattern),callback=parse_page)</span><br><span class="line">        res_l.append(res)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> res_l:</span><br><span class="line">        i.get()</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意：如果在主进程中等待进程池中所有任务都执行完毕后，再统一处理结果，则无需回调函数</strong> </p></blockquote>]]></content>
      
      <categories>
          
          <category> Python进程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 进程池 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Python进程间通信之队列</title>
      <link href="/post/58b02bea.html"/>
      <url>/post/58b02bea.html</url>
      <content type="html"><![CDATA[<h3 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h3><p>进程间通信有队列（multiprocess.Queue）和管道（multiprocess.Pipe），在这里只简单介绍队列</p><h4 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h4><h5 id="概念介绍"><a href="#概念介绍" class="headerlink" title="概念介绍"></a>概念介绍</h5><p>创建共享的进程队列，Queue是多进程安全的队列，可以使用Queue实现多进程之间的数据传递。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Queue([maxsize]) </span><br><span class="line">创建共享的进程队列。</span><br><span class="line">参数 ：maxsize是队列中允许的最大项数。如果省略此参数，则无大小限制。</span><br><span class="line">底层队列使用管道和锁定实现，另外，还需要运行支持线程以便队列中的数据传输到底层管道中</span><br></pre></td></tr></table></figure><p>方法介绍 ：</p><ul><li><p>q.get( [ block [ ,timeout ] ] ) </p><p>返回q中的一个项目。如果q为空，此方法将阻塞，直到队列中有项目可用为止。block用于控制阻塞行为，默认为True. 如果设置为False，将引发Queue.Empty异常（定义在Queue模块中）。timeout是可选超时时间，用在阻塞模式中。如果在制定的时间间隔内没有项目变为可用，将引发Queue.Empty异常。</p></li><li><p>q.get_nowait( ) </p><p>同q.get(False)方法。</p></li><li><p>q.put(item [, block [,timeout ] ] ) </p><p>将item放入队列。如果队列已满，此方法将阻塞至有空间可用为止。block控制阻塞行为，默认为True。如果设置为False，将引发Queue.Empty异常（定义在Queue库模块中）。timeout指定在阻塞模式中等待可用空间的时间长短。超时后将引发Queue.Full异常。</p></li><li><p>q.qsize() </p><p>返回队列中目前项目的正确数量。此函数的结果并不可靠，因为在返回结果和在稍后程序中使用结果之间，队列中可能添加或删除了项目。在某些系统上，此方法可能引发NotImplementedError异常。</p></li><li><p>q.empty() </p><p>如果调用此方法时 q为空，返回True。如果其他进程或线程正在往队列中添加项目，结果是不可靠的。也就是说，在返回和使用结果之间，队列中可能已经加入新的项目。</p></li><li><p>q.full() </p><p>如果q已满，返回为True. 由于线程的存在，结果也可能是不可靠的（参考q.empty（）方法）</p></li><li><p>q.close() </p><p>关闭队列，防止队列中加入更多数据。调用此方法时，后台线程将继续写入那些已入队列但尚未写入的数据，但将在此方法完成时马上关闭。如果q被垃圾收集，将自动调用此方法。关闭队列不会在队列使用者中生成任何类型的数据结束信号或异常。例如，如果某个使用者正被阻塞在get（）操作上，关闭生产者中的队列不会导致get（）方法返回错误。</p></li><li><p>q.cancel_join_thread() </p><p>不会再进程退出时自动连接后台线程。这可以防止join_thread()方法阻塞。</p></li><li><p>q.join_thread() </p><p>连接队列的后台线程。此方法用于在调用q.close()方法后，等待所有队列项被消耗。默认情况下，此方法由不是q的原始创建者的所有进程调用。调用q.cancel_join_thread()方法可以禁止这种行为。</p></li></ul><h5 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h5><ul><li><p>单看队列用法 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Queue</span><br><span class="line"></span><br><span class="line">q = Queue(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># put ,get ,put_nowait,get_nowait,full,empty</span></span><br><span class="line">q.put(<span class="number">3</span>)</span><br><span class="line">q.put(<span class="number">3</span>)</span><br><span class="line">q.put(<span class="number">3</span>)</span><br><span class="line"><span class="comment"># q.put(3)   # 如果队列已经满了，程序就会停在这里，等待数据被别人取走，再将数据放入队列。</span></span><br><span class="line"><span class="comment"># 如果队列中的数据一直不被取走，程序就会永远停在这里。</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    q.put_nowait(<span class="number">3</span>)  <span class="comment"># 可以使用put_nowait，如果队列满了不会阻塞，但是会因为队列满了而报错。</span></span><br><span class="line"><span class="keyword">except</span>:  <span class="comment"># 因此我们可以用一个try语句来处理这个错误。这样程序不会一直阻塞下去，但是会丢掉这个消息。</span></span><br><span class="line">    print(<span class="string">'队列已经满了'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 因此，我们再放入数据之前，可以先看一下队列的状态，如果已经满了，就不继续put了。</span></span><br><span class="line">print(q.full())  <span class="comment"># 满了</span></span><br><span class="line"></span><br><span class="line">print(q.get())</span><br><span class="line">print(q.get())</span><br><span class="line">print(q.get())</span><br><span class="line"><span class="comment"># print(q.get()) # 同put方法一样，如果队列已经空了，那么继续取就会出现阻塞。</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    q.get_nowait(<span class="number">3</span>)  <span class="comment"># 可以使用get_nowait，如果队列满了不会阻塞，但是会因为没取到值而报错。</span></span><br><span class="line"><span class="keyword">except</span>:  <span class="comment"># 因此我们可以用一个try语句来处理这个错误。这样程序不会一直阻塞下去。</span></span><br><span class="line">    print(<span class="string">'队列已经空了'</span>)</span><br><span class="line"></span><br><span class="line">print(q.empty())  <span class="comment"># 空了</span></span><br></pre></td></tr></table></figure></li></ul><p>上面这个例子还没有加入进程通信，只是先来看看队列为我们提供的方法，以及这些方法的使用和现象 </p><ul><li><p>子进程发送数据给父进程 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process, Queue</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(q)</span>:</span></span><br><span class="line">    q.put([time.asctime(), <span class="string">'from Eva'</span>, <span class="string">'hello'</span>])  <span class="comment"># 调用主函数中p进程传递过来的进程参数 put函数为向队列中添加一条数据。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    q = Queue()  <span class="comment"># 创建一个Queue对象</span></span><br><span class="line">    p = Process(target=func, args=(q,))  <span class="comment"># 创建一个进程</span></span><br><span class="line">    p.start()</span><br><span class="line">    print(q.get())</span><br><span class="line">    p.join()</span><br></pre></td></tr></table></figure></li></ul><p>上面是一个queue的简单应用，使用队列q对象调用get函数来取得队列中最先进入的数据 </p><ul><li><p>批量生产数据放入队列再批量获取结果 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process, Queue</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">consumer</span><span class="params">(q)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        res = q.get()</span><br><span class="line">        time.sleep(random.randint(<span class="number">1</span>, <span class="number">3</span>))</span><br><span class="line">        print(<span class="string">'%s 吃 %s'</span> % (os.getpid(), res))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">producer</span><span class="params">(q)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        time.sleep(random.randint(<span class="number">1</span>, <span class="number">3</span>))</span><br><span class="line">        res = <span class="string">'包子%s'</span> % i</span><br><span class="line">        q.put(res)</span><br><span class="line">        print(<span class="string">'%s 生产了 %s'</span> % (os.getpid(), res))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    q = Queue()</span><br><span class="line">    <span class="comment"># 生产者们:即厨师们</span></span><br><span class="line">    p1 = Process(target=producer, args=(q,))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 消费者们:即吃货们</span></span><br><span class="line">    c1 = Process(target=consumer, args=(q,))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 开始</span></span><br><span class="line">    p1.start()</span><br><span class="line">    c1.start()</span><br><span class="line">    print(<span class="string">'主'</span>)</span><br></pre></td></tr></table></figure><p><img src="..\img\process\20180629165826.png" alt=""></p></li></ul><p>问题来了，我们看结果主进程永远不会结束，原因是：生产者p在生产完后就结束了，但是消费者c在取空了q之后，则一直处于死循环中且卡在q.get()这一步。</p><p>在解决上面问题之前，这里引入一个<strong>生产者消费者模型</strong></p><h5 id="生产者消费者模型"><a href="#生产者消费者模型" class="headerlink" title="生产者消费者模型"></a>生产者消费者模型</h5><p><em>在并发编程中使用生产者和消费者模式能够解决绝大多数并发问题。该模式通过平衡生产线程和消费线程的工作能力来提高程序的整体处理数据的速度</em> </p><p><strong>为什么要使用生产者和消费者模式</strong></p><p><em>在线程世界里，生产者就是生产数据的线程，消费者就是消费数据的线程。在多线程开发当中，如果生产者处理速度很快，而消费者处理速度很慢，那么生产者就必须等待消费者处理完，才能继续生产数据。同样的道理，如果消费者的处理能力大于生产者，那么消费者就必须等待生产者。为了解决这个问题于是引入了生产者和消费者模式。</em></p><p><strong>什么是生产者消费者模式</strong></p><p><em>生产者消费者模式是通过一个容器来解决生产者和消费者的强耦合问题。生产者和消费者彼此之间不直接通讯，而通过阻塞队列来进行通讯，所以生产者生产完数据之后不用等待消费者处理，直接扔给阻塞队列，消费者不找生产者要数据，而是直接从阻塞队列里取，阻塞队列就相当于一个缓冲区，平衡了生产者和消费者的处理能力。</em></p><p>要解决上面产生的问题无非是让生产者在生产完毕后，往队列中再发一个结束信号，这样消费者在接收到结束信号后就可以break出死循环 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process, Queue</span><br><span class="line"><span class="keyword">import</span> time, random, os</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">consumer</span><span class="params">(q)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        res = q.get()</span><br><span class="line">        <span class="keyword">if</span> res <span class="keyword">is</span> <span class="keyword">None</span>: <span class="keyword">break</span>  <span class="comment"># 收到结束信号则结束</span></span><br><span class="line">        time.sleep(random.randint(<span class="number">1</span>, <span class="number">3</span>))</span><br><span class="line">        print(<span class="string">'%s 吃 %s'</span> % (os.getpid(), res))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">producer</span><span class="params">(q)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        time.sleep(random.randint(<span class="number">1</span>, <span class="number">3</span>))</span><br><span class="line">        res = <span class="string">'包子%s'</span> % i</span><br><span class="line">        q.put(res)</span><br><span class="line">        print(<span class="string">'%s 生产了 %s'</span> % (os.getpid(), res))</span><br><span class="line">    q.put(<span class="keyword">None</span>)  <span class="comment"># 发送结束信号</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    q = Queue()</span><br><span class="line">    <span class="comment"># 生产者们:即厨师们</span></span><br><span class="line">    p1 = Process(target=producer, args=(q,))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 消费者们:即吃货们</span></span><br><span class="line">    c1 = Process(target=consumer, args=(q,))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 开始</span></span><br><span class="line">    p1.start()</span><br><span class="line">    c1.start()</span><br><span class="line">    print(<span class="string">'主'</span>)</span><br></pre></td></tr></table></figure><blockquote><p>注意：结束信号None，不一定要由生产者发，主进程里同样可以发，但主进程需要等生产者结束后才应该发送该信号 </p></blockquote><p>下面再看看多个消费者的例子：有几个消费者就需要发送几次结束信号 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process, Queue</span><br><span class="line"><span class="keyword">import</span> time, random, os</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">consumer</span><span class="params">(q)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        res = q.get()</span><br><span class="line">        <span class="keyword">if</span> res <span class="keyword">is</span> <span class="keyword">None</span>: <span class="keyword">break</span>  <span class="comment"># 收到结束信号则结束</span></span><br><span class="line">        time.sleep(random.randint(<span class="number">1</span>, <span class="number">3</span>))</span><br><span class="line">        print(<span class="string">'%s 吃 %s'</span> % (os.getpid(), res))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">producer</span><span class="params">(name, q)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>):</span><br><span class="line">        time.sleep(random.randint(<span class="number">1</span>, <span class="number">3</span>))</span><br><span class="line">        res = <span class="string">'%s%s'</span> % (name, i)</span><br><span class="line">        q.put(res)</span><br><span class="line">        print(<span class="string">'%s 生产了 %s'</span> % (os.getpid(), res))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    q = Queue()</span><br><span class="line">    <span class="comment"># 生产者们:即厨师们</span></span><br><span class="line">    p1 = Process(target=producer, args=(<span class="string">'啤酒鸭'</span>, q))</span><br><span class="line">    p2 = Process(target=producer, args=(<span class="string">'烤鱼'</span>, q))</span><br><span class="line">    p3 = Process(target=producer, args=(<span class="string">'烧鸡'</span>, q))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 消费者们:即吃货们</span></span><br><span class="line">    c1 = Process(target=consumer, args=(q,))</span><br><span class="line">    c2 = Process(target=consumer, args=(q,))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 开始</span></span><br><span class="line">    p1.start()</span><br><span class="line">    p2.start()</span><br><span class="line">    p3.start()</span><br><span class="line">    c1.start()</span><br><span class="line">    c2.start()</span><br><span class="line"></span><br><span class="line">    p1.join()  <span class="comment"># 必须保证生产者全部生产完毕,才应该发送结束信号</span></span><br><span class="line">    p2.join()</span><br><span class="line">    p3.join()</span><br><span class="line">    q.put(<span class="keyword">None</span>)  <span class="comment"># 有几个消费者就应该发送几次结束信号None</span></span><br><span class="line">    q.put(<span class="keyword">None</span>)  <span class="comment"># 发送结束信号</span></span><br><span class="line">    print(<span class="string">'主'</span>)</span><br></pre></td></tr></table></figure><p>有没有发现上面的方法很low，有几个消费者就要发送几次结束信号，下面再优化一下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">JoinableQueue([maxsize])  </span><br><span class="line">创建可连接的共享进程队列，这就像是一个Queue对象，但队列允许项目的使用者通知生产者项目已经被成功处理。通知进程是使用共享的信号和条件变量来实现的。</span><br></pre></td></tr></table></figure><p>JoinableQueue的实例p除了与Queue对象相同的方法之外，还具有以下方法</p><p>方法介绍 ：</p><ul><li><p>q.task_done() </p><p>使用者使用此方法发出信号，表示q.get()返回的项目已经被处理。如果调用此方法的次数大于从队列中删除的项目数量，将引发ValueError异常。</p></li><li><p>q.join() </p><p>生产者将使用此方法进行阻塞，直到队列中所有项目均被处理。阻塞将持续到为队列中的每个项目均调用q.task_done()方法为止。 </p></li></ul><p>下面的例子说明如何建立永远运行的进程，使用和处理队列上的项目。生产者将项目放入队列，并等待它们被处理</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process, JoinableQueue</span><br><span class="line"><span class="keyword">import</span> time, random, os</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">consumer</span><span class="params">(q)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        res = q.get()</span><br><span class="line">        <span class="keyword">if</span> res <span class="keyword">is</span> <span class="keyword">None</span>: <span class="keyword">break</span>  <span class="comment"># 收到结束信号则结束</span></span><br><span class="line">        time.sleep(random.randint(<span class="number">1</span>, <span class="number">3</span>))</span><br><span class="line">        print(<span class="string">'%s 吃 %s'</span> % (os.getpid(), res))</span><br><span class="line">        q.task_done()  <span class="comment"># 向q.join()发送一次信号,证明一个数据已经被取走了</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">producer</span><span class="params">(name, q)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>):</span><br><span class="line">        time.sleep(random.randint(<span class="number">1</span>, <span class="number">3</span>))</span><br><span class="line">        res = <span class="string">'%s%s'</span> % (name, i)</span><br><span class="line">        q.put(res)</span><br><span class="line">        print(<span class="string">'%s 生产了 %s'</span> % (os.getpid(), res))</span><br><span class="line">    q.join()  <span class="comment"># 生产完毕，使用此方法进行阻塞，直到队列中所有项目均被处理</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    q = JoinableQueue()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 生产者们:即厨师们</span></span><br><span class="line">    p1 = Process(target=producer, args=(<span class="string">'啤酒鸭'</span>, q))</span><br><span class="line">    p2 = Process(target=producer, args=(<span class="string">'烤鱼'</span>, q))</span><br><span class="line">    p3 = Process(target=producer, args=(<span class="string">'烧鸡'</span>, q))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 消费者们:即吃货们</span></span><br><span class="line">    c1 = Process(target=consumer, args=(q,))</span><br><span class="line">    c2 = Process(target=consumer, args=(q,))</span><br><span class="line">    c1.daemon = <span class="keyword">True</span></span><br><span class="line">    c2.daemon = <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 开始</span></span><br><span class="line">    p_l = [p1, p2, p3, c1, c2]</span><br><span class="line">    <span class="keyword">for</span> p <span class="keyword">in</span> p_l:</span><br><span class="line">        p.start()</span><br><span class="line"></span><br><span class="line">    p1.join()  <span class="comment"># 必须保证生产者全部生产完毕,才应该发送结束信号</span></span><br><span class="line">    p2.join()</span><br><span class="line">    p3.join()</span><br><span class="line">    print(<span class="string">'主'</span>)</span><br><span class="line"><span class="comment"># p1,p2,p3结束了,证明c1,c2肯定全都收完了p1,p2,p3发到队列的数据</span></span><br><span class="line"><span class="comment"># 因而c1,c2也没有存在的价值了,不需要继续阻塞在进程中影响主进程了。应该随着主进程的结束而结束,所以设置成守护进程就可以了</span></span><br></pre></td></tr></table></figure><p>参考资料：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">http://www.cnblogs.com/Eva-J/articles/8253549.html</span><br><span class="line">http://www.cnblogs.com/linhaifeng/articles/6817679.html</span><br><span class="line">https://www.jianshu.com/p/1200fd49b583</span><br><span class="line">https://www.jianshu.com/p/aed6067eeac9</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Python进程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 进程通信 </tag>
            
            <tag> 队列 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Python进程同步之锁</title>
      <link href="/post/779a7de2.html"/>
      <url>/post/779a7de2.html</url>
      <content type="html"><![CDATA[<h3 id="锁-——-multiprocess-Lock"><a href="#锁-——-multiprocess-Lock" class="headerlink" title="锁 —— multiprocess.Lock"></a>锁 —— multiprocess.Lock</h3><p>通过刚刚的学习，我们千方百计实现了程序的异步，让多个任务可以同时在几个进程中并发处理，他们之间的运行没有顺序，一旦开启也不受我们控制。尽管并发编程让我们能更加充分的利用IO资源，但是也给我们带来了新的问题。</p><p>当多个进程使用同一份数据资源的时候，就会引发数据安全或顺序混乱问题。</p><p>接下来我们以模拟抢票为例，来看看数据安全的重要性。 </p><p>先看看不使用锁保护的多进程同时抢购余票结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 文件ticket的内容为：&#123;"count":1&#125;</span></span><br><span class="line"><span class="comment"># 注意一定要用双引号，不然json无法识别</span></span><br><span class="line"><span class="comment"># 并发运行，效率高，但竞争写同一文件，数据写入错乱</span></span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process, Lock</span><br><span class="line"><span class="keyword">import</span> time, json</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">()</span>:</span></span><br><span class="line">    dic = json.load(open(<span class="string">'ticket'</span>))</span><br><span class="line">    print(<span class="string">'\033[31m剩余票数%s\033[0m'</span> % dic[<span class="string">'count'</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(i)</span>:</span></span><br><span class="line">    dic = json.load(open(<span class="string">'ticket'</span>))</span><br><span class="line">    time.sleep(<span class="number">0.1</span>)  <span class="comment"># 模拟读数据的网络延迟</span></span><br><span class="line">    <span class="keyword">if</span> dic[<span class="string">'count'</span>] &gt; <span class="number">0</span>:</span><br><span class="line">        dic[<span class="string">'count'</span>] -= <span class="number">1</span></span><br><span class="line">        time.sleep(<span class="number">0.2</span>)  <span class="comment"># 模拟写数据的网络延迟</span></span><br><span class="line">        json.dump(dic, open(<span class="string">'ticket'</span>, <span class="string">'w'</span>))</span><br><span class="line">        print(<span class="string">'\033[32m用户%s购票成功\033[0m'</span> % i)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task</span><span class="params">(i)</span>:</span></span><br><span class="line">    search()</span><br><span class="line">    get(i)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):  <span class="comment"># 模拟并发10个客户端抢票</span></span><br><span class="line">        p = Process(target=task, args=(i,))</span><br><span class="line">        p.start()</span><br></pre></td></tr></table></figure><p>想想上面代码中会有什么样的结果出现？是只有一个用户购票成功，还是多个用户，下面一起来看看结果：</p><p><img src="..\img\process\20180629162519.png" alt=""></p><p>为什么会出现这样的情况呢？明明只有一张票，怎么会被这么多人购买成功，这个就是数据安全问题！！！</p><p>下面来解决这个数据安全问题：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 文件ticket的内容为：&#123;"count":1&#125;</span></span><br><span class="line"><span class="comment"># 注意一定要用双引号，不然json无法识别</span></span><br><span class="line"><span class="comment"># 并发运行，效率高，但竞争写同一文件，数据写入错乱</span></span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process, Lock</span><br><span class="line"><span class="keyword">import</span> time, json</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">()</span>:</span></span><br><span class="line">    dic = json.load(open(<span class="string">'ticket'</span>))</span><br><span class="line">    print(<span class="string">'\033[31m剩余票数%s\033[0m'</span> % dic[<span class="string">'count'</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(i)</span>:</span></span><br><span class="line">    dic = json.load(open(<span class="string">'ticket'</span>))</span><br><span class="line">    time.sleep(<span class="number">0.1</span>)  <span class="comment"># 模拟读数据的网络延迟</span></span><br><span class="line">    <span class="keyword">if</span> dic[<span class="string">'count'</span>] &gt; <span class="number">0</span>:</span><br><span class="line">        dic[<span class="string">'count'</span>] -= <span class="number">1</span></span><br><span class="line">        time.sleep(<span class="number">0.2</span>)  <span class="comment"># 模拟写数据的网络延迟</span></span><br><span class="line">        json.dump(dic, open(<span class="string">'ticket'</span>, <span class="string">'w'</span>))</span><br><span class="line">        print(<span class="string">'\033[32m用户%s购票成功\033[0m'</span> % i)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task</span><span class="params">(i, lock)</span>:</span></span><br><span class="line">    search()</span><br><span class="line">    lock.acquire()  <span class="comment"># 获取钥匙</span></span><br><span class="line">    get(i)  <span class="comment"># 有钥匙后进入方法执行代码</span></span><br><span class="line">    lock.release()  <span class="comment"># 归还钥匙</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    lock = Lock()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):  <span class="comment"># 模拟并发10个客户端抢票</span></span><br><span class="line">        p = Process(target=task, args=(i, lock))</span><br><span class="line">        p.start()</span><br></pre></td></tr></table></figure><p>结果：</p><p><img src="..\img\process\20180629163404.png" alt=""></p><blockquote><p>加锁可以保证多个进程修改同一块数据时，同一时间只能有一个任务可以进行修改，即串行的修改，没错，速度是慢了，但牺牲了速度却保证了数据安全。<br>虽然可以用文件共享数据实现进程间通信，但问题是：<br>1、效率低（共享数据基于文件，而文件是硬盘上的数据）<br>2、需要自己加锁处理</p><p>因此我们最好找寻一种解决方案能够兼顾：</p><p>1、效率高（多个进程共享一块内存的数据）</p><p>2、帮我们处理好锁问题。这就是mutiprocessing模块为我们提供的基于消息的IPC通信机制：队列和管道。<br>队列和管道都是将数据存放于内存中<br>队列又是基于（管道+锁）实现的，可以让我们从复杂的锁问题中解脱出来，<br>我们应该尽量避免使用共享数据，尽可能使用消息传递和队列，避免处理复杂的同步和锁问题，而且在进程数目增多时，往往可以获得更好的可获展性。</p></blockquote><p>参考资料：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">http://www.cnblogs.com/Eva-J/articles/8253549.html</span><br><span class="line">http://www.cnblogs.com/linhaifeng/articles/6817679.html</span><br><span class="line">https://www.jianshu.com/p/1200fd49b583</span><br><span class="line">https://www.jianshu.com/p/aed6067eeac9</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Python进程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 进程同步 </tag>
            
            <tag> 进程锁 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Python之进程</title>
      <link href="/post/d3c89889.html"/>
      <url>/post/d3c89889.html</url>
      <content type="html"><![CDATA[<h3 id="什么是进程"><a href="#什么是进程" class="headerlink" title="什么是进程"></a>什么是进程</h3><p>进程（Process）是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是<a href="https://baike.baidu.com/item/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F" target="_blank" rel="noopener">操作系统</a>结构的基础。在早期面向进程设计的计算机结构中，进程是程序的基本执行实体；在当代面向线程设计的计算机结构中，进程是线程的容器。程序是指令、数据及其组织形式的描述，进程是程序的实体。</p><p>狭义定义：进程是正在运行的程序的实例（an instance of a computer program that is being executed）。</p><p>广义定义：进程是一个具有一定独立功能的程序关于某个数据集合的一次运行活动。它是<a href="https://baike.baidu.com/item/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/192" target="_blank" rel="noopener">操作系统</a>动态执行的<a href="https://baike.baidu.com/item/%E5%9F%BA%E6%9C%AC%E5%8D%95%E5%85%83" target="_blank" rel="noopener">基本单元</a>，在传统的<a href="https://baike.baidu.com/item/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F" target="_blank" rel="noopener">操作系统</a>中，进程既是基本的<a href="https://baike.baidu.com/item/%E5%88%86%E9%85%8D%E5%8D%95%E5%85%83" target="_blank" rel="noopener">分配单元</a>，也是基本的执行单元。</p><h4 id="进程的概念"><a href="#进程的概念" class="headerlink" title="进程的概念"></a>进程的概念</h4><p>第一，进程是一个实体。每一个进程都有它自己的地址空间，一般情况下，包括文本区域（text region）、数据区域（data region）和堆栈（stack region）。文本区域存储处理器执行的代码；数据区域存储变量和进程执行期间使用的动态分配的内存；堆栈区域存储着活动过程调用的指令和本地变量。<br>第二，进程是一个“执行中的程序”。程序是一个没有生命的实体，只有处理器赋予程序生命时（操作系统执行之），它才能成为一个活动的实体，我们称其为进程。<br>进程是操作系统中最基本、重要的概念。是多道程序系统出现后，为了刻画系统内部出现的动态情况，描述系统内部各道程序的活动规律引进的一个概念,所有多道程序设计操作系统都建立在进程的基础上。</p><h4 id="进程的特征"><a href="#进程的特征" class="headerlink" title="进程的特征"></a>进程的特征</h4><p>动态性：进程的实质是程序在多道程序系统中的一次执行过程，进程是动态产生，动态消亡的。<br>并发性：任何进程都可以同其他进程一起并发执行<br>独立性：进程是一个能独立运行的基本单位，同时也是系统分配资源和调度的独立单位；<br>异步性：由于进程间的相互制约，使进程具有执行的间断性，即进程按各自独立的、不可预知的速度向前推进<br>结构特征：进程由程序、数据和进程控制块三部分组成。<br>多个不同的进程可以包含相同的程序：一个程序在不同的数据集里就构成不同的进程，能得到不同的结果；但是执行过程中，程序不能发生改变。</p><h4 id="进程与程序中的区别"><a href="#进程与程序中的区别" class="headerlink" title="进程与程序中的区别"></a>进程与程序中的区别</h4><p>程序是指令和数据的有序集合，其本身没有任何运行的含义，是一个静态的概念。<br>而进程是程序在处理机上的一次执行过程，它是一个动态的概念。<br>程序可以作为一种软件资料长期存在，而进程是有一定生命期的。<br>程序是永久的，进程是暂时的。</p><blockquote><p><strong>注意：同一个程序执行两次，就会在操作系统中出现两个进程，所以我们可以同时运行一个软件，分别做不同的事情也不会混乱。</strong> </p></blockquote><h3 id="进程的并行与并发"><a href="#进程的并行与并发" class="headerlink" title="进程的并行与并发"></a>进程的并行与并发</h3><p><strong>并行</strong> : 并行是指两者同时执行，比如赛跑，两个人都在不停的往前跑；（资源够用，比如三个线程，四核的CPU ）</p><p><strong>并发</strong> : 并发是指资源有限的情况下，两者交替轮流使用资源，比如一段路(单核CPU资源)同时只能过一个人，A走一段后，让给B，B用完继续给A ，交替使用，目的是提高效率。</p><p><strong>区别</strong>:</p><ul><li><strong>并行</strong>是从微观上，也就是在一个精确的时间片刻，有不同的程序在执行，这就要求必须有多个处理器。</li><li><strong>并发</strong>是从宏观上，在一个时间段上可以看出是同时执行的，比如一个服务器同时处理多个session。</li></ul><h3 id="同步异步阻塞非阻塞"><a href="#同步异步阻塞非阻塞" class="headerlink" title="同步异步阻塞非阻塞"></a>同步异步阻塞非阻塞</h3><h4 id="状态介绍"><a href="#状态介绍" class="headerlink" title="状态介绍"></a>状态介绍</h4><p><img src="..\img\process\1120359184.png" alt=""></p><p>​    在了解其他概念之前，我们首先要了解进程的几个状态。在程序运行的过程中，由于被操作系统的调度算法控制，程序会进入几个状态：就绪，运行和阻塞。</p><p>　　（1）就绪(Ready)状态</p><p>　　当进程已分配到除CPU以外的所有必要的资源，只要获得处理机便可立即执行，这时的进程状态称为就绪状态。</p><p>　　（2）执行/运行（Running）状态当进程已获得处理机，其程序正在处理机上执行，此时的进程状态称为执行状态。</p><p>　　（3）阻塞(Blocked)状态正在执行的进程，由于等待某个事件发生而无法执行时，便放弃处理机而处于阻塞状态。引起进程阻塞的事件可有多种，例如，等待I/O完成、申请缓冲区不能满足、等待信件(信号)等。</p><p><img src="..\img\process\135915799.png" alt=""></p><h4 id="同步和异步"><a href="#同步和异步" class="headerlink" title="同步和异步"></a>同步和异步</h4><p>​    所谓同步就是一个任务的完成需要依赖另外一个任务时，只有等待被依赖的任务完成后，依赖的任务才能算完成，这是一种可靠的任务序列。<strong>要么成功都成功，失败都失败，两个任务的状态可以保持一致。</strong></p><p>​    所谓异步是不需要等待被依赖的任务完成，只是通知被依赖的任务要完成什么工作，依赖的任务也立即执行，只要自己完成了整个任务就算完成了。<strong>至于被依赖的任务最终是否真正完成，依赖它的任务无法确定</strong>，所以它是不可靠的任务序列。</p><p>​    比如我去银行办理业务，可能会有两种方式：<br>        第一种 ：选择排队等候；<br>        第二种 ：选择取一个小纸条上面有我的号码，等到排到我这一号时由柜台的人通知我轮到我去办理业务了；</p><p>​        第一种：前者(排队等候)就是同步等待消息通知，也就是我要一直在等待银行办理业务情况；</p><p>​        第二种：后者(等待别人通知)就是异步等待消息通知。在异步消息处理中，等待消息通知者(在这个例子中就是等待办理业务的人)往往注册一个回调机制，在所等待的事件被触发时由触发机制(在这里是柜台的人)通过某种机制(在这里是写在小纸条上的号码，喊号)找到等待该事件的人。</p><h4 id="阻塞与非阻塞"><a href="#阻塞与非阻塞" class="headerlink" title="阻塞与非阻塞"></a>阻塞与非阻塞</h4><p>​    阻塞和非阻塞这两个概念与程序（线程）等待消息通知(无所谓同步或者异步)时的状态有关。也就是说阻塞与非阻塞主要是程序（线程）等待消息通知时的状态角度来说的 </p><p>​    继续上面的那个例子，不论是排队还是使用号码等待通知，如果在这个等待的过程中，等待者除了等待消息通知之外不能做其它的事情，那么该机制就是阻塞的，表现在程序中,也就是该程序一直阻塞在该函数调用处不能继续往下执行。<br>相反，有的人喜欢在银行办理这些业务的时候一边打打电话发发短信一边等待，这样的状态就是非阻塞的，因为他(等待者)没有阻塞在这个消息通知上，而是一边做自己的事情一边等待。</p><blockquote><p>注意：同步非阻塞形式实际上是效率低下的，想象一下你一边打着电话一边还需要抬头看到底队伍排到你了没有。如果把打电话和观察排队的位置看成是程序的两个操作的话，这个程序需要在这两种不同的行为之间来回的切换，效率可想而知是低下的；而异步非阻塞形式却没有这样的问题，因为打电话是你(等待者)的事情，而通知你则是柜台(消息触发机制)的事情，程序没有在两种不同的操作中来回切换。</p></blockquote><h4 id="同步-异步与阻塞-非阻塞"><a href="#同步-异步与阻塞-非阻塞" class="headerlink" title="同步/异步与阻塞/非阻塞"></a>同步/异步与阻塞/非阻塞</h4><h5 id="同步阻塞形式"><a href="#同步阻塞形式" class="headerlink" title="同步阻塞形式"></a>同步阻塞形式</h5><p>​    效率最低。拿上面的例子来说，就是你专心排队，什么别的事都不做。 </p><h5 id="异步阻塞形式"><a href="#异步阻塞形式" class="headerlink" title="异步阻塞形式"></a>异步阻塞形式</h5><p>​    如果在银行等待办理业务的人<code>采用的是异步的方式去等待消息被触发（通知）</code>，也就是领了一张小纸条，假如在这段时间里他不能离开银行做其它的事情，那么很显然，这个人被阻塞在了这个等待的操作上面； <strong>异步操作是可以被阻塞住的，只不过它不是在处理消息时阻塞，而是在等待消息通知时被阻塞。</strong> </p><h5 id="同步非阻塞形式"><a href="#同步非阻塞形式" class="headerlink" title="同步非阻塞形式"></a>同步非阻塞形式</h5><p>​    实际上是效率低下的。</p><p>​    想象一下你一边打着电话一边还需要抬头看到底队伍排到你了没有，如果把打电话和观察排队的位置看成是程序的两个操作的话，<code>这个程序需要在这两种不同的行为之间来回的切换</code>，效率可想而知是低下的。</p><h5 id="异步非阻塞形式"><a href="#异步非阻塞形式" class="headerlink" title="异步非阻塞形式"></a>异步非阻塞形式</h5><p>​    效率更高，因为打电话是你(等待者)的事情，而通知你则是柜台(消息触发机制)的事情，<code>程序没有在两种不同的操作中来回切换</code>。</p><p>​    比如说，这个人突然发觉自己烟瘾犯了，需要出去抽根烟，于是他告诉大堂经理说，排到我这个号码的时候麻烦到外面通知我一下，那么他就没有被阻塞在这个等待的操作上面，自然这个就是异步+非阻塞的方式了。</p><p>很多人会把同步和阻塞混淆，是<code>因为很多时候同步操作会以阻塞的形式表现出来</code>，同样的，很多人也会把异步和非阻塞混淆，<code>因为异步操作一般都不会在真正的IO操作处被阻塞</code>。 </p><p>下面来看看在python程序中的进程操作:</p><h3 id="在python程序中的进程操作"><a href="#在python程序中的进程操作" class="headerlink" title="在python程序中的进程操作"></a>在python程序中的进程操作</h3><p>之前已经了解了很多进程相关的理论知识，了解进程是什么应该不再困难了，刚刚我们已经了解了，运行中的程序就是一个进程。所有的进程都是通过它的父进程来创建的。因此，运行起来的python程序也是一个进程，那么我们也可以在程序中再创建进程。多个进程可以实现并发效果，也就是说，当我们的程序中存在多个进程的时候，在某些时候，就会让程序的执行速度变快。以我们之前所学的知识，并不能实现创建进程这个功能，所以我们就需要借助python中强大的模块。 </p><h4 id="multiprocess模块"><a href="#multiprocess模块" class="headerlink" title="multiprocess模块"></a>multiprocess模块</h4><p>仔细说来，multiprocess不是一个模块而是python中一个操作、管理进程的包。 之所以叫multi是取自multiple的多功能的意思,在这个包中几乎包含了和进程有关的所有子模块。由于提供的子模块非常多，为了方便大家归类记忆，我将这部分大致分为四个部分：创建进程部分，进程同步部分，进程池部分，进程之间数据共享。 </p><h4 id="multiprocess-process模块"><a href="#multiprocess-process模块" class="headerlink" title="multiprocess.process模块"></a>multiprocess.process模块</h4><h5 id="process模块介绍"><a href="#process模块介绍" class="headerlink" title="process模块介绍"></a>process模块介绍</h5><p>process模块是一个创建进程的模块，借助这个模块，就可以完成进程的创建。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Process([group [, target [, name [, args [, kwargs]]]]])，由该类实例化得到的对象，表示一个子进程中的任务（尚未启动）</span><br><span class="line"></span><br><span class="line">强调：</span><br><span class="line">1. 需要使用关键字的方式来指定参数</span><br><span class="line">2. args指定的为传给target函数的位置参数，是一个元组形式，必须有逗号</span><br><span class="line"></span><br><span class="line">参数介绍：</span><br><span class="line">1. group参数未使用，值始终为None</span><br><span class="line">2. target表示调用对象，即子进程要执行的任务</span><br><span class="line">3. args表示调用对象的位置参数元组，args=(1,2,&apos;egon&apos;,)</span><br><span class="line">4. kwargs表示调用对象的字典,kwargs=&#123;&apos;name&apos;:&apos;egon&apos;,&apos;age&apos;:18&#125;</span><br><span class="line">5. name为子进程的名称</span><br></pre></td></tr></table></figure><p>方法介绍 :</p><ul><li>p.start()：启动进程，并调用该子进程中的p.run() </li><li>p.run():进程启动时运行的方法，正是它去调用target指定的函数，我们自定义类的类中一定要实现该方法  </li><li>p.terminate():强制终止进程p，不会进行任何清理操作，如果p创建了子进程，该子进程就成了僵尸进程，使用该方法需要特别小心这种情况。如果p还保存了一个锁那么也将不会被释放，进而导致死锁</li><li>p.is_alive():如果p仍然运行，返回True</li><li>p.join([timeout]):主线程等待p终止（强调：是主线程处于等的状态，而p是处于运行的状态）。timeout是可选的超时时间，需要强调的是，p.join只能join住start开启的进程，而不能join住run开启的进程</li></ul><p>属性介绍 :</p><ul><li>p.daemon：默认值为False，如果设为True，代表p为后台运行的守护进程，当p的父进程终止时，p也随之终止，并且设定为True后，p不能创建自己的新进程，必须在p.start()之前设置</li><li>p.name:进程的名称</li><li>p.pid：进程的pid</li><li>p.exitcode:进程在运行时为None、如果为–N，表示被信号N结束(了解即可)</li><li>p.authkey:进程的身份验证键,默认是由os.urandom()随机生成的32字符的字符串。这个键的用途是为涉及网络连接的底层进程间通信提供安全性，这类连接只有在具有相同的身份验证键时才能成功（了解即可）</li></ul><h5 id="使用process模块创建进程"><a href="#使用process模块创建进程" class="headerlink" title="使用process模块创建进程"></a>使用process模块创建进程</h5><p>在一个python进程中开启子进程，start方法和并发效果。 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(args1, args2)</span>:</span></span><br><span class="line">    print(args1, args2)</span><br><span class="line">    time.sleep(<span class="number">3</span>)</span><br><span class="line">    print(<span class="string">'子进程 :'</span>, os.getpid())</span><br><span class="line">    print(<span class="string">'子进程的父进程 :'</span>, os.getppid())</span><br><span class="line">    print(<span class="number">12345</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    p = Process(target=func, args=(<span class="string">'参数1'</span>, <span class="string">'参数2'</span>))  <span class="comment"># 注册</span></span><br><span class="line">    <span class="comment"># p是一个进程对象,还没有启动进程</span></span><br><span class="line">    p.start()  <span class="comment"># 开启了一个子进程</span></span><br><span class="line">    <span class="comment"># p.join()  # 是感知一个子进程的结束,将异步的程序改为同步</span></span><br><span class="line">    print(<span class="string">'我是父进程'</span>)</span><br><span class="line">    print(<span class="string">'*'</span> * <span class="number">10</span>)</span><br><span class="line">    print(<span class="string">'父进程 :'</span>, os.getpid())  <span class="comment"># 查看当前进程的进程号</span></span><br><span class="line">    print(<span class="string">'父进程的父进程 :'</span>, os.getppid())  <span class="comment"># 查看当前进程的父进程</span></span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="..\img\process\20180628141032.png" alt=""></p><p>上面是单个进程，那么多个进程同时运行又是怎么样的呢？一起来看看：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(filename, content)</span>:</span></span><br><span class="line">    print(filename)</span><br><span class="line">    <span class="keyword">with</span> open(filename, <span class="string">'w'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(content * <span class="number">10</span> * <span class="string">'*'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    p_list = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        p = Process(target=func, args=(<span class="string">'info%s'</span> % i, <span class="number">0</span>))</span><br><span class="line">        p_list.append(p)</span><br><span class="line">        p.start()</span><br></pre></td></tr></table></figure><p>这里同时启动了10个进程，并创建10文件向文件中写入内容，它们同时在10个进程中并发处理，但是它们之间的运行没有顺序 </p><p>运行结果：</p><p><img src="..\img\process\20180628162043.png" alt=""></p><p>那我们又怎么写入内容后查看这10个文件呢？这里我们再次用到join方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(filename, content)</span>:</span></span><br><span class="line">    print(filename)</span><br><span class="line">    <span class="keyword">with</span> open(filename, <span class="string">'w'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(content * <span class="number">10</span> * <span class="string">'*'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    p_list = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        p = Process(target=func, args=(<span class="string">'info%s'</span> % i, <span class="number">0</span>))</span><br><span class="line">        p_list.append(p)</span><br><span class="line">        p.start()</span><br><span class="line">    [p.join() <span class="keyword">for</span> p <span class="keyword">in</span> p_list]  <span class="comment"># 之前的所有进程必须在这里都执行完才能执行下面的代码</span></span><br><span class="line">    print([i <span class="keyword">for</span> i <span class="keyword">in</span> os.walk(<span class="string">r'C:\GavinLiu\projects\my_process'</span>)])</span><br></pre></td></tr></table></figure><p>除了上面这些开启进程的方法，还有一种以继承Process类的形式开启进程的方式 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyProcess</span><span class="params">(Process)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, arg1, arg2)</span>:</span></span><br><span class="line">        super().__init__()</span><br><span class="line">        self.arg1 = arg1</span><br><span class="line">        self.arg2 = arg2</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(self.pid)</span><br><span class="line">        print(self.name)</span><br><span class="line">        print(self.arg1)</span><br><span class="line">        print(self.arg2)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    p1 = MyProcess(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">    p1.start()  <span class="comment"># start会自动调用run</span></span><br><span class="line">    p2 = MyProcess(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">    p2.start()</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="..\img\process\20180628163308.png" alt=""></p><p>进程之间的数据隔离问题 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> n  <span class="comment"># 声明了一个全局变量</span></span><br><span class="line">    n = <span class="number">0</span>  <span class="comment"># 重新定义了一个n</span></span><br><span class="line">    print(<span class="string">'子进程: %s'</span> % os.getpid(), n)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    n = <span class="number">100</span></span><br><span class="line">    p = Process(target=func)</span><br><span class="line">    p.start()</span><br><span class="line">    p.join()</span><br><span class="line">    print(<span class="string">'父进程: '</span>, os.getpid(), n)</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="..\img\process\20180628163825.png" alt=""></p><h5 id="守护进程"><a href="#守护进程" class="headerlink" title="守护进程"></a>守护进程</h5><p>主进程创建守护进程</p><p>　　其一：守护进程会在主进程代码执行结束后就终止</p><p>　　其二：守护进程内无法再开启子进程,否则抛出异常：AssertionError: daemonic processes are not allowed to have children</p><blockquote><p>注意：进程之间是互相独立的，主进程代码运行结束，守护进程随即终止</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Myprocess</span><span class="params">(Process)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, person)</span>:</span></span><br><span class="line">        super().__init__()</span><br><span class="line">        self.person = person</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(os.getpid(), self.name)</span><br><span class="line">        print(<span class="string">'%s正在和女主播聊天'</span> % self.person)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    p = Myprocess(<span class="string">'少林'</span>)</span><br><span class="line">    p.daemon = <span class="keyword">True</span>  <span class="comment"># 一定要在p.start()前设置,设置p为守护进程,禁止p创建子进程,并且父进程代码执行结束,p即终止运行</span></span><br><span class="line">    p.start()</span><br><span class="line">    time.sleep(<span class="number">10</span>)  <span class="comment"># 在sleep时查看进程id对应的进程ps -ef|grep id(linux下)</span></span><br><span class="line">    print(<span class="string">'主'</span>)</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="..\img\process\20180628170154.png" alt=""></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="number">123</span>)</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    print(<span class="string">"end123"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bar</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="number">456</span>)</span><br><span class="line">    time.sleep(<span class="number">3</span>)</span><br><span class="line">    print(<span class="string">"end456"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    p1 = Process(target=foo)</span><br><span class="line">    p2 = Process(target=bar)</span><br><span class="line"></span><br><span class="line">    p1.daemon = <span class="keyword">True</span></span><br><span class="line">    p1.start()</span><br><span class="line">    p2.start()</span><br><span class="line">    time.sleep(<span class="number">0.1</span>)</span><br><span class="line">    print(<span class="string">"main-------"</span>)  <span class="comment"># 打印该行则主进程代码结束,则守护进程p1应该被终止.#可能会有p1任务执行的打印信息123,因为主进程打印main----时,p1也执行了,但是随即被终止.</span></span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="..\img\process\20180628165703.png" alt=""></p><p><img src="..\img\process\20180628165719.png" alt=""></p><p>参考资料：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">http://www.cnblogs.com/Eva-J/articles/8253549.html</span><br><span class="line">http://www.cnblogs.com/linhaifeng/articles/6817679.html</span><br><span class="line">https://www.jianshu.com/p/1200fd49b583</span><br><span class="line">https://www.jianshu.com/p/aed6067eeac9</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Python进程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 进程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Django之中间件</title>
      <link href="/post/11a0df73.html"/>
      <url>/post/11a0df73.html</url>
      <content type="html"><![CDATA[<h1 id="Django中间件"><a href="#Django中间件" class="headerlink" title="Django中间件"></a>Django中间件</h1><h2 id="中间件介绍"><a href="#中间件介绍" class="headerlink" title="中间件介绍"></a>中间件介绍</h2><h3 id="什么是中间件"><a href="#什么是中间件" class="headerlink" title="什么是中间件?"></a>什么是中间件?</h3><p>官方的说法：中间件是一个用来处理Django的请求和响应的框架级别的钩子。它是一个轻量、低级别的插件系统，用于在全局范围内改变Django的输入和输出。每个中间件组件都负责做一些特定的功能。</p><p>但是由于其影响的是全局，所以需要谨慎使用，使用不当会影响性能。</p><p>说的直白一点中间件是帮助我们在视图函数执行之前和执行之后都可以做一些额外的操作，它本质上就是一个自定义类，类中定义了几个方法，Django框架会在请求的特定的时间去执行这些方法。</p><p>我们一直都在使用中间件，只是没有注意到而已，打开Django项目的settings.py文件，看到下图的MIDDLEWARE配置项。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">MIDDLEWARE = [</span><br><span class="line">    <span class="string">'django.middleware.security.SecurityMiddleware'</span>,</span><br><span class="line">    <span class="string">'django.contrib.sessions.middleware.SessionMiddleware'</span>,</span><br><span class="line">    <span class="string">'django.middleware.common.CommonMiddleware'</span>,</span><br><span class="line">    <span class="string">'django.middleware.csrf.CsrfViewMiddleware'</span>,</span><br><span class="line">    <span class="string">'django.contrib.auth.middleware.AuthenticationMiddleware'</span>,</span><br><span class="line">    <span class="string">'django.contrib.messages.middleware.MessageMiddleware'</span>,</span><br><span class="line">    <span class="string">'django.middleware.clickjacking.XFrameOptionsMiddleware'</span>,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>MIDDLEWARE配置项是一个列表，列表中是一个个字符串，这些字符串其实是一个个类，也就是一个个中间件。</p><p>我们之前已经接触过一个csrf相关的中间件了？我们一开始把他注释掉，再提交post请求的时候，就不会被forbidden了，后来学会使用csrf_token之后就不再注释这个中间件了。</p><p>那接下来就学习中间件中的方法以及这些方法什么时候被执行。</p><h2 id="自定义中间件"><a href="#自定义中间件" class="headerlink" title="自定义中间件"></a>自定义中间件</h2><p>中间件可以定义五个方法，分别是：（主要的是process_request和process_response）</p><ul><li>process_request(self,request)</li><li>process_view(self, request, view_func, view_args, view_kwargs)</li><li>process_template_response(self,request,response)</li><li>process_exception(self, request, exception)</li><li>process_response(self, request, response)</li></ul><p>以上方法的返回值可以是None或一个HttpResponse对象，如果是None，则继续按照django定义的规则向后继续执行，如果是HttpResponse对象，则直接将该对象返回给用户。</p><p>views.py中 :</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">(request)</span>:</span></span><br><span class="line">    print(<span class="string">'index视图'</span>)</span><br><span class="line">    <span class="keyword">return</span> HttpResponse(<span class="string">'OK'</span>)</span><br></pre></td></tr></table></figure><p>下面我们来一一说明中间件的五个方法:</p><h3 id="process-request"><a href="#process-request" class="headerlink" title="process_request"></a>process_request</h3><p>先来撸一段代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.utils.deprecation <span class="keyword">import</span> MiddlewareMixin</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MD1</span><span class="params">(MiddlewareMixin)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_request</span><span class="params">(self, request)</span>:</span></span><br><span class="line">        print(<span class="string">'MD1里面的 process_request'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MD2</span><span class="params">(MiddlewareMixin)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_request</span><span class="params">(self, request)</span>:</span></span><br><span class="line">        print(<span class="string">'MD2里面的 process_request'</span>)</span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>在settings.py的MIDDLEWARE配置项中注册上述两个自定义中间件： </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">MIDDLEWARE = [</span><br><span class="line">    <span class="string">'django.middleware.security.SecurityMiddleware'</span>,</span><br><span class="line">    <span class="string">'django.contrib.sessions.middleware.SessionMiddleware'</span>,</span><br><span class="line">    <span class="string">'django.middleware.common.CommonMiddleware'</span>,</span><br><span class="line">    <span class="string">'django.middleware.csrf.CsrfViewMiddleware'</span>,</span><br><span class="line">    <span class="string">'django.contrib.auth.middleware.AuthenticationMiddleware'</span>,</span><br><span class="line">    <span class="string">'django.contrib.messages.middleware.MessageMiddleware'</span>,</span><br><span class="line">    <span class="string">'django.middleware.clickjacking.XFrameOptionsMiddleware'</span>,</span><br><span class="line">    <span class="string">'middlewares.MD1'</span>,  <span class="comment"># 自定义中间件MD1</span></span><br><span class="line">    <span class="string">'middlewares.MD2'</span>  <span class="comment"># 自定义中间件MD2</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>完成以上操作后,我们运行一下项目并访问某个视图:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MD1里面的 process_request</span><br><span class="line">MD2里面的 process_request</span><br><span class="line">index视图</span><br></pre></td></tr></table></figure><p>再把MD1和MD2在settings.py中的位置调换一下，再访问一个视图，会发现终端中打印的内容如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MD2里面的 process_request</span><br><span class="line">MD1里面的 process_request</span><br><span class="line">index视图</span><br></pre></td></tr></table></figure><p>看结果我们知道：视图函数还是最后执行的，MD2比MD1先执行自己的process_request方法。</p><p>在打印一下两个自定义中间件中process_request方法中的request参数，会发现它们是同一个对象。</p><p>由此总结一下：</p><ol><li>中间件的process_request方法是在执行视图函数之前执行的。</li><li>当配置多个中间件时，会按照MIDDLEWARE中的注册顺序，也就是列表的索引值，从前到后依次执行的。（在settings.py里面设置中 从上到下的顺序）</li><li>不同中间件之间传递的request都是同一个对象</li><li>返回None，继续执行后续的中间件的process_request方法，返回response , 不执行后续的中间件的process_request方法</li></ol><h3 id="process-response"><a href="#process-response" class="headerlink" title="process_response"></a>process_response</h3><p>process_response 有两个参数，一个是request，一个是response，request就是上述例子中一样的对象，response是视图函数返回的HttpResponse对象。该方法的返回值也必须是HttpResponse对象。</p><p>给上述的MD1和MD2加上process_response方法： </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.utils.deprecation <span class="keyword">import</span> MiddlewareMixin</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MD1</span><span class="params">(MiddlewareMixin)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_request</span><span class="params">(self, request)</span>:</span></span><br><span class="line">        print(<span class="string">'MD1里面的 process_request'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_response</span><span class="params">(self, request, response)</span>:</span></span><br><span class="line">        print(<span class="string">'MD1里面的 process_response'</span>)</span><br><span class="line">        <span class="keyword">return</span> response</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MD2</span><span class="params">(MiddlewareMixin)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_request</span><span class="params">(self, request)</span>:</span></span><br><span class="line">        print(<span class="string">'MD2里面的 process_request'</span>)</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_response</span><span class="params">(self, request, response)</span>:</span></span><br><span class="line">        print(<span class="string">'MD2里面的 process_response'</span>)</span><br><span class="line">        <span class="keyword">return</span> response</span><br></pre></td></tr></table></figure><p> 访问一个视图，看一下终端的输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MD2里面的 process_request</span><br><span class="line">MD1里面的 process_request</span><br><span class="line">index视图</span><br><span class="line">MD1里面的 process_response</span><br><span class="line">MD2里面的 process_response</span><br></pre></td></tr></table></figure><p>看结果可知：process_response方法是在视图函数之后执行的，并且顺序是MD1比MD2先执行。(此时settings.py中 MD2比MD1先注册)</p><p>由此总结一下：</p><ol><li>多个中间件中的process_response方法是按照MIDDLEWARE中的注册顺序<strong>倒序</strong>执行的（在settings.py里面设置中 从下到上的顺序）</li><li>在请求有响应的时候执行process_response方法</li><li>该方法的返回值也必须是HttpResponse对象</li></ol><h3 id="process-view"><a href="#process-view" class="headerlink" title="process_view"></a>process_view</h3><p>process_view(self, request, view_func, view_args, view_kwargs)</p><p>该方法有四个参数</p><p>request是HttpRequest对象。</p><p>view_func是Django即将使用的视图函数。 （它是实际的函数对象，而不是函数的名称作为字符串。）</p><p>view_args是将传递给视图的位置参数的列表.</p><p>view_kwargs是将传递给视图的关键字参数的字典。 view_args和view_kwargs都不包含第一个视图参数（request）。</p><p>Django会在调用视图函数之前调用process_view方法。</p><p>它应该返回None或一个HttpResponse对象。 如果返回None，Django将继续处理这个请求，执行任何其他中间件的process_view方法，然后在执行相应的视图。 如果它返回一个HttpResponse对象，Django不会调用适当的视图函数。 它将执行中间件的process_response方法并将应用到该HttpResponse并返回结果。</p><p> 给MD1和MD2添加process_view方法:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.utils.deprecation <span class="keyword">import</span> MiddlewareMixin</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MD1</span><span class="params">(MiddlewareMixin)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_request</span><span class="params">(self, request)</span>:</span></span><br><span class="line">        print(<span class="string">'MD1里面的 process_request'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_response</span><span class="params">(self, request, response)</span>:</span></span><br><span class="line">        print(<span class="string">'MD1里面的 process_response'</span>)</span><br><span class="line">        <span class="keyword">return</span> response</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_view</span><span class="params">(self, request, view_func, view_args, view_kwargs)</span>:</span></span><br><span class="line">        print(<span class="string">'-'</span> * <span class="number">80</span>)</span><br><span class="line">        print(<span class="string">'MD1 中的process_view'</span>)</span><br><span class="line">        print(view_func, view_func.__name__)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MD2</span><span class="params">(MiddlewareMixin)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_request</span><span class="params">(self, request)</span>:</span></span><br><span class="line">        print(<span class="string">'MD2里面的 process_request'</span>)</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_response</span><span class="params">(self, request, response)</span>:</span></span><br><span class="line">        print(<span class="string">'MD2里面的 process_response'</span>)</span><br><span class="line">        <span class="keyword">return</span> response</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_view</span><span class="params">(self, request, view_func, view_args, view_kwargs)</span>:</span></span><br><span class="line">        print(<span class="string">'-'</span> * <span class="number">80</span>)</span><br><span class="line">        print(<span class="string">'MD2 中的process_view'</span>)</span><br><span class="line">        print(view_func, view_func.__name__)</span><br></pre></td></tr></table></figure><p>访问index视图函数，看一下输出结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">MD2里面的 process_request</span><br><span class="line">MD1里面的 process_request</span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line">MD2 中的process_view</span><br><span class="line">&lt;function index at 0x000001DE68317488&gt; index</span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line">MD1 中的process_view</span><br><span class="line">&lt;function index at 0x000001DE68317488&gt; index</span><br><span class="line">index视图</span><br><span class="line">MD1里面的 process_response</span><br><span class="line">MD2里面的 process_response</span><br></pre></td></tr></table></figure><p>process_view方法是在process_request之后，视图函数之前执行的，执行顺序按照MIDDLEWARE中的注册顺序<strong>从前到后顺序</strong>执行的，返回None，继续执行后续的中间件的process_view方法，返回response , 不执行后续的中间件的process_view方法。</p><h3 id="process-exception"><a href="#process-exception" class="headerlink" title="process_exception"></a>process_exception</h3><p>process_exception(self, request, exception)</p><p>该方法两个参数:</p><p>一个HttpRequest对象</p><p>一个exception是视图函数异常产生的Exception对象。</p><p>这个方法只有在视图函数中出现异常了才执行，它返回的值可以是一个None也可以是一个HttpResponse对象。如果是HttpResponse对象，Django将调用模板和中间件中的process_response方法，并返回给浏览器，否则将默认处理异常。如果返回一个None，则交给下一个中间件的process_exception方法来处理异常。它的执行顺序也是按照中间件注册顺序的<strong>倒序</strong>执行。</p><p> 给MD1和MD2添加上这个方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.utils.deprecation <span class="keyword">import</span> MiddlewareMixin</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MD1</span><span class="params">(MiddlewareMixin)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_request</span><span class="params">(self, request)</span>:</span></span><br><span class="line">        print(<span class="string">'MD1里面的 process_request'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_response</span><span class="params">(self, request, response)</span>:</span></span><br><span class="line">        print(<span class="string">'MD1里面的 process_response'</span>)</span><br><span class="line">        <span class="keyword">return</span> response</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_view</span><span class="params">(self, request, view_func, view_args, view_kwargs)</span>:</span></span><br><span class="line">        print(<span class="string">'-'</span> * <span class="number">80</span>)</span><br><span class="line">        print(<span class="string">'MD1 中的process_view'</span>)</span><br><span class="line">        print(view_func, view_func.__name__)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_exception</span><span class="params">(self, request, exception)</span>:</span></span><br><span class="line">        print(exception)</span><br><span class="line">        print(<span class="string">'MD1 中的process_exception'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MD2</span><span class="params">(MiddlewareMixin)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_request</span><span class="params">(self, request)</span>:</span></span><br><span class="line">        print(<span class="string">'MD2里面的 process_request'</span>)</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_response</span><span class="params">(self, request, response)</span>:</span></span><br><span class="line">        print(<span class="string">'MD2里面的 process_response'</span>)</span><br><span class="line">        <span class="keyword">return</span> response</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_view</span><span class="params">(self, request, view_func, view_args, view_kwargs)</span>:</span></span><br><span class="line">        print(<span class="string">'-'</span> * <span class="number">80</span>)</span><br><span class="line">        print(<span class="string">'MD2 中的process_view'</span>)</span><br><span class="line">        print(view_func, view_func.__name__)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_exception</span><span class="params">(self, request, exception)</span>:</span></span><br><span class="line">        print(exception)</span><br><span class="line">        print(<span class="string">'MD2 中的process_exception'</span>)</span><br></pre></td></tr></table></figure><p>如果视图函数中无异常，process_exception方法不执行。</p><p>想办法，在视图函数中抛出一个异常：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">(request)</span>:</span></span><br><span class="line">    print(<span class="string">'index视图'</span>)</span><br><span class="line">    <span class="keyword">raise</span> ValueError(<span class="string">'呵呵'</span>)</span><br><span class="line">    <span class="keyword">return</span> HttpResponse(<span class="string">'OK'</span>)</span><br></pre></td></tr></table></figure><p>在MD1的process_exception中返回一个响应对象：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MD1</span><span class="params">(MiddlewareMixin)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_request</span><span class="params">(self, request)</span>:</span></span><br><span class="line">        print(<span class="string">'MD1里面的 process_request'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_response</span><span class="params">(self, request, response)</span>:</span></span><br><span class="line">        print(<span class="string">'MD1里面的 process_response'</span>)</span><br><span class="line">        <span class="keyword">return</span> response</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_view</span><span class="params">(self, request, view_func, view_args, view_kwargs)</span>:</span></span><br><span class="line">        print(<span class="string">'-'</span> * <span class="number">80</span>)</span><br><span class="line">        print(<span class="string">'MD1 中的process_view'</span>)</span><br><span class="line">        print(view_func, view_func.__name__)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_exception</span><span class="params">(self, request, exception)</span>:</span></span><br><span class="line">        print(exception)</span><br><span class="line">        print(<span class="string">'MD1 中的process_exception'</span>)</span><br><span class="line">        <span class="keyword">return</span> HttpResponse(str(exception))  <span class="comment"># 返回一个响应对象</span></span><br></pre></td></tr></table></figure><p>看输出结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">MD2里面的 process_request</span><br><span class="line">MD1里面的 process_request</span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line">MD2 中的process_view</span><br><span class="line">&lt;function index at 0x0000022C09727488&gt; index</span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line">MD1 中的process_view</span><br><span class="line">&lt;function index at 0x0000022C09727488&gt; index</span><br><span class="line">index视图</span><br><span class="line">呵呵</span><br><span class="line">MD1 中的process_exception</span><br><span class="line">MD1里面的 process_response</span><br><span class="line">MD2里面的 process_response</span><br></pre></td></tr></table></figure><p>注意，这里并没有执行MD2的process_exception方法，因为MD1中的process_exception方法直接返回了一个响应对象。</p><h3 id="process-template-response"><a href="#process-template-response" class="headerlink" title="process_template_response"></a>process_template_response</h3><p>process_template_response(self, request, response)</p><p>它的参数，一个HttpRequest对象，response是TemplateResponse对象（由视图函数或者中间件产生）。</p><p>process_template_response是在视图函数执行完成后立即执行，但是它有一个前提条件，那就是视图函数返回的对象有一个render()方法（或者表明该对象是一个TemplateResponse对象或等价方法）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MD1</span><span class="params">(MiddlewareMixin)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_request</span><span class="params">(self, request)</span>:</span></span><br><span class="line">        print(<span class="string">'MD1里面的 process_request'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_response</span><span class="params">(self, request, response)</span>:</span></span><br><span class="line">        print(<span class="string">'MD1里面的 process_response'</span>)</span><br><span class="line">        <span class="keyword">return</span> response</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_view</span><span class="params">(self, request, view_func, view_args, view_kwargs)</span>:</span></span><br><span class="line">        print(<span class="string">'-'</span> * <span class="number">80</span>)</span><br><span class="line">        print(<span class="string">'MD1 中的process_view'</span>)</span><br><span class="line">        print(view_func, view_func.__name__)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_exception</span><span class="params">(self, request, exception)</span>:</span></span><br><span class="line">        print(exception)</span><br><span class="line">        print(<span class="string">'MD1 中的process_exception'</span>)</span><br><span class="line">        <span class="keyword">return</span> HttpResponse(str(exception))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_template_response</span><span class="params">(self, request, response)</span>:</span></span><br><span class="line">        print(<span class="string">'MD1 中的process_template_response'</span>)</span><br><span class="line">        <span class="keyword">return</span> response</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MD2</span><span class="params">(MiddlewareMixin)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_request</span><span class="params">(self, request)</span>:</span></span><br><span class="line">        print(<span class="string">'MD2里面的 process_request'</span>)</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_response</span><span class="params">(self, request, response)</span>:</span></span><br><span class="line">        print(<span class="string">'MD2里面的 process_response'</span>)</span><br><span class="line">        <span class="keyword">return</span> response</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_view</span><span class="params">(self, request, view_func, view_args, view_kwargs)</span>:</span></span><br><span class="line">        print(<span class="string">'-'</span> * <span class="number">80</span>)</span><br><span class="line">        print(<span class="string">'MD2 中的process_view'</span>)</span><br><span class="line">        print(view_func, view_func.__name__)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_exception</span><span class="params">(self, request, exception)</span>:</span></span><br><span class="line">        print(exception)</span><br><span class="line">        print(<span class="string">'MD2 中的process_exception'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_template_response</span><span class="params">(self, request, response)</span>:</span></span><br><span class="line">        print(<span class="string">'MD2 中的process_template_response'</span>)</span><br><span class="line">        <span class="keyword">return</span> response</span><br></pre></td></tr></table></figure><p>修改views.py中代码 :</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">(request)</span>:</span></span><br><span class="line">    print(<span class="string">'index视图'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">render</span><span class="params">()</span>:</span></span><br><span class="line">        print(<span class="string">'render'</span>)</span><br><span class="line">        <span class="keyword">return</span> HttpResponse(<span class="string">'render'</span>)</span><br><span class="line">    rep = HttpResponse(<span class="string">'OK'</span>)</span><br><span class="line">    rep.render = render</span><br><span class="line">    <span class="keyword">return</span> rep</span><br></pre></td></tr></table></figure><p>访问index视图，终端输出的结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">MD2里面的 process_request</span><br><span class="line">MD1里面的 process_request</span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line">MD2 中的process_view</span><br><span class="line">&lt;function index at 0x000001C111B97488&gt; index</span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line">MD1 中的process_view</span><br><span class="line">&lt;function index at 0x000001C111B97488&gt; index</span><br><span class="line">index视图</span><br><span class="line">MD1 中的process_template_response</span><br><span class="line">MD2 中的process_template_response</span><br><span class="line">render</span><br><span class="line">MD1里面的 process_response</span><br><span class="line">MD2里面的 process_response</span><br></pre></td></tr></table></figure><p>从结果看出：</p><p>视图函数执行完之后，立即执行了中间件的process_template_response方法，顺序是倒序，先执行MD1的，在执行MD2的，接着执行了视图函数返回的HttpResponse对象的render方法，返回了一个新的HttpResponse对象，接着执行中间件的process_response方法。</p><h2 id="中间件的执行流程"><a href="#中间件的执行流程" class="headerlink" title="中间件的执行流程"></a>中间件的执行流程</h2><p>上面我们一一了解了中间件中的5个方法，它们的参数、返回值以及什么时候执行，现在总结一下中间件的执行流程。 </p><p>请求到达中间件之后，先按照正序执行每个注册中间件的process_reques方法，process_request方法返回的值是None，就依次执行，如果返回的值是HttpResponse对象，不再执行后面的process_request方法，而是执行当前对应中间件的process_response方法，将HttpResponse对象返回给浏览器。也就是说：如果MIDDLEWARE中注册了6个中间件，执行过程中，第3个中间件返回了一个HttpResponse对象，那么第4,5,6中间件的process_request和process_response方法都不执行，顺序执行3,2,1中间件的process_response方法。</p><p><img src="..\img\django\middlewares1.png" alt="图一"> </p><p>process_request方法都执行完后，匹配路由，找到要执行的视图函数，先不执行视图函数，先执行中间件中的process_view方法，process_view方法返回None，继续按顺序执行，所有process_view方法执行完后执行视图函数。假如中间件3 的process_view方法返回了HttpResponse对象，则4,5,6的process_view以及视图函数都不执行，直接从最后一个中间件，也就是中间件6的process_response方法开始倒序执行。 </p><p><img src="..\img\django\867021-20180409214307195-1684061444.png" alt="图二"></p><p>process_template_response和process_exception两个方法的触发是有条件的，执行顺序也是倒序。总结所有的执行流程如下： </p><p><img src="..\img\django\286908304.png" alt="图三"></p><p><img src="..\img\django\2137571775.png" alt="图四"></p><h2 id="Django请求流程图"><a href="#Django请求流程图" class="headerlink" title="Django请求流程图"></a>Django请求流程图</h2><p><img src="..\img\django\196913305.png" alt="图五"></p>]]></content>
      
      <categories>
          
          <category> Django </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Django </tag>
            
            <tag> 中间件 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Django(二)之模型</title>
      <link href="/post/2116a065.html"/>
      <url>/post/2116a065.html</url>
      <content type="html"><![CDATA[<p>本文档使用Django 2.x，Django是一个基于MVC架构的Web框架，MVC架构要追求的是模型和视图的解耦合，而其中的模型说得更直白一些就是数据，所以通常也被称作数据模型。在实际的项目中，数据模型通常通过数据库实现持久化操作，而关系型数据库在很长一段时间都是持久化的首选方案，在我们的OA项目中，我们选择使用MySQL来实现数据持久化。</p><h3 id="配置关系型数据库MySQL"><a href="#配置关系型数据库MySQL" class="headerlink" title="配置关系型数据库MySQL"></a>配置关系型数据库MySQL</h3><ol><li><p>进入oa文件夹，修改项目的settings.py文件，首先将我们之前创建的应用hrs添加已安装的项目中，然后配置MySQL作为持久化方案。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">(venv)$</span><span class="bash"> <span class="built_in">cd</span> oa</span></span><br><span class="line"><span class="meta">(venv)$</span><span class="bash"> vim settings.py</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 此处省略上面的代码</span></span><br><span class="line"></span><br><span class="line">INSTALLED_APPS = [</span><br><span class="line">    <span class="string">'django.contrib.admin'</span>,</span><br><span class="line">    <span class="string">'django.contrib.auth'</span>,</span><br><span class="line">    <span class="string">'django.contrib.contenttypes'</span>,</span><br><span class="line">    <span class="string">'django.contrib.sessions'</span>,</span><br><span class="line">    <span class="string">'django.contrib.messages'</span>,</span><br><span class="line">    <span class="string">'django.contrib.staticfiles'</span>,</span><br><span class="line">    <span class="string">'hrs'</span>,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">DATABASES = &#123;</span><br><span class="line">    <span class="string">'default'</span>: &#123;</span><br><span class="line">        <span class="string">'ENGINE'</span>: <span class="string">'django.db.backends.mysql'</span>,</span><br><span class="line">        <span class="string">'NAME'</span>: <span class="string">'oa'</span>,</span><br><span class="line">        <span class="string">'HOST'</span>: <span class="string">'localhost'</span>,</span><br><span class="line">        <span class="string">'PORT'</span>: <span class="number">3306</span>,</span><br><span class="line">        <span class="string">'USER'</span>: <span class="string">'root'</span>,</span><br><span class="line">        <span class="string">'PASSWORD'</span>: <span class="string">'123456'</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 此处省略下面的代码</span></span><br></pre></td></tr></table></figure><p>在配置ENGINE属性时，常用的可选值包括：</p><ul><li><code>&#39;django.db.backends.sqlite3&#39;</code>：SQLite嵌入式数据库</li><li><code>&#39;django.db.backends.postgresql&#39;</code>：BSD许可证下发行的开源关系型数据库产品</li><li><code>&#39;django.db.backends.mysql&#39;</code>：转手多次目前属于甲骨文公司的经济高效的数据库产品</li><li><code>&#39;django.db.backends.oracle&#39;</code>：甲骨文公司的旗舰关系型数据库产品</li></ul><p>其他的配置可以参考官方文档中<a href="https://docs.djangoproject.com/zh-hans/2.0/ref/databases/#third-party-notes" target="_blank" rel="noopener">数据库配置</a>的部分。</p><p>NAME属性代表数据库的名称，如果使用SQLite它对应着一个文件，在这种情况下NAME的属性值应该是一个绝对路径。如果使用其他关系型数据库，还要配置对应的HOST（主机）、PORT（端口）、USER（用户名）、PASSWORD（口令）等属性。</p></li><li><p>安装MySQL客户端工具，Python 3中使用PyMySQL，Python 2中用MySQLdb。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">(venv)$</span><span class="bash"> pip install pymysql</span></span><br></pre></td></tr></table></figure><p>如果使用Python 3需要修改<strong>项目</strong>的<code>__init__.py</code>文件并加入如下所示的代码，这段代码的作用是将PyMySQL视为MySQLdb来使用，从而避免Django找不到连接MySQL的客户端工具而询问你：“Did you install mysqlclient? ”（你安装了mysqlclient吗？）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pymysql</span><br><span class="line"></span><br><span class="line">pymysql.install_as_MySQLdb()</span><br></pre></td></tr></table></figure></li><li><p>运行manage.py并指定migrate参数实现数据库迁移，为应用程序创建对应的数据表，当然在此之前需要<strong>先启动MySQL数据库服务器并创建名为oa的数据库</strong>，在MySQL中创建数据库的语句如下所示。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">database</span> <span class="keyword">if</span> <span class="keyword">exists</span> oa;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">database</span> oa <span class="keyword">default</span> <span class="keyword">charset</span> utf8;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">(venv)$</span><span class="bash"> <span class="built_in">cd</span> ..</span></span><br><span class="line"><span class="meta">(venv)$</span><span class="bash"> python manage.py migrate</span></span><br><span class="line">Operations to perform:</span><br><span class="line">  Apply all migrations: admin, auth, contenttypes, sessions</span><br><span class="line">Running migrations:</span><br><span class="line">  Applying contenttypes.0001_initial... OK</span><br><span class="line">  Applying auth.0001_initial... OK</span><br><span class="line">  Applying admin.0001_initial... OK</span><br><span class="line">  Applying admin.0002_logentry_remove_auto_add... OK</span><br><span class="line">  Applying contenttypes.0002_remove_content_type_name... OK</span><br><span class="line">  Applying auth.0002_alter_permission_name_max_length... OK</span><br><span class="line">  Applying auth.0003_alter_user_email_max_length... OK</span><br><span class="line">  Applying auth.0004_alter_user_username_opts... OK</span><br><span class="line">  Applying auth.0005_alter_user_last_login_null... OK</span><br><span class="line">  Applying auth.0006_require_contenttypes_0002... OK</span><br><span class="line">  Applying auth.0007_alter_validators_add_error_messages... OK</span><br><span class="line">  Applying auth.0008_alter_user_username_max_length... OK</span><br><span class="line">  Applying auth.0009_alter_user_last_name_max_length... OK</span><br><span class="line">  Applying sessions.0001_initial... OK</span><br></pre></td></tr></table></figure></li><li><p>可以看到，Django帮助我们创建了10张表，这些都是使用Django框架需要的东西，稍后我们就会用到这些表。除此之外，我们还应该为我们自己的应用创建数据模型。如果要在hrs应用中实现对部门和员工的管理，我们可以创建如下所示的数据模型。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">(venv)$</span><span class="bash"> <span class="built_in">cd</span> hrs</span></span><br><span class="line"><span class="meta">(venv)$</span><span class="bash"> vim models.py</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dept</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    <span class="string">"""部门类"""</span></span><br><span class="line">    </span><br><span class="line">    no = models.IntegerField(primary_key=<span class="keyword">True</span>, db_column=<span class="string">'dno'</span>, verbose_name=<span class="string">'部门编号'</span>)</span><br><span class="line">    name = models.CharField(max_length=<span class="number">20</span>, db_column=<span class="string">'dname'</span>, verbose_name=<span class="string">'部门名称'</span>)</span><br><span class="line">    location = models.CharField(max_length=<span class="number">10</span>, db_column=<span class="string">'dloc'</span>, verbose_name=<span class="string">'部门所在地'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        db_table = <span class="string">'tb_dept'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Emp</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    <span class="string">"""员工类"""</span></span><br><span class="line">    </span><br><span class="line">    no = models.IntegerField(primary_key=<span class="keyword">True</span>, db_column=<span class="string">'eno'</span>, verbose_name=<span class="string">'员工编号'</span>)</span><br><span class="line">    name = models.CharField(max_length=<span class="number">20</span>, db_column=<span class="string">'ename'</span>, verbose_name=<span class="string">'员工姓名'</span>)</span><br><span class="line">    job = models.CharField(max_length=<span class="number">10</span>, verbose_name=<span class="string">'职位'</span>)</span><br><span class="line">    <span class="comment"># 自参照完整性多对一外键关联</span></span><br><span class="line">    mgr = models.ForeignKey(<span class="string">'self'</span>, on_delete=models.SET_NULL, null=<span class="keyword">True</span>, blank=<span class="keyword">True</span>, verbose_name=<span class="string">'主管编号'</span>)</span><br><span class="line">    sal = models.DecimalField(max_digits=<span class="number">7</span>, decimal_places=<span class="number">2</span>, verbose_name=<span class="string">'月薪'</span>)</span><br><span class="line">    comm = models.DecimalField(max_digits=<span class="number">7</span>, decimal_places=<span class="number">2</span>, null=<span class="keyword">True</span>, blank=<span class="keyword">True</span>, verbose_name=<span class="string">'补贴'</span>)</span><br><span class="line">    dept = models.ForeignKey(Dept, db_column=<span class="string">'dno'</span>, on_delete=models.PROTECT, verbose_name=<span class="string">'所在部门'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        db_table = <span class="string">'tb_emp'</span></span><br></pre></td></tr></table></figure><blockquote><p>说明：上面定义模型时使用了字段类及其属性，其中IntegerField对应数据库中的integer类型，CharField对应数据库的varchar类型，DecimalField对应数据库的decimal类型，ForeignKey用来建立多对一外键关联。字段属性primary_key用于设置主键，max_length用来设置字段的最大长度，db_column用来设置数据库中与字段对应的列，verbose_name则设置了Django后台管理系统中该字段显示的名称。如果对这些东西感到很困惑也不要紧，文末提供了字段类、字段属性、元数据选项等设置的相关说明，不清楚的读者可以稍后查看对应的参考指南。</p></blockquote></li><li><p>通过模型创建数据表。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">(venv)$</span><span class="bash"> <span class="built_in">cd</span> ..</span></span><br><span class="line"><span class="meta">(venv)$</span><span class="bash"> python manage.py makemigrations hrs</span></span><br><span class="line">Migrations for 'hrs':</span><br><span class="line">  hrs/migrations/0001_initial.py</span><br><span class="line">    - Create model Dept</span><br><span class="line">    - Create model Emp</span><br><span class="line"><span class="meta">(venv)$</span><span class="bash"> python manage.py migrate</span></span><br><span class="line">Operations to perform:</span><br><span class="line">  Apply all migrations: admin, auth, contenttypes, hrs, sessions</span><br><span class="line">Running migrations:</span><br><span class="line">  Applying hrs.0001_initial... OK</span><br></pre></td></tr></table></figure><p>执行完数据迁移操作之后，可以在通过图形化的MySQL客户端工具查看到E-R图（实体关系图）。</p><p><img src="..\img\django\er-graph.png" alt=""></p></li></ol><h3 id="在后台管理模型"><a href="#在后台管理模型" class="headerlink" title="在后台管理模型"></a>在后台管理模型</h3><ol><li><p>创建超级管理员账号。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">(venv)$</span><span class="bash"> python manage.py createsuperuser</span></span><br><span class="line">Username (leave blank to use 'hao'): jackfrued</span><br><span class="line">Email address: jackfrued@126.com</span><br><span class="line">Password: </span><br><span class="line">Password (again): </span><br><span class="line">Superuser created successfully.</span><br></pre></td></tr></table></figure></li><li><p>启动Web服务器，登录后台管理系统。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">(venv)$</span><span class="bash"> python manage.py runserver</span></span><br></pre></td></tr></table></figure><p>访问<a href="http://127.0.0.1:8000/admin" target="_blank" rel="noopener">http://127.0.0.1:8000/admin</a>，会来到如下图所示的登录界面。</p><p><img src="..\img\django\admin-login.png" alt=""></p><p>登录后进入管理员操作平台。</p><p><img src="..\img\django\admin-welcome.png" alt=""></p><p>至此我们还没有看到之前创建的模型类，需要在应用的admin.py文件中模型进行注册。</p></li><li><p>注册模型类。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">(venv)$</span><span class="bash"> <span class="built_in">cd</span> hrs</span></span><br><span class="line"><span class="meta">(venv)$</span><span class="bash"> vim admin.py</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.contrib <span class="keyword">import</span> admin</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> hrs.models <span class="keyword">import</span> Emp, Dept</span><br><span class="line"></span><br><span class="line">admin.site.register(Dept)</span><br><span class="line">admin.site.register(Emp)</span><br></pre></td></tr></table></figure><p>注册模型类后，就可以在后台管理系统中看到它们。</p><p><img src="..\img\django\admin-model.png" alt=""></p></li><li><p>对模型进行CRUD操作。</p><p>可以在管理员平台对模型进行C（新增）R（查看）U（更新）D（删除）操作，如下图所示。</p><p>添加新的部门。</p><p><img src="..\img\django\admin-model-create-g.png" alt=""></p><p>查看所有部门。</p><p><img src="..\img\django\admin-model-read-g.png" alt=""></p><p>更新和删除部门。</p><p><img src="..\img\django\admin-model-delete-and-update.png" alt=""></p></li><li><p>注册模型管理类。</p><p>再次修改admin.py文件，通过注册模型管理类，可以在后台管理系统中更好的管理模型。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.contrib <span class="keyword">import</span> admin</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> hrs.models <span class="keyword">import</span> Emp, Dept</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DeptAdmin</span><span class="params">(admin.ModelAdmin)</span>:</span></span><br><span class="line"></span><br><span class="line">    list_display = (<span class="string">'no'</span>, <span class="string">'name'</span>, <span class="string">'location'</span>)</span><br><span class="line">    ordering = (<span class="string">'no'</span>, )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EmpAdmin</span><span class="params">(admin.ModelAdmin)</span>:</span></span><br><span class="line"></span><br><span class="line">    list_display = (<span class="string">'no'</span>, <span class="string">'name'</span>, <span class="string">'job'</span>, <span class="string">'mgr'</span>, <span class="string">'sal'</span>, <span class="string">'comm'</span>, <span class="string">'dept'</span>)</span><br><span class="line">    search_fields = (<span class="string">'name'</span>, <span class="string">'job'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">admin.site.register(Dept, DeptAdmin)</span><br><span class="line">admin.site.register(Emp, EmpAdmin)</span><br></pre></td></tr></table></figure><p><img src="..\img\django\admin-model-depts.png" alt=""></p><p><img src="..\img\django\admin-model-emps.png" alt=""></p><p>为了更好的查看模型数据，可以为Dept和Emp两个模型类添加<code>__str__</code>魔法方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dept</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    <span class="string">"""部门类"""</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 此处省略上面的代码</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.name</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 此处省略下面的代码</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Emp</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    <span class="string">"""员工类"""</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 此处省略上面的代码</span></span><br><span class="line">    </span><br><span class="line">    mgr = models.ForeignKey(<span class="string">'self'</span>, on_delete=models.SET_NULL, null=<span class="keyword">True</span>, blank=<span class="keyword">True</span>, verbose_name=<span class="string">'直接主管'</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 此处省略下面的代码</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 此处省略上面的代码</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.name</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 此处省略下面的代码</span></span><br></pre></td></tr></table></figure><p>修改代码后刷新查看Emp模型的页面，效果如下图所示。</p><p><img src="..\img\django\admin-model-emps-modified.png" alt=""></p></li></ol><h3 id="使用ORM完成模型的CRUD操作"><a href="#使用ORM完成模型的CRUD操作" class="headerlink" title="使用ORM完成模型的CRUD操作"></a>使用ORM完成模型的CRUD操作</h3><p>在了解了Django提供的模型管理平台之后，我们来看看如何从代码层面完成对模型的CRUD（Create / Read / Update / Delete）操作。我们可以通过manage.py开启Shell交互式环境，然后使用Django内置的ORM框架对模型进行CRUD操作。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">(venv)$</span><span class="bash"> <span class="built_in">cd</span> ..</span></span><br><span class="line"><span class="meta">(venv)$</span><span class="bash"> python manage.py shell</span></span><br><span class="line">Python 3.6.4 (v3.6.4:d48ecebad5, Dec 18 2017, 21:07:28) </span><br><span class="line">[GCC 4.2.1 (Apple Inc. build 5666) (dot 3)] on darwin</span><br><span class="line">Type "help", "copyright", "credits" or "license" for more information.</span><br><span class="line">(InteractiveConsole)</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt;</span></span><br></pre></td></tr></table></figure><h4 id="新增"><a href="#新增" class="headerlink" title="新增"></a>新增</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt;</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; from hrs.models import Dept, Emp</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; dept = Dept(40, <span class="string">'研发2部'</span>, <span class="string">'深圳'</span>)</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; dept.save()</span></span><br></pre></td></tr></table></figure><h4 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt;</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; dept.name = <span class="string">'研发3部'</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; dept.save()</span></span><br></pre></td></tr></table></figure><h4 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h4><p>查询所有对象。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt;</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; Dept.objects.all()</span></span><br><span class="line">&lt;QuerySet [&lt;Dept: 研发1部&gt;, &lt;Dept: 销售1部&gt;, &lt;Dept: 运维1部&gt;, &lt;Dept: 研发3部&gt;]&gt;</span><br></pre></td></tr></table></figure><p>过滤数据。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; </span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; Dept.objects.filter(name=<span class="string">'研发3部'</span>) <span class="comment"># 查询部门名称为“研发3部”的部门</span></span></span><br><span class="line">&lt;QuerySet [&lt;Dept: 研发3部&gt;]&gt;</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt;</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; Dept.objects.filter(name__contains=<span class="string">'研发'</span>) <span class="comment"># 查询部门名称包含“研发”的部门(模糊查询)</span></span></span><br><span class="line">&lt;QuerySet [&lt;Dept: 研发1部&gt;, &lt;Dept: 研发3部&gt;]&gt;</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt;</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; Dept.objects.filter(no__gt=10).filter(no__lt=40) <span class="comment"># 查询部门编号大于10小于40的部门</span></span></span><br><span class="line">&lt;QuerySet [&lt;Dept: 销售1部&gt;, &lt;Dept: 运维1部&gt;]&gt;</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt;</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; Dept.objects.filter(no__range=(10, 30)) <span class="comment"># 查询部门编号在10到30之间的部门</span></span></span><br><span class="line">&lt;QuerySet [&lt;Dept: 研发1部&gt;, &lt;Dept: 销售1部&gt;, &lt;Dept: 运维1部&gt;]&gt;</span><br></pre></td></tr></table></figure><p>查询单个对象。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; </span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; Dept.objects.get(pk=10)</span></span><br><span class="line">&lt;Dept: 研发1部&gt;</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt;</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; Dept.objects.get(no=20)</span></span><br><span class="line">&lt;Dept: 销售1部&gt;</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt;</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; Dept.objects.get(no__exact=30)</span></span><br><span class="line">&lt;Dept: 运维1部&gt;</span><br></pre></td></tr></table></figure><p>排序数据。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt;</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; Dept.objects.order_by(<span class="string">'no'</span>) <span class="comment"># 查询所有部门按部门编号升序排列</span></span></span><br><span class="line">&lt;QuerySet [&lt;Dept: 研发1部&gt;, &lt;Dept: 销售1部&gt;, &lt;Dept: 运维1部&gt;, &lt;Dept: 研发3部&gt;]&gt;</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt;</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; Dept.objects.order_by(<span class="string">'-no'</span>) <span class="comment"># 查询所有部门按部门编号降序排列</span></span></span><br><span class="line">&lt;QuerySet [&lt;Dept: 研发3部&gt;, &lt;Dept: 运维1部&gt;, &lt;Dept: 销售1部&gt;, &lt;Dept: 研发1部&gt;]&gt;</span><br></pre></td></tr></table></figure><p>切片数据。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt;</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; Dept.objects.order_by(<span class="string">'no'</span>)[0:2] <span class="comment"># 按部门编号排序查询1~2部门</span></span></span><br><span class="line">&lt;QuerySet [&lt;Dept: 研发1部&gt;, &lt;Dept: 销售1部&gt;]&gt;</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt;</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; Dept.objects.order_by(<span class="string">'no'</span>)[2:4] <span class="comment"># 按部门编号排序查询3~4部门</span></span></span><br><span class="line">&lt;QuerySet [&lt;Dept: 运维1部&gt;, &lt;Dept: 研发3部&gt;]&gt;</span><br></pre></td></tr></table></figure><p>高级查询。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt;</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; Emp.objects.filter(dept__no=10) <span class="comment"># 根据部门编号查询该部门的员工</span></span></span><br><span class="line">&lt;QuerySet [&lt;Emp: 乔峰&gt;, &lt;Emp: 张无忌&gt;, &lt;Emp: 张三丰&gt;]&gt;</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt;</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; Emp.objects.filter(dept__name__contains=<span class="string">'销售'</span>) <span class="comment"># 查询名字包含“销售”的部门的员工</span></span></span><br><span class="line">&lt;QuerySet [&lt;Emp: 黄蓉&gt;]&gt;</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt;</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; Dept.objects.get(pk=10).emp_set.all() <span class="comment"># 通过部门反查部门所有的员工</span></span></span><br><span class="line">&lt;QuerySet [&lt;Emp: 乔峰&gt;, &lt;Emp: 张无忌&gt;, &lt;Emp: 张三丰&gt;]&gt;</span><br></pre></td></tr></table></figure><blockquote><p>说明1：由于员工与部门之间存在多对一外键关联，所以也能通过部门反向查询该部门的员工（从一对多关系中“一”的一方查询“多”的一方），反向查询属性默认的名字是<code>类名小写_set</code>（如上面例子中的<code>emp_set</code>），当然也可以在创建模型时通过<code>ForeingKey</code>的<code>related_name</code>属性指定反向查询属性的名字。如果不希望执行反向查询可以将<code>related_name</code>属性设置为<code>&#39;+&#39;</code>或以<code>&#39;+&#39;</code>开头的字符串。</p><p>说明2：查询多个对象的时候返回的是QuerySet对象，QuerySet使用了惰性查询，即在创建QuerySet对象的过程中不涉及任何数据库活动，等真正用到对象时（求值QuerySet）才向数据库发送SQL语句并获取对应的结果，这一点在实际开发中需要引起注意！</p><p>说明3：可以在QuerySet上使用<code>update()</code>方法一次更新多个对象。</p></blockquote><h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt;</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; Dept.objects.get(pk=40).delete()</span></span><br><span class="line">(1, &#123;'hrs.Dept': 1&#125;)</span><br></pre></td></tr></table></figure><h3 id="Django模型最佳实践"><a href="#Django模型最佳实践" class="headerlink" title="Django模型最佳实践"></a>Django模型最佳实践</h3><ol><li>正确的模型命名和关系字段命名。</li><li>设置适当的<code>related_name</code>属性。</li><li>用<code>OneToOneField</code>代替<code>ForeignKeyField(unique=True)</code>。</li><li>通过“迁移操作”（migrate）来添加模型。</li><li>用NoSQL来应对需要降低范式级别的场景。</li><li>如果布尔类型可以为空要使用<code>NullBooleanField</code>。</li><li>在模型中放置业务逻辑。</li><li>用<code>&lt;ModelName&gt;.DoesNotExists</code>取代<code>ObjectDoesNotExists</code>。</li><li>在数据库中不要出现无效数据。</li><li>不要对<code>QuerySet</code>调用<code>len()</code>函数。</li><li>将<code>QuerySet</code>的<code>exists()</code>方法的返回值用于<code>if</code>条件。</li><li>用<code>DecimalField</code>来存储货币相关数据而不是<code>FloatField</code>。</li><li>定义<code>__str__</code>方法。</li><li>不要将数据文件放在同一个目录中。</li></ol><blockquote><p>说明：以上内容来自于STEELKIWI网站的<a href="https://steelkiwi.com/blog/best-practices-working-django-models-python/" target="_blank" rel="noopener"><em>Best Practice working with Django models in Python</em></a>，有兴趣的小伙伴可以阅读原文。</p></blockquote><h3 id="模型定义参考"><a href="#模型定义参考" class="headerlink" title="模型定义参考"></a>模型定义参考</h3><h4 id="字段"><a href="#字段" class="headerlink" title="字段"></a>字段</h4><p>对字段名称的限制</p><ul><li>字段名不能是Python的保留字，否则会导致语法错误</li><li>字段名不能有多个连续下划线，否则影响ORM查询操作</li></ul><p>Django模型字段类</p><table><thead><tr><th>字段类</th><th>说明</th></tr></thead><tbody><tr><td>AutoField</td><td>自增ID字段</td></tr><tr><td>BigIntegerField</td><td>64位有符号整数</td></tr><tr><td>BinaryField</td><td>存储二进制数据的字段，对应Python的bytes类型</td></tr><tr><td>BooleanField</td><td>存储True或False</td></tr><tr><td>CharField</td><td>长度较小的字符串</td></tr><tr><td>DateField</td><td>存储日期，有auto_now和auto_now_add属性</td></tr><tr><td>DateTimeField</td><td>存储日期和日期，两个附加属性同上</td></tr><tr><td>DecimalField</td><td>存储固定精度小数，有max_digits（有效位数）和decimal_places（小数点后面）两个必要的参数</td></tr><tr><td>DurationField</td><td>存储时间跨度</td></tr><tr><td>EmailField</td><td>与CharField相同，可以用EmailValidator验证</td></tr><tr><td>FileField</td><td>文件上传字段</td></tr><tr><td>FloatField</td><td>存储浮点数</td></tr><tr><td>ImageField</td><td>其他同FileFiled，要验证上传的是不是有效图像</td></tr><tr><td>IntegerField</td><td>存储32位有符号整数。</td></tr><tr><td>GenericIPAddressField</td><td>存储IPv4或IPv6地址</td></tr><tr><td>NullBooleanField</td><td>存储True、False或null值</td></tr><tr><td>PositiveIntegerField</td><td>存储无符号整数（只能存储正数）</td></tr><tr><td>SlugField</td><td>存储slug（简短标注）</td></tr><tr><td>SmallIntegerField</td><td>存储16位有符号整数</td></tr><tr><td>TextField</td><td>存储数据量较大的文本</td></tr><tr><td>TimeField</td><td>存储时间</td></tr><tr><td>URLField</td><td>存储URL的CharField</td></tr><tr><td>UUIDField</td><td>存储全局唯一标识符</td></tr></tbody></table><h4 id="字段属性"><a href="#字段属性" class="headerlink" title="字段属性"></a>字段属性</h4><p>通用字段属性</p><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>null</td><td>数据库中对应的字段是否允许为NULL，默认为False</td></tr><tr><td>blank</td><td>后台模型管理验证数据时，是否允许为NULL，默认为False</td></tr><tr><td>choices</td><td>设定字段的选项，各元组中的第一个值是设置在模型上的值，第二值是人类可读的值</td></tr><tr><td>db_column</td><td>字段对应到数据库表中的列名，未指定时直接使用字段的名称</td></tr><tr><td>db_index</td><td>设置为True时将在该字段创建索引</td></tr><tr><td>db_tablespace</td><td>为有索引的字段设置使用的表空间，默认为DEFAULT_INDEX_TABLESPACE</td></tr><tr><td>default</td><td>字段的默认值</td></tr><tr><td>editable</td><td>字段在后台模型管理或ModelForm中是否显示，默认为True</td></tr><tr><td>error_messages</td><td>设定字段抛出异常时的默认消息的字典，其中的键包括null、blank、invalid、invalid_choice、unique和unique_for_date</td></tr><tr><td>help_text</td><td>表单小组件旁边显示的额外的帮助文本。</td></tr><tr><td>primary_key</td><td>将字段指定为模型的主键，未指定时会自动添加AutoField用于主键，只读。</td></tr><tr><td>unique</td><td>设置为True时，表中字段的值必须是唯一的</td></tr><tr><td>verbose_name</td><td>字段在后台模型管理显示的名称，未指定时使用字段的名称</td></tr></tbody></table><p>ForeignKey属性</p><ol><li>limit_choices_to：值是一个Q对象或返回一个Q对象，用于限制后台显示哪些对象。</li><li>related_name：用于获取关联对象的关联管理器对象（反向查询），如果不允许反向，该属性应该被设置为<code>&#39;+&#39;</code>，或者以<code>&#39;+&#39;</code>结尾。</li><li>to_field：指定关联的字段，默认关联对象的主键字段。</li><li>db_constraint：是否为外键创建约束，默认值为True。</li><li>on_delete：外键关联的对象被删除时对应的动作，可取的值包括django.db.models中定义的：<ul><li>CASCADE：级联删除。</li><li>PROTECT：抛出ProtectedError异常，阻止删除引用的对象。</li><li>SET_NULL：把外键设置为null，当null属性被设置为True时才能这么做。</li><li>SET_DEFAULT：把外键设置为默认值，提供了默认值才能这么做。</li></ul></li></ol><p>ManyToManyField属性</p><ol><li>symmetrical：是否建立对称的多对多关系。</li><li>through：指定维持多对多关系的中间表的Django模型。</li><li>throughfields：定义了中间模型时可以指定建立多对多关系的字段。</li><li>db_table：指定维持多对多关系的中间表的表名。</li></ol><h4 id="模型元数据选项"><a href="#模型元数据选项" class="headerlink" title="模型元数据选项"></a>模型元数据选项</h4><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>abstract</td><td>设置为True时模型是抽象父类</td></tr><tr><td>app_label</td><td>如果定义模型的应用不在INSTALLED_APPS中可以用该属性指定</td></tr><tr><td>db_table</td><td>模型使用的数据表名称</td></tr><tr><td>db_tablespace</td><td>模型使用的数据表空间</td></tr><tr><td>default_related_name</td><td>关联对象回指这个模型时默认使用的名称，默认为<model_name>_set</model_name></td></tr><tr><td>get_latest_by</td><td>模型中可排序字段的名称。</td></tr><tr><td>managed</td><td>设置为True时，Django在迁移中创建数据表并在执行flush管理命令时把表移除</td></tr><tr><td>order_with_respect_to</td><td>标记对象为可排序的</td></tr><tr><td>ordering</td><td>对象的默认排序</td></tr><tr><td>permissions</td><td>创建对象时写入权限表的额外权限</td></tr><tr><td>default_permissions</td><td>默认为<code>(&#39;add&#39;, &#39;change&#39;, &#39;delete&#39;)</code></td></tr><tr><td>unique_together</td><td>设定组合在一起时必须独一无二的字段名</td></tr><tr><td>index_together</td><td>设定一起建立索引的多个字段名</td></tr><tr><td>verbose_name</td><td>为对象设定人类可读的名称</td></tr><tr><td>verbose_name_plural</td><td>设定对象的复数名称</td></tr></tbody></table><h3 id="查询参考"><a href="#查询参考" class="headerlink" title="查询参考"></a>查询参考</h3><p>按字段查找可以用的条件：</p><ol><li>exact / iexact：精确匹配/忽略大小写的精确匹配查询</li><li>contains / icontains / startswith / istartswith / endswith / iendswith：基于<code>like</code>的模糊查询</li><li>in：集合运算</li><li>gt / gte / lt / lte：大于/大于等于/小于/小于等于关系运算</li><li>range：指定范围查询（SQL中的<code>between…and…</code>）</li><li>year / month / day / week_day / hour / minute / second：查询时间日期</li><li>isnull：查询空值（True）或非空值（False）</li><li>search：基于全文索引的全文检索</li><li>regex / iregex：基于正则表达式的模糊匹配查询</li></ol><p>Q对象（用于执行复杂查询）的使用：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt;</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; from django.db.models import Q</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; Emp.objects.filter(</span></span><br><span class="line">...     Q(name__startswith='张'),</span><br><span class="line">...     Q(sal__gte=5000) | Q(comm__gte=1000)</span><br><span class="line">... ) # 查询名字以“张”开头 工资大于等于5000或补贴大于等于1000的员工</span><br><span class="line">&lt;QuerySet [&lt;Emp: 张三丰&gt;]&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Django </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Django </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Django(一)</title>
      <link href="/post/e8c9ba97.html"/>
      <url>/post/e8c9ba97.html</url>
      <content type="html"><![CDATA[<p>编写自己的第一个Django应用                                                                                                                                           </p><blockquote><p>创建项目</p></blockquote><ul><li>Windows环境下</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">### Windows环境下</span></span><br><span class="line"><span class="comment"># 创建根目录也就是你项目的容器</span></span><br><span class="line">$ mkdir mysite</span><br><span class="line"><span class="comment"># 切换到根目录</span></span><br><span class="line">$ <span class="built_in">cd</span> mysite/</span><br><span class="line"><span class="comment"># 建虚拟环境</span></span><br><span class="line">$ python -m venv venv</span><br><span class="line"><span class="comment"># 进入Scripts目录</span></span><br><span class="line">$ <span class="built_in">cd</span> venv</span><br><span class="line">$ <span class="built_in">cd</span> Scripts</span><br><span class="line"><span class="comment"># 激活环境</span></span><br><span class="line">$ activate</span><br><span class="line"><span class="comment"># 在虚拟环境下安装django依赖库</span></span><br><span class="line">(venv)$ pip install django</span><br><span class="line"><span class="comment"># 查看django版本</span></span><br><span class="line">(venv)$ django-admin --version</span><br><span class="line"><span class="comment"># 切换到根目录</span></span><br><span class="line">(venv)$ <span class="built_in">cd</span> ../..</span><br><span class="line"><span class="comment"># 创建项目</span></span><br><span class="line">(venv)$ django-admin startproject mysite .</span><br></pre></td></tr></table></figure><ul><li>Linux和macOS 环境</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## Linux和macOS 环境</span></span><br><span class="line"><span class="comment"># 创建项目文件夹</span></span><br><span class="line">$ mkdir mysite</span><br><span class="line"><span class="comment"># 切换到项目目录</span></span><br><span class="line">$ <span class="built_in">cd</span> mysite/</span><br><span class="line"><span class="comment"># 使用venv模块创建虚拟环境，目录名venv</span></span><br><span class="line">$ python3 -m venv venv</span><br><span class="line"><span class="comment"># 激活虚拟环境</span></span><br><span class="line">$ <span class="built_in">source</span> venv/bin/activate</span><br><span class="line"><span class="comment"># 更新pip到最新版本</span></span><br><span class="line">(venv)$ python -m pip install --upgrade pip</span><br><span class="line"><span class="comment"># 使用pip安装django</span></span><br><span class="line">(venv)$ pip install django</span><br><span class="line"><span class="comment"># 通过安装django时安装的脚本工具django-admin检查django版本</span></span><br><span class="line">(venv)$ django-admin --version</span><br><span class="line"><span class="comment"># 开启新项目</span></span><br><span class="line">(venv)$ django-admin startproject mysite .</span><br></pre></td></tr></table></figure><p>好了到现在为止,我们已经创建好了自己的一个Django项目,让我们看看 <a href="https://docs.djangoproject.com/zh-hans/2.0/ref/django-admin/#django-admin-startproject" target="_blank" rel="noopener">startproject</a> 创建了些什么:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysite/</span><br><span class="line">    manage.py</span><br><span class="line">    mysite/</span><br><span class="line">        __init__.py</span><br><span class="line">        settings.py</span><br><span class="line">        urls.py</span><br><span class="line">        wsgi.py</span><br></pre></td></tr></table></figure><p>下面我们简单的介绍上面每个文件是什么有什么作用</p><ul><li><code>manage.py</code>:用各种方式管理 Django 项目的命令行工具</li><li><code>__init__.py</code>:一个空文件，告诉 Python 这个目录应该被认为是一个 Python 包</li><li><code>settings.py</code>:整个Django 项目的配置文件</li><li><code>urls.py</code>:就像是地图,负责把URL模式映射到应用程序</li><li><code>wsgi.py</code>:用于项目部署</li></ul><blockquote><p>启动服务器</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(venv)$ python manage.py runserver</span><br></pre></td></tr></table></figure><p>你刚刚启动的是 Django 自带的用于开发的简易服务器，它是一个用纯 Python 写的轻量级的 Web 服务器。</p><p>现在我们用浏览器访问以下<a href="https://127.0.0.1:8000/" target="_blank" rel="noopener">https://127.0.0.1:8000/</a>，如果看到了小火箭那么恭喜你已经成功访问项目</p><p>Django默认端口是8000，如果你想更换服务器的监听端口，那么请运行<code>python manage.py runserver 8080</code>,如果你想在本地访问你服务器上的项目那么你需要执行<code>python manage.py runserver 0:8000</code>,<code>python manage.py runserver 0.0.0.0:8000</code>,这里的<strong>0</strong>相当于<strong>0.0.0.0</strong></p><blockquote><p>创建应用</p></blockquote><p>一个项目下我们可以有多个应用,现在我们来创建自己的第一个应用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(venv)$ python manage.py startapp hrs</span><br></pre></td></tr></table></figure><p>下面我们来看看<code>startapp</code>命令创建了些什么:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">hrs/</span><br><span class="line">    __init__.py</span><br><span class="line">    admin.py</span><br><span class="line">    apps.py</span><br><span class="line">    migrations/</span><br><span class="line">        __init__.py</span><br><span class="line">    models.py</span><br><span class="line">    tests.py</span><br><span class="line">    views.py</span><br></pre></td></tr></table></figure><ul><li><code>__init__.py</code>: 一个空文件,告诉Python这个目录应该被认为是一个包</li><li><code>admin.py</code>: 可以用来注册模型,让Django自动创建管理界面</li><li><code>apps.py</code>: 当前应用的配置</li><li><code>migrations</code>: 存放与模型有关的数据库信息<ul><li><code>__init__.py</code>: 也是一个空文件,告诉Python这个目录应该被认为是一个包</li></ul></li><li><code>models.py</code>:存放应用的数据模型,即实体类及其之间的关系(MVC/MVT中的M)</li><li><code>tests.py</code>: 测试应用的各种测试函数</li><li><code>views.py</code>: 处理请求并返回响应的函数(MVC中的C,MVT中的V)</li></ul><blockquote><p>创建一个视图</p></blockquote><p>hrs/views.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.http <span class="keyword">import</span> HttpResponse</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">home</span><span class="params">(request)</span>:</span>    </span><br><span class="line"><span class="keyword">return</span> HttpResponse(<span class="string">'&lt;h1&gt;Hello, Django!&lt;/h1&gt;'</span>)</span><br></pre></td></tr></table></figure><p>完成后,到项目目录,修改该目录下的urls.py文件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.contrib <span class="keyword">import</span> admin</span><br><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path</span><br><span class="line"><span class="keyword">from</span> hrs <span class="keyword">import</span> views</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">'hrs/'</span>, views.home),</span><br><span class="line">    path(<span class="string">'admin/'</span>, admin.site.urls),</span><br><span class="line">]</span><br></pre></td></tr></table></figure><blockquote><p>注意:我们还可以为应用单独建立一个urls.py文件来映射请求的URL,如下面:</p></blockquote><p>在hrs引用下创建一个urls.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path</span><br><span class="line"><span class="keyword">from</span> hrs <span class="keyword">import</span> views</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">''</span>, views.home, name=<span class="string">'index'</span>),</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>那么相应的我们在项目的urls.py文件中应当做出改变:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.contrib <span class="keyword">import</span> admin</span><br><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path, include</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">'hrs/'</span>, include(<span class="string">'hrs.urls'</span>)),</span><br><span class="line">    path(<span class="string">'admin/'</span>, admin.site.urls),</span><br><span class="line">]</span><br></pre></td></tr></table></figure><blockquote><p>使用视图模板</p></blockquote><p>在manage.py所在的同级目录下创建一个templates文件夹</p><p>接下来便是创建一个个模板页面,在这里我创建一个index.html模板页面</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;&#123; greeting &#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123; current_time &#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line">    今天为你推荐&#123;&#123; num &#125;&#125;种水果:</span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">        &#123;% for fruit in fruits %&#125;</span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span>&#123;&#123; fruit &#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        &#123;% endfor %&#125;</span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>要使用模板我们要改相应的配置,切换到配置文件目录找到setting.py文件</p><p>我们需要修改<code>TEMPLATES</code>的配置,代码如下所示:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">TEMPLATES = [</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">'BACKEND'</span>: <span class="string">'django.template.backends.django.DjangoTemplates'</span>,</span><br><span class="line">        <span class="string">'DIRS'</span>: [os.path.join(BASE_DIR, <span class="string">'templates'</span>)],  <span class="comment"># 将DIRS路径配置成模板页面所在的路径</span></span><br><span class="line">        <span class="string">'APP_DIRS'</span>: <span class="keyword">True</span>,</span><br><span class="line">        <span class="string">'OPTIONS'</span>: &#123;</span><br><span class="line">            <span class="string">'context_processors'</span>: [</span><br><span class="line">                <span class="string">'django.template.context_processors.debug'</span>,</span><br><span class="line">                <span class="string">'django.template.context_processors.request'</span>,</span><br><span class="line">                <span class="string">'django.contrib.auth.context_processors.auth'</span>,</span><br><span class="line">                <span class="string">'django.contrib.messages.context_processors.messages'</span>,</span><br><span class="line">            ],</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>要渲染模板我们需要在views.py中传递参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> randrange</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> render</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">home</span><span class="params">(req)</span>:</span></span><br><span class="line">    fruit = [<span class="string">'大苹果'</span>, <span class="string">'水晶葡萄'</span>, <span class="string">'大西瓜'</span>, <span class="string">'石榴'</span>, <span class="string">'桃子'</span>, <span class="string">'李子'</span>, <span class="string">'梨子'</span>]</span><br><span class="line">    len_f = randrange(<span class="number">1</span>, len(fruit))</span><br><span class="line">    fruits = set()</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> range(len_f):</span><br><span class="line">        index = randrange(<span class="number">0</span>, len(fruit))</span><br><span class="line">        fruits.add(fruit[index])</span><br><span class="line"></span><br><span class="line">    ctx = &#123;</span><br><span class="line">        <span class="string">'greeting'</span>: <span class="string">'你好,世界'</span>,</span><br><span class="line">        <span class="string">'current_time'</span>: datetime.now,</span><br><span class="line">        <span class="string">'num'</span>: len(fruits),</span><br><span class="line">        <span class="string">'fruits'</span>: fruits,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> render(req, <span class="string">'index.html'</span>, ctx)</span><br></pre></td></tr></table></figure><p>到这里我们完成了一个简单的Django项目,现在我们将项目重新运行查看一下结果</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(venv)$ python manage.py runserver 0:8000</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Django </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Django </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Python3.x 连接MySQL数据库</title>
      <link href="/post/64b3833f.html"/>
      <url>/post/64b3833f.html</url>
      <content type="html"><![CDATA[<h3 id="Python3-x-连接MySQL数据库"><a href="#Python3-x-连接MySQL数据库" class="headerlink" title="Python3.x 连接MySQL数据库"></a>Python3.x 连接MySQL数据库</h3><p>由于 MySQLdb 模块还不支持 Python3.x，所以 Python3.x 如果想连接MySQL需要安装 pymysql 模块。</p><p>pymysql 模块可以通过 pip 安装<code>pip install PyMySQL</code></p><blockquote><p>用pymysql连接数据库</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">conn = pymysql.connect(host=<span class="string">'localhost'</span>,</span><br><span class="line">                           port=<span class="number">3306</span>,</span><br><span class="line">                           user=<span class="string">'root'</span>,</span><br><span class="line">                           password=<span class="string">'root'</span>,</span><br><span class="line">                           db=<span class="string">'hrs'</span>,</span><br><span class="line">                           charset=<span class="string">'utf8'</span>,</span><br><span class="line">                           autocommit=<span class="keyword">False</span>  <span class="comment"># 默认不自动提交</span></span><br><span class="line">                           )</span><br></pre></td></tr></table></figure><ul><li><p>常用参数说明:</p><p>​<code>host</code>:主机IP</p><p>​<code>port</code>:端口号</p><p>​<code>user</code>:mysql登录用户名</p><p>​<code>password</code>:mysql登录密码</p><p>​<code>db</code>:数据库名称</p><p>​<code>charset</code>:连接数据库采用的字符编码</p><p><code>autocommit</code>:默认值是False,DML(数据操纵语言)不会自动提交,如果为True则会自动提交</p><p><code>cursorclass</code>:pymysql.cursors.DictCursor - 设置游标的类型,查询返回的结果是以字典的方式</p></li><li><p>测试是否连接成功</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(conn)</span><br><span class="line">$ &lt;pymysql.connections.Connection object at <span class="number">0x05656EB0</span>&gt;</span><br></pre></td></tr></table></figure></li></ul><p>如果运行上面的语句不报错,并且看到了输出到控制台的值,那么我们则用pymysql连接上了MySQL数据库.</p><blockquote><p>方法介绍</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">connection对象常用的方法</span><br><span class="line">cursor()        使用该连接创建并返回游标</span><br><span class="line">commit()        提交当前事务</span><br><span class="line">rollback()      回滚当前事务</span><br><span class="line">close()         关闭连接</span><br><span class="line"></span><br><span class="line">cursor对象常用的方法和属性</span><br><span class="line">execute(sql)    执行一个数据库的查询命令</span><br><span class="line">fetchone()      取得结果集的下一行</span><br><span class="line">fetchmany(size) 获取结果集的下几行</span><br><span class="line">fetchall()      获取结果集中的所有行</span><br><span class="line">rowcount      返回数据条数或影响行数</span><br><span class="line">close()         关闭游标对象</span><br></pre></td></tr></table></figure><p>在介绍上面方法使用前再看看连接数据库的代码块,其中有一个很重要的参数<strong>db</strong> (数据库名称),所以我们应当在连接数据库之前，先创建一个数据库，方便测试 pymysql 的功能</p><blockquote><p>使用Python实现增删改查和事务处理</p></blockquote><p>首先我们在上面说的<code>hrs</code>数据库中创建一张部门表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建部门表</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> tbdept</span><br><span class="line">(</span><br><span class="line">dno <span class="built_in">int</span>,<span class="comment">-- 部门编号</span></span><br><span class="line">dname <span class="built_in">varchar</span>(<span class="number">10</span>) <span class="keyword">not</span> <span class="literal">null</span>,  <span class="comment">-- 部门名称</span></span><br><span class="line">dloc <span class="built_in">varchar</span>(<span class="number">20</span>) <span class="keyword">not</span> <span class="literal">null</span>,  <span class="comment">-- 部门所在地</span></span><br><span class="line">primary <span class="keyword">key</span> (dno)</span><br><span class="line">);</span><br><span class="line"><span class="comment">-- 添加部门记录</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tbdept <span class="keyword">values</span> </span><br><span class="line">(<span class="number">10</span>, <span class="string">'会计部'</span>, <span class="string">'北京'</span>),</span><br><span class="line">(<span class="number">20</span>, <span class="string">'研发部'</span>, <span class="string">'成都'</span>),</span><br><span class="line">(<span class="number">30</span>, <span class="string">'销售部'</span>, <span class="string">'重庆'</span>),</span><br><span class="line">(<span class="number">40</span>, <span class="string">'运维部'</span>, <span class="string">'深圳'</span>);</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_conn</span><span class="params">()</span>:</span></span><br><span class="line">    config = &#123;</span><br><span class="line">        <span class="string">'host'</span>: <span class="string">'localhost'</span>,</span><br><span class="line">        <span class="string">'port'</span>: <span class="number">3306</span>,</span><br><span class="line">        <span class="string">'user'</span>: <span class="string">'root'</span>,</span><br><span class="line">        <span class="string">'password'</span>: <span class="string">'root'</span>,</span><br><span class="line">        <span class="string">'db'</span>: <span class="string">'hrs'</span>,</span><br><span class="line">        <span class="string">'charset'</span>: <span class="string">'utf8'</span>,</span><br><span class="line">        <span class="string">'autocommit'</span>: <span class="keyword">False</span>,  <span class="comment"># 默认不自动提交</span></span><br><span class="line">        <span class="string">'cursorclass'</span>: pymysql.cursors.DictCursor  <span class="comment"># 设置游标的类型,查询返回的结果是以字典的方式</span></span><br><span class="line">    &#125;</span><br><span class="line">    conn = pymysql.connect(**config)</span><br><span class="line">    <span class="keyword">return</span> conn</span><br></pre></td></tr></table></figure><ul><li><p>下面我们先来看看添加的操作:</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insert</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    插入</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="comment"># Connection(连接) / Cursor(游标)</span></span><br><span class="line">    conn = get_conn()</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># 创建Cursor对象,cursor支持上下文语法,可以放在with中</span></span><br><span class="line">        <span class="keyword">with</span> conn.cursor() <span class="keyword">as</span> cursor:</span><br><span class="line">            <span class="comment"># 向数据库发出sql语句</span></span><br><span class="line">            dno = input(<span class="string">'部门编号:'</span>)</span><br><span class="line">            dname = input(<span class="string">'部门名称:'</span>)</span><br><span class="line">            dloc = input(<span class="string">'部门地址:'</span>)</span><br><span class="line">            <span class="comment"># 如果使用字符串格式化的方式来组装SQL语句</span></span><br><span class="line">            <span class="comment"># 最大的风险是用被SQL注射攻击</span></span><br><span class="line">            <span class="comment"># sql = "insert into tbdept values (%d, '%s', '%s')" % (dno, dname, dloc)</span></span><br><span class="line">            <span class="comment"># result = cursor.execute(sql)</span></span><br><span class="line">            <span class="comment"># result = cursor.execute('insert into tbdept values (%s, %s, %s)', (dno, dname, dloc))</span></span><br><span class="line">            <span class="comment"># 这个方式传参是以字典的方式,但是要注意的是在占位的时候用%(name)s</span></span><br><span class="line">            result = cursor.execute(</span><br><span class="line">                <span class="string">'insert into tbdept values (%(dno)s, %(dname)s, %(dloc)s)'</span>,</span><br><span class="line">                &#123;<span class="string">'dno'</span>: dno, <span class="string">'dname'</span>: dname, <span class="string">'dloc'</span>: dloc&#125;</span><br><span class="line">            )</span><br><span class="line">            <span class="comment"># print('成功插入', cursor.rowcount, '条数据') # 这里cursor.rowcount是获取到受影响的行</span></span><br><span class="line">            print(<span class="string">'成功插入'</span>, result, <span class="string">'条数据'</span>)</span><br><span class="line">            conn.commit()</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        conn.close()</span><br></pre></td></tr></table></figure></li><li><p>修改操作</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">update</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    修改</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    conn = get_conn()</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">with</span> conn.cursor() <span class="keyword">as</span> cursor:</span><br><span class="line">            dno = input(<span class="string">'部门编号:'</span>)</span><br><span class="line">            dname = input(<span class="string">'部门名称:'</span>)</span><br><span class="line">            <span class="comment"># 这个方式传参是以字典的方式,但是要注意的是在占位的时候用%(name)s</span></span><br><span class="line">            result = cursor.execute(</span><br><span class="line">                <span class="string">'update tbdept set dname=%(dname)s where dno=%(dno)s'</span>,</span><br><span class="line">                &#123;<span class="string">'dno'</span>: dno, <span class="string">'dname'</span>: dname&#125;</span><br><span class="line">            )</span><br><span class="line">            <span class="comment"># print('成功插入', cursor.rowcount, '条数据') # 这里cursor.rowcount是获取到受影响的行</span></span><br><span class="line">            print(<span class="string">'成功修改'</span>, result, <span class="string">'条数据'</span>)</span><br><span class="line">            conn.commit()</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        conn.close()</span><br></pre></td></tr></table></figure></li><li><p>删除操作</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span><span class="params">(dno)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    根据编号删除</span></span><br><span class="line"><span class="string">    :param dno: 编号</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    conn = get_conn()</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">with</span> conn.cursor() <span class="keyword">as</span> cursor:</span><br><span class="line">            <span class="comment"># 向数据库发出sql语句</span></span><br><span class="line">            <span class="comment"># execute方法中占位后传参除了元组和字典外,还可以是列表</span></span><br><span class="line">            result = cursor.execute(<span class="string">'delete from tbdept where dno=%s'</span>, [dno])</span><br><span class="line">            <span class="comment"># 如果事务中的所有操作全部成功了最后手动提交</span></span><br><span class="line">            conn.commit()</span><br><span class="line">            print(<span class="string">'删除成功'</span> <span class="keyword">if</span> result == <span class="number">1</span> <span class="keyword">else</span> <span class="string">'删除失败'</span>)</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        print(e)</span><br><span class="line">        <span class="comment"># 如果事务操作有任何一个操作发生异常,那么就会回滚事务</span></span><br><span class="line">        conn.rollback()</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        conn.close()</span><br></pre></td></tr></table></figure></li><li><p>查询操作</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">select</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    查询</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    conn = get_conn()</span><br><span class="line">    print(conn)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># 创建Cursor对象</span></span><br><span class="line">        <span class="keyword">with</span> conn.cursor() <span class="keyword">as</span> cursor:</span><br><span class="line">            <span class="comment"># 向数据库发出sql语句</span></span><br><span class="line">            cursor.execute(<span class="string">'select dno, dname, dloc from tbdept'</span>)</span><br><span class="line">            result = cursor.fetchone()</span><br><span class="line">            <span class="comment"># 程序中最好不要使用fetchall(),如果库中数据量很大,那么脑补一下会有什么样的结果呢</span></span><br><span class="line">            <span class="keyword">while</span> result:</span><br><span class="line">                print(result)</span><br><span class="line">                <span class="comment"># 取出部门名称</span></span><br><span class="line">                <span class="comment"># 在这里我上面连接数据时,使用了cursorclass参数,查询时返回的结果是以字典的方式</span></span><br><span class="line">                print(result[<span class="string">'dname'</span>])</span><br><span class="line">                result = cursor.fetchone()</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        conn.close()</span><br></pre></td></tr></table></figure></li></ul><p>到现在我们已经简单的介绍了用pymysql完成了对数据库的CURD操作</p>]]></content>
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> pymysql </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Linux环境下Git安装与使用</title>
      <link href="/post/9fdd7050.html"/>
      <url>/post/9fdd7050.html</url>
      <content type="html"><![CDATA[<p>Linux环境下Git安装和使用                                                                                                                                            </p><h3 id="Linux环境下Git安装与使用"><a href="#Linux环境下Git安装与使用" class="headerlink" title="Linux环境下Git安装与使用"></a>Linux环境下Git安装与使用</h3><blockquote><p>安装</p></blockquote><ol><li><p>官网下载并解压</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_0_11_centos ~]# wget https://mirrors.edge.kernel.org/pub/software/scm/git/git-2.17.0.tar.gz</span><br><span class="line">[root@VM_0_11_centos ~]# tar -xvf git-2.17.0.tar.gz</span><br><span class="line">[root@VM_0_11_centos ~]# cd git-2.17.0</span><br></pre></td></tr></table></figure></li><li><p>移除旧版本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_0_11_centos ~]# yum remove git</span><br></pre></td></tr></table></figure></li><li><p>安装依赖库</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_0_11_centos ~]# yum install libcurl-devel</span><br><span class="line">[root@VM_0_11_centos ~]# yum install  autoconf automake libtool</span><br></pre></td></tr></table></figure></li><li><p>执行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_0_11_centos ~]# make configure</span><br><span class="line">GIT_VERSION = 2.17.0</span><br><span class="line">    GEN configure</span><br><span class="line">[root@VM_0_11_centos ~]# ./configure --prefix=/usr/local/git --with-iconv =/usr/local/lib（建议优先尝试后者）</span><br><span class="line">或者</span><br><span class="line">./configure --prefix=/usr/local/git --with-iconv --with-curl --with-expat=/usr/local/lib（如果没有安装libiconv请自行安装）</span><br><span class="line">[root@VM_0_11_centos git-2.17.0]# make &amp;&amp; make install</span><br></pre></td></tr></table></figure></li><li><p>配置环境变量</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_0_11_centos git-2.17.0]# vim ~/.bash_profile</span><br><span class="line">在文件末尾追加上下面命令:</span><br><span class="line">PATH=$PATH:/usr/local/git/bin</span><br><span class="line">export PATH</span><br></pre></td></tr></table></figure></li><li><p>重新加载环境变量</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_0_11_centos git-2.17.0]# source ~/.bash_profile</span><br></pre></td></tr></table></figure></li><li><p>查看git版本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_0_11_centos git-2.17.0]# git --version</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>使用</p></blockquote><ol><li><p>在本地建立本地仓库</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_0_11_centos ~]# mkdir test</span><br><span class="line">[root@VM_0_11_centos test]# cd test</span><br><span class="line">[root@VM_0_11_centos test]# git init</span><br></pre></td></tr></table></figure></li><li><p>把文件纳入版本控制(加入暂存区)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_0_11_centos test]# git add &lt;filename&gt; # 将修改后的文件加入暂存区</span><br><span class="line">[root@VM_0_11_centos test]# git add . # add后跟.是将当前文件夹下面的所有文件及文件夹都加入暂存区</span><br></pre></td></tr></table></figure></li><li><p>提交到仓库(-m 后是描述)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_0_11_centos test]# git commit -m '本次提交文件的相关描述信息'</span><br></pre></td></tr></table></figure><p>如果提交报错,看否是缺少<code>user.name</code>、<code>user.email</code>,可执行下面的命令解决:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_0_11_centos test]# git config --global user.name 'your-name'</span><br><span class="line">[root@VM_0_11_centos test]# git config --global user.email 'your-email'</span><br></pre></td></tr></table></figure></li><li><p>查看放入暂存区的文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_0_11_centos test]# git status</span><br></pre></td></tr></table></figure></li><li><p>查看版本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_0_11_centos test]# git log</span><br></pre></td></tr></table></figure></li><li><p>回滚到某个版本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_0_11_centos test]# git reset --hard 版本号</span><br></pre></td></tr></table></figure></li><li><p>显示版本包括历史版本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_0_11_centos test]# git reflog</span><br><span class="line">[root@VM_0_11_centos test]# git reflog --pretty=oneline # 单行显示</span><br></pre></td></tr></table></figure></li><li><p>把暂存区的内容全撤回来(可以在本地做修改,然后再次add进暂存区做提交)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_0_11_centos test]# git checkout -- [可跟上文件名]</span><br></pre></td></tr></table></figure></li><li><p>添加远端仓库</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_0_11_centos test]# git remote add origin https://git.coding.net/gavinliu/test.git</span><br></pre></td></tr></table></figure></li><li><p>将本地仓库和远端仓库同步</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_0_11_centos test]# git push -u origin master</span><br></pre></td></tr></table></figure></li><li><p>创建分支</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_0_11_centos test]# git branch [分支名]</span><br></pre></td></tr></table></figure></li><li><p>查看所有分支</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_0_11_centos test]# git branch</span><br></pre></td></tr></table></figure></li><li><p>切换分支</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_0_11_centos test]# git checkout [分支名]</span><br></pre></td></tr></table></figure></li><li><p>删除文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_0_11_centos test]# git rm [filename]</span><br></pre></td></tr></table></figure></li><li><p>合并分支</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_0_11_centos test]# git merge [分支名]</span><br></pre></td></tr></table></figure></li><li><p>克隆项目到本地</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_0_11_centos ~]# git clone https://git.coding.net/jackfrued/HelloGit.git</span><br></pre></td></tr></table></figure></li><li><p>推送到服务器,origin是原始名字,master是分支</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_0_11_centos test]# git push origin master</span><br></pre></td></tr></table></figure></li><li><p>拉取服务器代码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_0_11_centos test]# git pull</span><br></pre></td></tr></table></figure><p>​</p></li></ol>]]></content>
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Shell常用命令</title>
      <link href="/post/cdf8534a.html"/>
      <url>/post/cdf8534a.html</url>
      <content type="html"><![CDATA[<p>shell的基本常用命令                                                                                                                                                            </p><h2 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h2><blockquote><p><strong>常用操作</strong></p></blockquote><table><thead><tr><th>指令</th><th>操作</th></tr></thead><tbody><tr><td>pwd</td><td>当前路径</td></tr><tr><td>cd</td><td>更改目录 不加参数 进入主目录</td></tr><tr><td>ls</td><td>当前目录内容</td></tr><tr><td>ls -a</td><td>查看隐藏文件</td></tr><tr><td>ls -l</td><td>文件详情</td></tr><tr><td>ls -ld</td><td>目录本身信息</td></tr><tr><td>mkdir</td><td>新建文件夹</td></tr><tr><td>rm</td><td>删除文件</td></tr><tr><td>rm -rf dir/</td><td>删除文件夹</td></tr><tr><td>cp file1 file2</td><td>复制文件</td></tr><tr><td>cp -r dir1 dir2</td><td>复制文件夹</td></tr><tr><td>mv file ..</td><td>移动文件到上一级</td></tr><tr><td>mv file dir/</td><td>移动到dir目录</td></tr><tr><td>mv file1 file2</td><td>替换文件</td></tr><tr><td>mv dir1 dir2</td><td>替换文件夹</td></tr><tr><td>touch a.text</td><td>创建文件</td></tr><tr><td>&gt;a.text</td><td>创建文件</td></tr><tr><td>touch .file.text</td><td>创建隐藏文件</td></tr><tr><td>[cat / less / more] file</td><td>查看文件</td></tr><tr><td>file a.txt</td><td>查看文件类型</td></tr><tr><td>man xx</td><td>打开xx指令的手册 /x 查找某参数 n 查找下一处</td></tr><tr><td>table</td><td>可以补全路径名</td></tr><tr><td>echo</td><td>打印</td></tr><tr><td>date</td><td>显示时间</td></tr><tr><td>cal</td><td>显示日历</td></tr></tbody></table><blockquote><p><strong>解压缩</strong></p></blockquote><table><thead><tr><th>指令</th><th>操作</th></tr></thead><tbody><tr><td>unzip</td><td>解压</td></tr><tr><td>zip -r</td><td>压缩 file.zip dir 压缩后的名称 压缩对象</td></tr><tr><td>tar zxvf</td><td>解压.tar.gz</td></tr><tr><td>tar zcvf</td><td>压缩文件</td></tr><tr><td>tar jxvf</td><td>解压tar.bz2</td></tr><tr><td>tar jcvf</td><td>解压tar.bz2</td></tr></tbody></table><blockquote><p><strong>重定向</strong></p></blockquote><table><thead><tr><th>指令</th><th>操作</th></tr></thead><tbody><tr><td>丨</td><td>管道线</td></tr><tr><td>&lt;</td><td>标准输入重定向</td></tr><tr><td>&gt;</td><td>把输出流保存到文件中 重定向前把文件清空</td></tr><tr><td>&gt;&gt;</td><td>把输出流保存到文件中 不清空文件</td></tr><tr><td>cat file1 &gt;file</td><td>把file1中的内容写入file中</td></tr><tr><td>cat file1 &gt;&gt;file</td><td>把file1中的内容写入file内容后</td></tr><tr><td>ls shit 2 &gt;out.txt</td><td>标准错误输出</td></tr></tbody></table><blockquote><p><strong>权限</strong></p></blockquote><p>用户在自己的主目录有写权限，在其它目录没有。</p><table><thead><tr><th>指令</th><th>操作</th></tr></thead><tbody><tr><td>su -</td><td>更改用户为root</td></tr><tr><td>sudo</td><td>超级用户</td></tr><tr><td>chmod +x +r +w</td><td>添加执行/读/写权限</td></tr><tr><td>chmod 777</td><td>添加全部权限</td></tr></tbody></table><blockquote><p><strong>进程</strong></p></blockquote><table><thead><tr><th>指令</th><th>操作</th></tr></thead><tbody><tr><td>ps -[ef丨aux] 丨grep 应用名称</td><td>查看进程</td></tr><tr><td>kill [-9] pid</td><td>结束某个程序</td></tr></tbody></table><blockquote><p><strong>搜索</strong></p></blockquote><table><thead><tr><th>指令</th><th>操作</th></tr></thead><tbody><tr><td>find file -type f</td><td>搜索文件</td></tr><tr><td>find dir/ -type d</td><td>搜索目录</td></tr></tbody></table><blockquote><p><strong>概念</strong></p></blockquote><table><thead><tr><th>概念</th><th>解释</th></tr></thead><tbody><tr><td>绝对路径</td><td>以 <code>/</code> 开头的路径</td></tr><tr><td>相对路径</td><td>相对于当前工作路径 ./当前工作目录 ../上一级目录</td></tr><tr><td>通配符</td><td>例如 <code>*</code></td></tr></tbody></table>]]></content>
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Shell </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Linux环境下安装Python3.X</title>
      <link href="/post/c8a586cb.html"/>
      <url>/post/c8a586cb.html</url>
      <content type="html"><![CDATA[<p>Linux下大部分系统默认自带python2.x的版本，最常见的是python2.6或python2.7版本，默认的python被系统很多程序所依赖，比如centos下的yum就是python2写的，所以默认版本不要轻易删除，否则会有一些问题，如果需要使用最新的Python3那么我们可以编译安装源码包到独立目录，这和系统默认环境之间是没有任何影响的，python3和python2两个环境并存即可</p><h2 id="Linux环境下安装Python3-X"><a href="#Linux环境下安装Python3-X" class="headerlink" title="Linux环境下安装Python3.X"></a>Linux环境下安装Python3.X</h2><blockquote><p>1.下载Python源代码并解压缩到指定目录</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@iZwz95cxo3u633jbk49xrpZ ~]<span class="comment"># wget https://www.python.org/ftp/python/3.6.5/Python-3.6.5.tar.xz</span></span><br><span class="line">[root@iZwz95cxo3u633jbk49xrpZ ~]<span class="comment"># xz -d Python-3.6.5.tar.xz</span></span><br><span class="line">[root@iZwz95cxo3u633jbk49xrpZ ~]<span class="comment"># tar -xvf Python-3.6.5.tar</span></span><br></pre></td></tr></table></figure><blockquote><p>2.安装依赖库,没有安装可能导致Python在最后安装失败</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@iZwz95cxo3u633jbk49xrpZ ~]<span class="comment"># yum -y install zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel gdbm-devel db4-devel libpcap-devel xz-devel</span></span><br></pre></td></tr></table></figure><blockquote><p>3.进入Python源码目录进行配置和安装</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@iZwz95cxo3u633jbk49xrpZ ~]<span class="comment"># cd Python-3.6.5</span></span><br><span class="line">[root@iZwz95cxo3u633jbk49xrpZ ~]<span class="comment"># ./configure --prefix=/usr/local/python36 --enable-optimizations</span></span><br><span class="line"><span class="comment"># 待上面命令成功后</span></span><br><span class="line">[root@iZwz95cxo3u633jbk49xrpZ ~]<span class="comment"># make &amp;&amp; make install</span></span><br><span class="line"><span class="comment">#如果在中途遇见错误,解决错误信息再重新执行make &amp;&amp; make install即可</span></span><br></pre></td></tr></table></figure><blockquote><p>4.创建软链接</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@iZwz95cxo3u633jbk49xrpZ ~]<span class="comment"># ln -s /usr/local/python36/bin/python3 /usr/bin/python3</span></span><br><span class="line">[root@iZwz95cxo3u633jbk49xrpZ ~]<span class="comment"># ln -s /usr/local/python36/bin/pip3 /usr/bin/pip3</span></span><br><span class="line">[root@iZwz95cxo3u633jbk49xrpZ ~]<span class="comment"># ln -s /usr/local/python36/bin/2to3 /usr/bin/2to3</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">注意:要用ipython环境要先安装ipyton</span><br><span class="line">[root@iZwz95cxo3u633jbk49xrpZ ~]<span class="comment"># pip3 install ipython</span></span><br><span class="line">[root@iZwz95cxo3u633jbk49xrpZ ~]<span class="comment"># ln -s /usr/local/python36/bin/ipython3 /usr/bin/ipython3</span></span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hexo</title>
      <link href="/post/b132932.html"/>
      <url>/post/b132932.html</url>
      <content type="html"><![CDATA[<p>使用hexo搭建一个博客，并托管在github pages上的简易教程。                                                                                    </p><blockquote><p>什么是Hexo?</p></blockquote><p>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 <a href="http://daringfireball.net/projects/markdown/" target="_blank" rel="noopener">Markdown</a>（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p><blockquote><p>安装前提</p></blockquote><p>安装 Hexo 相当简单。然而在安装前，您必须检查电脑中是否已安装下列应用程序：</p><ul><li><a href="http://nodejs.org/" target="_blank" rel="noopener">Node.js</a></li><li><a href="http://git-scm.com/" target="_blank" rel="noopener">Git</a></li></ul><p>如果您的电脑中已经安装上述必备程序，那么恭喜您！接下来只需要使用 npm 即可完成 Hexo 的安装。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g hexo-cli</span><br></pre></td></tr></table></figure><p>如果有环境问题,请参考<a href="https://hexo.bootcss.com/docs/" target="_blank" rel="noopener">Hexo文档</a></p><h3 id="如何使用Hexo搭建Github-Pages博客"><a href="#如何使用Hexo搭建Github-Pages博客" class="headerlink" title="如何使用Hexo搭建Github Pages博客"></a>如何使用Hexo搭建Github Pages博客</h3><blockquote><p>创建仓库</p></blockquote><p>首先我们需要在<a href="https://github.com/" target="_blank" rel="noopener">Github</a>创建一个账号,然后我们登录进去创建仓库</p><p>仓库名称<strong>必须</strong>为 <strong>username</strong>.github.io (注：username为你在github的用户名)</p><p><img src="/..\img\hexo\1.png" alt="1"></p><p><img src="/..\img\hexo\2.png" alt="1"></p><p>如果报错就是仓库已经存在。</p><p>仓库创建成功后，github会给你该仓库的https和ssh地址，复制ssh地址作为备用</p><blockquote><p>建站</p></blockquote><p>上面的操作完成后,我们就可以进行建站操作了,可以参照<a href="https://hexo.bootcss.com/docs/setup.html" target="_blank" rel="noopener">Hexo建站文档</a>,也可以运行下面的命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ hexo init &lt;folder&gt;</span><br><span class="line">$ <span class="built_in">cd</span> &lt;folder&gt;</span><br><span class="line">$ npm install</span><br></pre></td></tr></table></figure><p>上面操作完成后我们建站就成功了,现在我们可以看看自己的博客是什么样子了。在命令行运行下面这条的命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-server --save</span><br></pre></td></tr></table></figure><p>server安装成功后，启动server便可以把博客跑起来：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>现在默认是在本地运行,运行hexo server成功后会出现一个<a href="http://localhost:4000/地址" target="_blank" rel="noopener">http://localhost:4000/地址</a></p><p><img src="/../img/hexo/hexo-blog.png" alt="hexo-blog.png"></p><blockquote><p>部署</p></blockquote><p>到现在我们自己的博客就已经搭建起来,现在我们修改项目的部署信息</p><p>在博客的根目录下可以找到<strong>_config.yml</strong>文件,在文件最后可以找到deploy信息,现做如下配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: git@github.com:&#123;username&#125;/&#123;username&#125;.github.io.git # 这个地址就是github创建仓库后的shh地址</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><p>以上配置好后,我们再配置一下SSH key,关于SSH key的生成和配置，github有详细的<a href="https://help.github.com/articles/generating-ssh-keys/" target="_blank" rel="noopener">帮助文档</a>可以参考。这里做简单介绍：</p><p><img src="/..\img\hexo\3.png" alt="3"></p><p><img src="/..\img\hexo\4.png" alt="4"></p><p><img src="/..\img\hexo\5.png" alt="5"></p><p>完成以上操作就完成了SSH key的配置。</p><p>有了这些配置后便可以提交部署到Github Pages,执行下面的命令:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo clean <span class="comment"># 删除database和public文件夹,因为执行了hexo server</span></span><br></pre></td></tr></table></figure><p>成功后再执行下面的命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate <span class="comment"># 生成新的部署所需要的文件</span></span><br><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>在执行了hexo deploy命令后可能会出现报错<strong>ERROR Deployer not found : github</strong>,这个需要再安装<strong>hexo-deployer-git</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p>完成后再次执行<code>hexo deploy</code>命令,待命令执行成功后我们就成功部署了自己的博客,直接访问<code>https://your-github-username.github.io/</code>这样就可以看到默认主题的博客了</p>]]></content>
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Python3基础之函数</title>
      <link href="/post/5e13db2f.html"/>
      <url>/post/5e13db2f.html</url>
      <content type="html"><![CDATA[<h3 id="Python3基础之函数"><a href="#Python3基础之函数" class="headerlink" title="Python3基础之函数"></a>Python3基础之函数</h3><blockquote><p>三元运算符补充</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 三元运算符(或者三目运算)</span></span><br><span class="line"><span class="comment"># 格式</span></span><br><span class="line"><span class="comment"># 结果 = 值1 if 条件 else 值2</span></span><br><span class="line">result = <span class="keyword">True</span> <span class="keyword">if</span> <span class="number">1</span>&gt;<span class="number">2</span> <span class="keyword">else</span> <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果条件成立则返回'值1',否则返回'值2'</span></span><br></pre></td></tr></table></figure><blockquote><p>函数的定义</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">在开始之前我们先上一段代码:</span><br><span class="line"><span class="keyword">while</span> <span class="keyword">True</span>：</span><br><span class="line">    <span class="keyword">if</span> cpu利用率 &gt; <span class="number">90</span>%:</span><br><span class="line">        <span class="comment"># 发送邮件提醒</span></span><br><span class="line">        连接邮箱服务器</span><br><span class="line">        发送邮件</span><br><span class="line">        关闭连接</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> 硬盘使用空间 &gt; <span class="number">90</span>%:</span><br><span class="line">        <span class="comment"># 发送邮件提醒</span></span><br><span class="line">        连接邮箱服务器</span><br><span class="line">        发送邮件</span><br><span class="line">        关闭连接</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> 内存占用 &gt; <span class="number">80</span>%:</span><br><span class="line">        <span class="comment"># 发送邮件提醒</span></span><br><span class="line">        连接邮箱服务器</span><br><span class="line">        发送邮件</span><br><span class="line">        关闭连接</span><br></pre></td></tr></table></figure><p>不知道大家是否注意到以上代码有很多重复的代码,要写出高质量的代码首先要解决的就是重复代码的问题。我们可以将上面的’发送邮件提醒’功能封装成一个函数,当满足条件时调用函数即可。<br>所以某些具有特殊功能的代码块, 将这些特定的代码块给他分封装起来,这个封装起来的代码块就是函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义函数</span></span><br><span class="line">函数的定义主要有如下要点：</span><br><span class="line">    <span class="number">1.</span><span class="function"><span class="keyword">def</span>：表示函数的关键字</span></span><br><span class="line"><span class="function">    2.函数名：函数的名称，日后根据函数名调用函数（函数的命名规则和变量的命名规则一致）</span></span><br><span class="line"><span class="function">    3.函数体：函数中进行一系列的逻辑计算，如：发送邮件</span></span><br><span class="line"><span class="function">    4.参数：为函数体提供数据</span></span><br><span class="line"><span class="function">    5.返回值：当函数执行完毕后，可以给调用者返回数据。</span></span><br><span class="line"><span class="function">下面我们重构一下上面发送邮件的代码：</span></span><br><span class="line"><span class="function"><span class="title">def</span> <span class="title">send</span><span class="params">()</span>:</span></span><br><span class="line">       </span><br><span class="line">    发送邮件的代码...</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">if</span> success: <span class="comment">#发送成功</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">   </span><br><span class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">       </span><br><span class="line">    <span class="comment"># 每次执行发送邮件函数，都会将返回值自动赋值给result</span></span><br><span class="line">    <span class="comment"># 之后，可以根据result来写日志，或重发等操作</span></span><br><span class="line">   </span><br><span class="line">   <span class="comment"># 在这儿根据函数名'send'来调用函数</span></span><br><span class="line">    result = send()</span><br><span class="line">    <span class="keyword">if</span> result == <span class="keyword">False</span>:</span><br><span class="line">        记录日志，短信发送失败...</span><br></pre></td></tr></table></figure><blockquote><p>匿名函数</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">对于简单的函数，也存在一种简便的表示方式，即：<span class="keyword">lambda</span>表达式</span><br><span class="line"><span class="comment"># 普通方式</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum</span><span class="params">(arg)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> arg + <span class="number">5</span></span><br><span class="line">print(sum(<span class="number">5</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 匿名函数</span></span><br><span class="line">lambda_sum = <span class="keyword">lambda</span> x, y: x + y</span><br><span class="line">print(lambda_sum(<span class="number">5</span>, <span class="number">5</span>))</span><br></pre></td></tr></table></figure><blockquote><p>函数的运用</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 递归调用,遍历文件夹目录</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_all_dir</span><span class="params">(path, str=<span class="string">"|--"</span>)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">        实现目录的遍历</span></span><br><span class="line"><span class="string">    :param path: 遍历目录的路径</span></span><br><span class="line"><span class="string">    :param str: 样式</span></span><br><span class="line"><span class="string">    :return: </span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="comment"># 返回一个指定文件夹(目录)包含文件和文件夹(目录),并且返回一个列表,但是不包含.和..,他一般按照英文首字母排序</span></span><br><span class="line">    fill_all = os.listdir(path)</span><br><span class="line">    <span class="comment"># print(fillAll)</span></span><br><span class="line">    <span class="keyword">for</span> filename <span class="keyword">in</span> fill_all:</span><br><span class="line">        <span class="comment"># 一定不能少了全路径的拼接</span></span><br><span class="line">        file_path = os.path.join(path, filename)</span><br><span class="line">        <span class="comment"># print(filePath)</span></span><br><span class="line">        <span class="comment"># 判断filePath是否是目录</span></span><br><span class="line">        <span class="keyword">if</span> os.path.isdir(file_path):</span><br><span class="line">            print(str + <span class="string">'文件夹'</span> + filename)</span><br><span class="line">            <span class="comment"># filePath是目录</span></span><br><span class="line">            get_all_dir(file_path, <span class="string">"\t"</span> + str)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># filePath不是目录,即是文件</span></span><br><span class="line">            print(str + <span class="string">'文件:'</span> + filename)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">get_all_dir(<span class="string">'../gavinliu_study'</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Python基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 函数 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Python3基础之分支结构和循环结构</title>
      <link href="/post/8b5ec2d0.html"/>
      <url>/post/8b5ec2d0.html</url>
      <content type="html"><![CDATA[<p>在Python中，要构造分支结构可以使用<code>if</code>、<code>elif</code>和<code>else</code>关键字。所谓关键字就是有特殊含义的单词，像<code>if</code>和<code>else</code>就是专门用于构造分支结构的关键字，很显然你不能够使用它作为变量名（事实上，用作其他的标识符也是不可以）</p><p>在程序中我们需要重复的执行某条或某些指令，例如比如在我们的程序中要实现每隔1秒中在屏幕上打印一个”hello, world”这样的字符串并持续一个小时，我们肯定不能够将<code>print(&#39;hello, world&#39;)</code>这句代码写上3600遍。当然你可能已经注意到了，刚才的描述中其实是重复的动作</p><h3 id="Python3基础之分支结构和循环结构"><a href="#Python3基础之分支结构和循环结构" class="headerlink" title="Python3基础之分支结构和循环结构"></a>Python3基础之分支结构和循环结构</h3><blockquote><p>分支结构</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">第一种:  <span class="keyword">if</span>结构</span><br><span class="line">格式:  <span class="keyword">if</span> 表达式:</span><br><span class="line">           语句块</span><br><span class="line">执行流程:程序遇到<span class="keyword">if</span>结构时,判断表达式的真假,如果为真,则执行语句块,否则结束<span class="keyword">if</span>结构    </span><br><span class="line">表达式为假的情况: <span class="number">0</span> <span class="string">''</span> <span class="keyword">None</span>  <span class="keyword">False</span> []  ()  &#123;&#125;</span><br><span class="line">num1 = <span class="number">78</span></span><br><span class="line">num2 = <span class="number">45</span></span><br><span class="line">tmp = <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> num1 &gt; num2:</span><br><span class="line">    tmp = num1</span><br><span class="line">    num1 = num2</span><br><span class="line">    num2 = tmp</span><br><span class="line">    print(num1, num2)</span><br><span class="line">第二种: <span class="keyword">if</span>-<span class="keyword">else</span>结构</span><br><span class="line">格式: <span class="keyword">if</span> 表达式:</span><br><span class="line">          语句块<span class="number">1</span></span><br><span class="line">      <span class="keyword">else</span>:</span><br><span class="line">          语句块<span class="number">2</span></span><br><span class="line">执行流程:程序执行到<span class="keyword">if</span>结构,判断表达式的真假,如果为真,则执行语句块<span class="number">1</span>,如果为假,则执行<span class="keyword">else</span>中的语句块的内容</span><br><span class="line"><span class="comment"># 判断一个年份是否是闰年</span></span><br><span class="line">year = int(input(<span class="string">'请输入你要输入的年份:'</span>))</span><br><span class="line"><span class="keyword">if</span> ((year % <span class="number">4</span> == <span class="number">0</span>) <span class="keyword">and</span> (year % <span class="number">100</span> != <span class="number">0</span>))  <span class="keyword">or</span> (year % <span class="number">400</span> == <span class="number">0</span>):</span><br><span class="line">    print(<span class="string">'是润年'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">'不是闰年'</span>)</span><br><span class="line">第三种: <span class="keyword">if</span>-<span class="keyword">elif</span>-<span class="keyword">else</span></span><br><span class="line">格式: <span class="keyword">if</span> 表达式<span class="number">1</span>:</span><br><span class="line">          语句块<span class="number">1</span></span><br><span class="line">      <span class="keyword">elif</span> 表达式<span class="number">2</span>:</span><br><span class="line">          语句块<span class="number">2</span></span><br><span class="line">      <span class="keyword">elif</span> 表达式<span class="number">3</span>:</span><br><span class="line">          语句块<span class="number">3</span></span><br><span class="line">      <span class="keyword">else</span>:</span><br><span class="line">          语句块n</span><br><span class="line">执行流程:程序执行到<span class="keyword">if</span>语句,判断表达式<span class="number">1</span>的真假,如果为真,则执行语句<span class="number">1</span>,否则判断表达式<span class="number">2</span>的真假,如果为真,则执行表达式<span class="number">2</span>,一次类推,直到最后一个表达式为假,就执行<span class="keyword">else</span>里边的语句块n</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="comment"># 产生一个1-6的随机数</span></span><br><span class="line">num = random.randint(<span class="number">1</span>, <span class="number">6</span>)</span><br><span class="line"><span class="comment"># print(num)</span></span><br><span class="line"><span class="keyword">if</span> num == <span class="number">1</span>:</span><br><span class="line">    print(<span class="string">'这个随机数乘以1后是%d'</span> % (num * <span class="number">1</span>))</span><br><span class="line"><span class="keyword">elif</span> num == <span class="number">2</span>:</span><br><span class="line">    print(<span class="string">'这个随机数乘以2后是%d'</span> % (num * <span class="number">2</span>))</span><br><span class="line"><span class="keyword">elif</span> num == <span class="number">3</span>:</span><br><span class="line">    print(<span class="string">'这个随机数乘以3后是%d'</span> % (num * <span class="number">3</span>))</span><br><span class="line"><span class="keyword">elif</span> num == <span class="number">4</span>:</span><br><span class="line">    print(<span class="string">'这个随机数乘以4后是%d'</span> % (num * <span class="number">4</span>))</span><br><span class="line"><span class="keyword">elif</span> num == <span class="number">5</span>:</span><br><span class="line">    print(<span class="string">'这个随机数乘以5后是%d'</span> % (num * <span class="number">5</span>))</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">'这个随机数乘以本身后是%d'</span> % (num * num))</span><br><span class="line">    </span><br><span class="line">第四种: 嵌套</span><br><span class="line"><span class="keyword">if</span>  表达式<span class="number">1</span>:</span><br><span class="line">    <span class="keyword">if</span> 表达式<span class="number">2</span>:</span><br><span class="line">        语句块<span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        语句块<span class="number">2</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    语句块<span class="number">3</span></span><br><span class="line">name = <span class="string">'xiaoming'</span></span><br><span class="line">password = <span class="string">'123456'</span></span><br><span class="line"></span><br><span class="line">user = input(<span class="string">'请输入用户名'</span>)</span><br><span class="line">pwd = input(<span class="string">'请输入密码'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> user == name:</span><br><span class="line">    <span class="keyword">if</span> pwd == password:</span><br><span class="line">        print(<span class="string">'恭喜你,登录成功'</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">'用户名或者密码错误2'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">'用户名或者密码错误1'</span>)</span><br></pre></td></tr></table></figure><blockquote><p>循环结构</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#for-in循环</span></span><br><span class="line"><span class="comment">#如果明确的知道循环执行的次数或者是要对一个容器进行迭代，使用for-in循环</span></span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">用for循环实现1~100求和</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">sum = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">101</span>):</span><br><span class="line">    sum += x</span><br><span class="line">print(sum)</span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">输入两个正整数计算最大公约数和最小公倍数</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">num1 = int(input(<span class="string">"请输入第一个整数:"</span>))</span><br><span class="line">num2 = int(input(<span class="string">"请输入第二个整数:"</span>))</span><br><span class="line"><span class="comment"># actual = None</span></span><br><span class="line">actual = min(num1, num2)  <span class="comment"># 取最小的整数</span></span><br><span class="line"><span class="comment"># commonDivisorVal = None</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, actual + <span class="number">1</span>):</span><br><span class="line">    <span class="keyword">if</span> (num1 % i == <span class="number">0</span>) <span class="keyword">and</span> (num2 % i == <span class="number">0</span>):</span><br><span class="line">        commonDivisorVal = i</span><br><span class="line">print(<span class="string">"%d和%d的最大公约数是%d"</span> % (num1, num2, commonDivisorVal))</span><br><span class="line"></span><br><span class="line"><span class="comment">#while循环</span></span><br><span class="line"><span class="comment">#如果要构造不知道具体循环次数的循环结构，推荐使用while循环，while循环通过一个能够产生或转换出bool值的表达式来控制循环，表达式的值为True循环继续，表达式的值为False循环结束。</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">猜数字游戏</span></span><br><span class="line"><span class="string">计算机出一个1~100之间的随机数由人来猜</span></span><br><span class="line"><span class="string">计算机根据人猜的数字分别给出提示大一点/小一点/猜对了</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line">answer = random.randint(<span class="number">1</span>, <span class="number">100</span>)</span><br><span class="line">counter = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">    counter += <span class="number">1</span></span><br><span class="line">    number = int(input(<span class="string">'请输入: '</span>))</span><br><span class="line">    <span class="keyword">if</span> number &lt; answer:</span><br><span class="line">        print(<span class="string">'大一点'</span>)</span><br><span class="line">    <span class="keyword">elif</span> number &gt; answer:</span><br><span class="line">        print(<span class="string">'小一点'</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">'恭喜你猜对了!'</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">print(<span class="string">'你总共猜了%d次'</span> % counter)</span><br></pre></td></tr></table></figure><blockquote><p> 注意:上面的代码中使用了break关键字来提前终止循环，需要注意的是break只能终止它所在的那个循环，这一点在使用嵌套的循环结构需要注意。除了break之外，还有另一个是continue，它可以用来跳过本次循环直接进入下一轮循环。</p></blockquote>]]></content>
      
      <categories>
          
          <category> Python基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 分支结构 </tag>
            
            <tag> 循环结构 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Python3基础之字符串、列表、元组、字典、集合等相关操作</title>
      <link href="/post/9a7b293f.html"/>
      <url>/post/9a7b293f.html</url>
      <content type="html"><![CDATA[<p>下面将一一介绍Python中的字符串、列表、元组、集合的相关操作</p><h3 id="字符串、列表、元组、字典、集合等相关操作"><a href="#字符串、列表、元组、字典、集合等相关操作" class="headerlink" title="字符串、列表、元组、字典、集合等相关操作"></a>字符串、列表、元组、字典、集合等相关操作</h3><blockquote><p>字符串操作</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line">字符串一般情况使用单引号或者双引号引起来</span><br><span class="line">规则: 单不能套单,单可以套双</span><br><span class="line">      双不能套双,双可以套单</span><br><span class="line"></span><br><span class="line"><span class="comment">## 多行字符串</span></span><br><span class="line"><span class="comment"># 方式二</span></span><br><span class="line">str3 = <span class="string">'3月25号我来到了美丽的成都,刚下飞机,'</span>\</span><br><span class="line">       <span class="string">'就碰到一个老外帅锅,结果他还跟我打招呼.但是我不会英语,好尴尬'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 方式一</span></span><br><span class="line">str4 = <span class="string">'''洁白的婚纱,手捧着鲜花 ,美丽的想通话.想起那年初夏,我为你牵挂.'''</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 方式三</span></span><br><span class="line">str5 = <span class="string">"""洁白的婚纱,手捧着鲜花 ,美丽的想通话.想起那年初夏,我为你牵挂."""</span></span><br><span class="line">print(str5)</span><br><span class="line"></span><br><span class="line"><span class="comment">#--------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">##字符串的长度</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">len(): 获取字符串的长度</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">str1 = <span class="string">'lhy'</span></span><br><span class="line">str1 = <span class="string">'刘海艳'</span></span><br><span class="line">str1 = <span class="string">'幸福像花儿一样'</span></span><br><span class="line">print(len(str1))</span><br><span class="line"></span><br><span class="line">总结: 无论是字符还是汉字,只要有一个,则长度就是几个</span><br><span class="line"></span><br><span class="line"><span class="comment">#-------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">##提取某个字符</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">提取字符串中的某一个字符</span></span><br><span class="line"><span class="string">方式:</span></span><br><span class="line"><span class="string">从左往右开始, 下标从0开始提取</span></span><br><span class="line"><span class="string">str[0]   str[1]   str[2] ..... str[n]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">从优往左开始, 下标从-1开始</span></span><br><span class="line"><span class="string">str[-1]  str[-2] .....  str[-n]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">str1 = <span class="string">'It is a dog'</span></span><br><span class="line">print(str1[<span class="number">0</span>])</span><br><span class="line">print(str1[<span class="number">-2</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># pytjon中的字符串一旦定义好之后,是不可以修改的</span></span><br><span class="line">str1[<span class="number">0</span>] = <span class="string">'i'</span></span><br><span class="line">print(<span class="string">'str1 ='</span>, str1)</span><br><span class="line"></span><br><span class="line"><span class="comment">#------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">##转义字符</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">转义字符: 将原来的意义给他去掉  \(这是反斜线)   </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">str1 = <span class="string">'我最喜欢的一首歌是\'咱们结婚吧\''</span></span><br><span class="line">str1 = <span class="string">'you\'re a good man'</span></span><br><span class="line">print(str1)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">系统里边有一些特殊的字符: \t(制表符) \n(换行符)</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">print(<span class="string">'你好\\t宝强哥,你的媳妇是马蓉吗?'</span>)</span><br><span class="line">print(<span class="string">'你好\\n宋喆,你的情人是\t马蓉\n吗?'</span>)</span><br><span class="line"><span class="comment"># 如果想将原来具有特殊含义的字符失去本身的意义,我们可以直接在整个字符串前边添加一个r</span></span><br><span class="line">print(<span class="string">r'你好\t宝强哥,你的媳妇是马蓉吗?'</span>)</span><br><span class="line">print(<span class="string">r'你好\n宋喆,你的情人是马蓉吗?'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#-------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">##字符串截取</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">字符串截取:</span></span><br><span class="line"><span class="string">str1[开始下标:结束下标]: 从开始下标截取,到结束下标=结尾,.包含开始下标,但不包含结束下标</span></span><br><span class="line"><span class="string">str1[0:5] 提取是的结果你是zhous</span></span><br><span class="line"><span class="string">str1[:3] 默认从下标0开始到结束的开区间</span></span><br><span class="line"><span class="string">str1[3:] 从指定的下标开始到结尾</span></span><br><span class="line"><span class="string">str1[-n:]: 从最后边提取n个</span></span><br><span class="line"><span class="string">str1[:]:  提取全部字符</span></span><br><span class="line"><span class="string">str1[::2]  根据下标每个n个提取一次</span></span><br><span class="line"><span class="string">str1[::-1]  将字符逆序排列</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">##字符串的格式化</span></span><br><span class="line">%s:    给字符串站位</span><br><span class="line">%d:     给int类型站位</span><br><span class="line">%f:     给浮点类型站位,  默认保留<span class="number">6</span>为小数</span><br><span class="line">        %<span class="number">.2</span>f:  保留两位小数</span><br><span class="line">        %<span class="number">10.2</span>f  共<span class="number">10</span>位,保留两位小数,其他为使用空格补齐</span><br><span class="line">         %<span class="number">010.2</span>f  共<span class="number">10</span>位,保留两位小数,其他为使用<span class="number">0</span>补齐</span><br><span class="line">%c:     打印一个字符</span><br><span class="line">%o:    将十进制转换成八进制</span><br><span class="line">%x:    将十进制转换成十六进制</span><br><span class="line"></span><br><span class="line">name = <span class="string">'宝强'</span></span><br><span class="line">age = <span class="number">36</span></span><br><span class="line">like = <span class="string">'green'</span></span><br><span class="line">print(<span class="string">'他是&#123;&#125;,今年&#123;&#125;,他喜欢&#123;&#125;'</span> .format(name, age, like))</span><br><span class="line">print(<span class="string">'他是&#123;lala&#125;,今年&#123;wawa&#125;, 他喜欢&#123;heihei&#125;'</span> .format(wawa=age, heihei=like, lala=name))</span><br><span class="line"></span><br><span class="line"><span class="comment">#--------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">##字符串比较大小</span></span><br><span class="line">[规则:]从第一个字符开始比较,将字符转换成ascii值进行比较</span><br><span class="line">如果小于则返回<span class="keyword">True</span>,否则返回<span class="keyword">False</span></span><br></pre></td></tr></table></figure><blockquote><p>列表操作</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">列表:  格式:  列表名 = [元素1, 元素2,,...]</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="comment"># append()往列表后边追加一个元素</span></span><br><span class="line">list1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">list1.append(<span class="number">100</span>)</span><br><span class="line"><span class="comment"># print(list1)</span></span><br><span class="line">list1.append([<span class="number">200</span>, <span class="number">400</span>, <span class="number">600</span>])</span><br><span class="line"><span class="comment"># print(list1)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在末尾一次性追加另外一个列表中的多个值</span></span><br><span class="line">list2 = [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">list2.extend([<span class="number">200</span>, <span class="number">300</span>, <span class="number">400</span>])</span><br><span class="line"><span class="comment"># print(list2)</span></span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">insert():在指定下标出添加一个元素,原来位置处的元素往后移动</span></span><br><span class="line"><span class="string">@参数一: 列表的下标</span></span><br><span class="line"><span class="string">@参数二: 列表中下标所对应的值</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">list3 = [<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]</span><br><span class="line">list3.insert(<span class="number">1</span>, <span class="number">250</span>)</span><br><span class="line"><span class="comment"># print(list3)</span></span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">pop():将列表中指定下标的元素删除, 如果默认不传递参数,则删除的是最后一个元素</span></span><br><span class="line"><span class="string">@参数一: [可有可无] 列表对应的下标</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">list4 = [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]</span><br><span class="line">list4.pop()</span><br><span class="line">list4.pop()</span><br><span class="line"><span class="comment"># print(list4)</span></span><br><span class="line">list4.pop(<span class="number">1</span>)</span><br><span class="line"><span class="comment"># print(list4)</span></span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">remove():移除列表中指定的元素</span></span><br><span class="line"><span class="string">@参数一: 列表中的元素</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">list5 = [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]</span><br><span class="line">list5.remove(<span class="number">3</span>)</span><br><span class="line"><span class="comment"># print(list5)</span></span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">clear():清除列表中所有的元素</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">list6 = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">list6.clear()</span><br><span class="line"><span class="comment"># print(list6)</span></span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">index():获取列表元素锁对应的下标</span></span><br><span class="line"><span class="string">@参数一:  列表中的某一个元素</span></span><br><span class="line"><span class="string">返回值:  列表中元素所对应的下标</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">list7 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">index1 = list7.index(<span class="number">3</span>)</span><br><span class="line"><span class="comment"># print(index1)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取列表的长度</span></span><br><span class="line">list8 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="comment"># print(len(list8))</span></span><br><span class="line"></span><br><span class="line">list9 = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">7</span>]</span><br><span class="line"><span class="comment"># print(max(list9))</span></span><br><span class="line"></span><br><span class="line">list10 = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">7</span>]</span><br><span class="line"><span class="comment"># print(min(list9))</span></span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">count(): 计算列表中元素出现的次数</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">list11 = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">7</span>]</span><br><span class="line"><span class="comment"># print(list11.count(3))</span></span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">reverse():将列表进行倒序排列</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">list12 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line">list12.reverse()</span><br><span class="line"><span class="comment"># print(list12)</span></span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">sort():将列表中的元素进行升序排列</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">list13 = [<span class="number">1</span>, <span class="number">100</span>, <span class="number">78</span>, <span class="number">23</span>, <span class="number">65</span>, <span class="number">43</span>]</span><br><span class="line">list13.sort()</span><br><span class="line"><span class="comment"># print(list13)</span></span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">引用传递:  </span></span><br><span class="line"><span class="string">在列表中,如果修改一个列表的元素,那么对应的另外一个列表的元素也改变</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">list14 = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">list15 = list14</span><br><span class="line">list15[<span class="number">1</span>] = <span class="number">200</span></span><br><span class="line"><span class="comment"># print(list14)</span></span><br><span class="line"><span class="comment"># print(list15)</span></span><br><span class="line"><span class="comment"># id():查看内存的地址</span></span><br><span class="line"><span class="comment"># print(id(list14))</span></span><br><span class="line"><span class="comment"># print(id(list15))</span></span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">值传递</span></span><br><span class="line"><span class="string">在列表中修改一个元素的值时,对应的另外一个列表中的值是不发生改变的</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">list16 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">list17 = list16.copy()</span><br><span class="line">list17[<span class="number">1</span>] = <span class="number">250</span></span><br><span class="line">print(list16)</span><br><span class="line">print(list17)</span><br><span class="line">print(id(list16))</span><br><span class="line">print(id(list17))</span><br></pre></td></tr></table></figure><blockquote><p>元组操作</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">元组:也是一种有序集合</span></span><br><span class="line"><span class="string">特点:</span></span><br><span class="line"><span class="string">1.跟列表非常相似:  list1 = []   tuple1 = ()</span></span><br><span class="line"><span class="string">2.一旦定义好之后不能修改</span></span><br><span class="line"><span class="string">3.使用小括号括起一个集合</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="comment"># 创建一个空元祖</span></span><br><span class="line">tuple1 = ()</span><br><span class="line"><span class="comment"># print(tuple1)</span></span><br><span class="line"><span class="comment"># print(type(tuple1))</span></span><br><span class="line"></span><br><span class="line">tuple2 = (<span class="number">23</span>, <span class="number">3.14</span>, <span class="string">'aaa'</span>, <span class="keyword">None</span>, <span class="keyword">True</span>)</span><br><span class="line"><span class="comment"># print(tuple2)</span></span><br><span class="line"></span><br><span class="line">tuple3 = (<span class="number">4</span>, )<span class="comment">#tuple</span></span><br><span class="line">tuple3 = (<span class="number">4</span>)<span class="comment">#int</span></span><br><span class="line"><span class="comment"># print(tuple3)</span></span><br><span class="line"><span class="comment"># print(type(tuple3))</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 访问元祖的元素</span></span><br><span class="line">tuple4 = (<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)</span><br><span class="line"><span class="comment"># print(tuple4[0])</span></span><br><span class="line"><span class="comment"># print(tuple4[1])</span></span><br><span class="line"><span class="comment"># 元祖在访问的时候一定不能溢出(越界),直接报错</span></span><br><span class="line"><span class="comment"># print(tuple4[5])</span></span><br><span class="line"><span class="comment"># 获取元祖中最后一个元素</span></span><br><span class="line"><span class="comment"># print(tuple4[-1])</span></span><br><span class="line"><span class="comment"># print(tuple4[-2])</span></span><br><span class="line"><span class="comment"># 一定不能越界</span></span><br><span class="line"><span class="comment"># print(tuple4[-6])</span></span><br><span class="line"></span><br><span class="line">tuple5 = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, [<span class="number">12</span>, <span class="number">34</span>, <span class="number">45</span>])</span><br><span class="line"><span class="comment"># print(tuple5)</span></span><br><span class="line"><span class="comment"># tuple5[0] = 150#直接报错, 元祖定义好之后是不能修改的</span></span><br><span class="line"><span class="comment"># print(tuple5)</span></span><br><span class="line"><span class="comment"># print(tuple5[-1][-2])</span></span><br><span class="line"><span class="comment"># print(tuple5[4][1])</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除元祖的用法跟删除变量的用法一致</span></span><br><span class="line">tuple6 = (<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>)</span><br><span class="line"><span class="keyword">del</span> tuple6</span><br><span class="line"><span class="comment"># print(tuple6)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 元祖进行操作</span></span><br><span class="line">tuple7 = (<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">tuple8 = (<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>)</span><br><span class="line"><span class="comment"># 将两个元祖合并成一个新的元祖</span></span><br><span class="line">tuple9 = tuple7 + tuple8</span><br><span class="line"><span class="comment"># print(tuple9)</span></span><br><span class="line"><span class="comment"># print(tuple7, tuple8)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将元祖重复n次,最后返回一个新的元祖</span></span><br><span class="line">tuple10 = (<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line"><span class="comment"># print(tuple10 * 10)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断一个元素是否在一个元祖中,如果在返回True,否则返回False</span></span><br><span class="line">tuple11 = (<span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>)</span><br><span class="line"><span class="comment"># print(4 in tuple11)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 元祖的截取</span></span><br><span class="line"><span class="comment"># 格式: 元祖名[开始下标:结束下标]</span></span><br><span class="line">tuple12 = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>,<span class="number">10</span>)</span><br><span class="line"><span class="comment"># print(tuple12[1:5])</span></span><br><span class="line"><span class="comment"># print(tuple12[3:])</span></span><br><span class="line"><span class="comment"># print(tuple12[:6])</span></span><br><span class="line"><span class="comment"># 将元祖进行逆序排列</span></span><br><span class="line"><span class="comment"># print(tuple12[::-1])</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 二维元祖:</span></span><br><span class="line">tuple13 = ((<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>), (<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>))</span><br><span class="line"><span class="comment"># print(tuple13[1][1])</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 元祖的方法</span></span><br><span class="line"><span class="comment"># 求一个元祖的长度</span></span><br><span class="line">tuple14 = (<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line"><span class="comment"># print(len(tuple14))</span></span><br><span class="line"><span class="comment"># print(max(tuple14))</span></span><br><span class="line"><span class="comment"># print(min(tuple14))</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 对列表进行遍历</span></span><br><span class="line"><span class="comment"># for i in [1, 2, 3, 4, 5]:</span></span><br><span class="line"><span class="comment">#     print(i)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 对元祖进行遍历</span></span><br><span class="line"><span class="comment"># for x in (3, 4, 5, 6, 7):</span></span><br><span class="line"><span class="comment">#     print(x)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将列表转换成元祖</span></span><br><span class="line">list11 = [<span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">8</span>]</span><br><span class="line">tuple15 = tuple(list11)</span><br><span class="line"><span class="comment"># print(tuple15)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将元祖转换成列表</span></span><br><span class="line">tuple16 = (<span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">9</span>)</span><br><span class="line">list12 = list(tuple16)</span><br><span class="line"><span class="comment"># print(list12)</span></span><br><span class="line"></span><br><span class="line">list13 = range(<span class="number">0</span>, <span class="number">10</span>)</span><br><span class="line">print(type(list13))</span><br><span class="line"><span class="comment"># range(): 从开始值开始,但不包含结束值[0, 10)</span></span><br><span class="line"><span class="comment"># for i in range(0, 10):</span></span><br><span class="line"><span class="comment">#     print(i)</span></span><br></pre></td></tr></table></figure><blockquote><p>字典操作</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">dict(字典): 在字典里边一般存放的是键值对的形式.</span></span><br><span class="line"><span class="string">键1 = 值1   key = value</span></span><br><span class="line"><span class="string">键1 : 值1</span></span><br><span class="line"><span class="string">写法: &#123;键1:值1, 键2:值2, 键3:值3&#125;</span></span><br><span class="line"><span class="string">例子:dict1 = &#123;'name': '刘海艳', 'age': 17, 'sex': 'girl'&#125;</span></span><br><span class="line"><span class="string">注意事项:</span></span><br><span class="line"><span class="string">1.在字典中键(key)的值必须是唯一</span></span><br><span class="line"><span class="string">2.在字典中可以存放多个键值对</span></span><br><span class="line"><span class="string">3.在字典中键(key)必须是不可变类型   字符串  整数都可以作为键(key)</span></span><br><span class="line"><span class="string">4.list和tuple都是有序集合, 而dictsahib无序集合</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="comment"># 必须保证字典中的key是唯一的</span></span><br><span class="line">dict1 = &#123;<span class="string">'yelei'</span>: <span class="number">100</span>, <span class="string">'xiaoming'</span> : <span class="number">99</span>, <span class="string">'jianfei'</span>: <span class="number">59</span>, <span class="string">'zhouying'</span>: <span class="number">110</span>&#125;</span><br><span class="line"><span class="comment"># print(dict1)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 元素的访问</span></span><br><span class="line"><span class="comment"># 获取的方式: 字典名[key]</span></span><br><span class="line"><span class="comment"># print(dict1['xiaoming'])</span></span><br><span class="line"><span class="comment"># print(dict1.get('yelei'))</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># print('yelei' in dict1)</span></span><br><span class="line"></span><br><span class="line">ret = dict1.get(<span class="string">'lhy'</span>)</span><br><span class="line"><span class="comment"># if ret == None:</span></span><br><span class="line"><span class="comment">#     print('没有')</span></span><br><span class="line"><span class="comment"># else:</span></span><br><span class="line"><span class="comment">#     print('有')</span></span><br><span class="line"></span><br><span class="line">dict2 = &#123;<span class="string">'user'</span>: <span class="string">'大黄'</span>, <span class="string">'sex'</span>: <span class="string">'男'</span>, <span class="string">'age'</span>: <span class="number">30</span>, <span class="string">'height'</span>: <span class="number">150</span> &#125;</span><br><span class="line"><span class="comment"># 添加元素</span></span><br><span class="line">dict2[<span class="string">'lover'</span>] = <span class="string">'小白'</span></span><br><span class="line"><span class="comment"># 一个key只能对应一个value</span></span><br><span class="line">dict2[<span class="string">'lover'</span>] = <span class="string">'小绿'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改</span></span><br><span class="line">dict2[<span class="string">'lover'</span>] = <span class="string">'小花'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除</span></span><br><span class="line">dict2.pop(<span class="string">'sex'</span>)</span><br><span class="line"><span class="comment"># 直接报错,因为他是无需集合</span></span><br><span class="line"><span class="comment"># dict2.pop()</span></span><br><span class="line"><span class="comment"># print(dict2)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 遍历</span></span><br><span class="line"><span class="comment"># for x in dict2:</span></span><br><span class="line"><span class="comment">#     print(x, dict2[x])</span></span><br><span class="line"><span class="comment"># 获取字典所有的value和key</span></span><br><span class="line"><span class="comment"># print(dict2.values())</span></span><br><span class="line"><span class="comment"># print(dict2.keys())</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># for i in dict2.values():</span></span><br><span class="line"><span class="comment">#     print(i)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># for i in dict2.keys():</span></span><br><span class="line"><span class="comment">#     print(i)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># for k,v in dict2.items():</span></span><br><span class="line"><span class="comment">#     print(k, v)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#for k,v in enumerate(dict2):</span></span><br><span class="line"><span class="comment">#    print(k, v)</span></span><br></pre></td></tr></table></figure><blockquote><p>集合操作</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">set(集合):类似于dict, 也是无序的,以key-value新的形势存在,但是没有value</span></span><br><span class="line"><span class="string">作用: 是对list,tuple,dict进行去重的, 求交集.并集</span></span><br><span class="line"><span class="string">1.set是无序</span></span><br><span class="line"><span class="string">2.set集合是不可改变的</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># set1 = set([1, 2, 3, 5, 3, 2])</span></span><br><span class="line"><span class="comment"># print(set1)</span></span><br><span class="line"><span class="comment"># print(type(set1))</span></span><br><span class="line"><span class="comment"># set2 = set((1, 2, 3, 5, 3, 2, 4, 5))</span></span><br><span class="line"><span class="comment"># print(set2)</span></span><br><span class="line"><span class="comment"># print(type(set2))</span></span><br><span class="line"><span class="comment"># set3 = set(&#123;3, 4, 5,5, 6, 3, 7&#125;)</span></span><br><span class="line"><span class="comment"># print(set3)</span></span><br><span class="line"><span class="comment"># print(type(set3))</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加</span></span><br><span class="line">set4 = set([<span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>])</span><br><span class="line">set4.add(<span class="number">8</span>)</span><br><span class="line"><span class="comment"># set4.add(3)#可以添加重复的值,但是没效果</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 总结:list和dict是可改变的, 而tuple是不可改变</span></span><br><span class="line"><span class="comment"># set4.add([10, 9])#直接报错,不能添加list</span></span><br><span class="line"><span class="comment"># set4.add((10, 9))</span></span><br><span class="line"><span class="comment"># set4.add(&#123;'a':1&#125;)#直接报错,不能添加字典</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># print(set4)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改</span></span><br><span class="line">set5 = set([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])</span><br><span class="line"><span class="comment"># 将list dict tuple 等等整个插入进去</span></span><br><span class="line"><span class="comment"># set5.update([6, 7, 8])</span></span><br><span class="line"><span class="comment"># set5.update(&#123;9, 10&#125;)</span></span><br><span class="line"><span class="comment"># set5.update((11, 56))</span></span><br><span class="line"><span class="comment"># print(set5)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除</span></span><br><span class="line"><span class="comment"># set6= set([3, 4, 5, 6, 7])</span></span><br><span class="line"><span class="comment"># set6.remove(4)</span></span><br><span class="line"><span class="comment"># print(set6)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 遍历</span></span><br><span class="line">set7 = set([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>])</span><br><span class="line">set7 = set([<span class="string">'aaa'</span>, <span class="string">'bbb'</span>, <span class="string">'ccc'</span>])</span><br><span class="line">set7 = set((<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>))</span><br><span class="line"><span class="comment"># 在set集合中,没有value,即使有value也遍历不出来</span></span><br><span class="line">set7 = set(&#123;<span class="string">'name'</span>:<span class="string">'小花'</span>, <span class="string">'age'</span>: <span class="number">18</span>&#125;)</span><br><span class="line"><span class="comment"># for i in set7:</span></span><br><span class="line"><span class="comment">#     print(i, end = ',')</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># &amp; | - ^</span></span><br><span class="line">set8 = set([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line">set9 = set([<span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>])</span><br><span class="line">set10 = set8 &amp; set9</span><br><span class="line">set11 = set8 | set9</span><br><span class="line">set12 = set8 - set9</span><br><span class="line">set13 = set8 ^ set9</span><br><span class="line">print(set10)</span><br><span class="line">print(set11)</span><br><span class="line">print(set12)</span><br><span class="line">print(set13)</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Python基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串 </tag>
            
            <tag> 列表 </tag>
            
            <tag> 元组 </tag>
            
            <tag> 字典 </tag>
            
            <tag> 集合 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Python3基础之基本数据类型、变量和运算符</title>
      <link href="/post/510bec9b.html"/>
      <url>/post/510bec9b.html</url>
      <content type="html"><![CDATA[<h3 id="Python3基础之基本数据类型、变量和运算符"><a href="#Python3基础之基本数据类型、变量和运算符" class="headerlink" title="Python3基础之基本数据类型、变量和运算符"></a>Python3基础之基本数据类型、变量和运算符</h3><ol><li><p>基本数据类型</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">在Python中，能够直接处理的数据类型有以下几种：</span><br><span class="line">    <span class="number">1</span>）整型:Python可以处理任意大小的整数，当然包括负整数</span><br><span class="line">    如：<span class="number">100</span> <span class="number">-100</span></span><br><span class="line">    计算机由于使用二进制，所以Python支持二进制（<span class="number">0b100</span>）、八进制(<span class="number">0o100</span>)和十六进制(<span class="number">0xff00</span>)表示</span><br><span class="line">    <span class="number">2</span>)浮点数:浮点数也就是小数，之所以称为浮点数，是因为按照科学记数法表示时，一个浮点数的小数点位置是可变的</span><br><span class="line">    如: <span class="number">123.456</span> 但是对于很大或很小的浮点数，就必须用科学计数法表示，把<span class="number">10</span>用e替代，<span class="number">1.23</span>x10^<span class="number">9</span>就是<span class="number">1.23e9</span></span><br><span class="line">    <span class="number">3</span>)字符串型:字符串是以单引号或双引号括起来的任意文本</span><br><span class="line">    如: <span class="string">'hello world'</span> 或者 <span class="string">"hello world"</span></span><br><span class="line">    <span class="number">4</span>)布尔型:布尔值和布尔代数的表示完全一致，一个布尔值只有<span class="keyword">True</span>、<span class="keyword">False</span>两种值，要么是<span class="keyword">True</span>，要么是<span class="keyword">False</span>，在Python中，可以直接用<span class="keyword">True</span>、<span class="keyword">False</span>表示布尔值（请注意大小写）</span><br><span class="line">    如: <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">False</span></span><br><span class="line">        <span class="number">3</span> &gt; <span class="number">2</span></span><br><span class="line">        <span class="number">2</span> &lt; </span><br><span class="line">    <span class="number">5</span>)空类型:空类型是Python里一个特殊的值，用<span class="keyword">None</span>表示。<span class="keyword">None</span>不能理解为<span class="number">0</span>，因为<span class="number">0</span>是有意义的，而<span class="keyword">None</span>是一个特殊的空值。(请注意不要与其它语言中的null混淆)</span><br><span class="line">在Python中还支持复数、列表、字典、元组、集合等数据类型，之后会一一说明。</span><br></pre></td></tr></table></figure></li><li><p>变量</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">什么是变量</span><br><span class="line">    在计算机程序中，变量不仅可以是数字，还可以是任意数据类型。变量是一种存储数据的载体，其值可以被读取和修改。</span><br><span class="line">变量命名</span><br><span class="line">    a.只能有数字,字母,下划线组成</span><br><span class="line">    b.不能以数字开始</span><br><span class="line">    c.不要跟关键字和系统保留字冲突</span><br><span class="line">    `关键字:</span><br><span class="line">      [<span class="string">'False'</span>, <span class="string">'None'</span>, <span class="string">'True'</span>, <span class="string">'and'</span>, <span class="string">'as'</span>, <span class="string">'assert'</span>, <span class="string">'async'</span>, <span class="string">'await'</span>, <span class="string">'break'</span>, <span class="string">'class'</span>, <span class="string">'continue'</span>, <span class="string">'def'</span>, <span class="string">'del'</span>, <span class="string">'elif'</span>, <span class="string">'else'</span>, <span class="string">'except'</span>, <span class="string">'finally'</span>, <span class="string">'for'</span>, <span class="string">'from'</span>, <span class="string">'global'</span>, <span class="string">'if'</span>, <span class="string">'import'</span>, <span class="string">'in'</span>, <span class="string">'is'</span>, <span class="string">'lambda'</span>, <span class="string">'nonlocal'</span>, <span class="string">'not'</span>, <span class="string">'or'</span>, <span class="string">'pass'</span>, <span class="string">'raise'</span>, <span class="string">'return'</span>, <span class="string">'try'</span>, <span class="string">'while'</span>, <span class="string">'with'</span>, <span class="string">'yield'</span>]</span><br><span class="line">    d. 严格区分大小写</span><br><span class="line">    e. 见名之意</span><br><span class="line">    f. 遵循驼峰原则: UserName  userName   user_name</span><br><span class="line">变量的实用和作用</span><br><span class="line">    a = <span class="number">100</span></span><br><span class="line">    b = <span class="number">-100</span></span><br><span class="line">    c = <span class="number">3.1415926</span></span><br><span class="line">    d = <span class="keyword">True</span></span><br><span class="line">    e = <span class="keyword">False</span></span><br><span class="line">    f = <span class="keyword">None</span></span><br><span class="line">    作用是将不同的数据类型存到内存中</span><br></pre></td></tr></table></figure></li><li><p>运算符</p><p><img src="https://gitee.com/gavinliu4011/codes/6kuiqc4nd0swy9ga83bvf76/raw?blob_name=%E8%BF%90%E7%AE%97%E7%AC%A6.png" alt="img"></p><blockquote><p>Python支持多种运算符，下表大致按照优先级从高到低的顺序列出了所有的运算符，我们会陆续使用到它们。<br>说明:此片段引用原文<a href="https://blog.csdn.net/jackfrued/article/details/79392196" target="_blank" rel="noopener">https://blog.csdn.net/jackfrued/article/details/79392196</a></p></blockquote></li></ol>]]></content>
      
      <categories>
          
          <category> Python基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 数据类型 </tag>
            
            <tag> 变量 </tag>
            
            <tag> 运算符 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Python之禅</title>
      <link href="/post/6be2dbca.html"/>
      <url>/post/6be2dbca.html</url>
      <content type="html"><![CDATA[<p>用过 Python的人，基本上都知道在交互式解释器中输入 import this 就会显示 Tim Peters 的 The Zen of Python，但它那偈语般的语句有点令人费解，所以我想分享一下我对它的体会，顺带给出我的翻译。</p><h3 id="Python之禅"><a href="#Python之禅" class="headerlink" title="Python之禅"></a>Python之禅</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Beautiful is better than ugly.</span><br><span class="line">优美胜于丑陋（Python 以编写优美的代码为目标）</span><br><span class="line"></span><br><span class="line">Explicit is better than implicit.</span><br><span class="line">明了胜于晦涩（优美的代码应当是明了的，命名规范，风格相似）</span><br><span class="line"></span><br><span class="line">Simple is better than complex.</span><br><span class="line">简洁胜于复杂（优美的代码应当是简洁的，不要有复杂的内部实现）</span><br><span class="line"></span><br><span class="line">Complex is better than complicated.</span><br><span class="line">复杂胜于凌乱（如果复杂不可避免，那代码间也不能有难懂的关系，要保持接口简洁）</span><br><span class="line"></span><br><span class="line">Flat is better than nested.</span><br><span class="line">扁平胜于嵌套（优美的代码应当是扁平的，不能有太多的嵌套）</span><br><span class="line"></span><br><span class="line">Sparse is better than dense.</span><br><span class="line">间隔胜于紧凑（优美的代码有适当的间隔，不要奢望一行代码解决问题）</span><br><span class="line"></span><br><span class="line">Readability counts.</span><br><span class="line">可读性很重要（优美的代码是可读的）</span><br><span class="line"></span><br><span class="line">Special cases aren&apos;t special enough to break the rules.</span><br><span class="line">Although practicality beats purity.</span><br><span class="line">即便假借特例的实用性之名，也不可违背这些规则（这些规则至高无上）</span><br><span class="line"></span><br><span class="line">Errors should never pass silently.</span><br><span class="line">不要包容所有错误</span><br><span class="line"></span><br><span class="line">Unless explicitly silenced.                                             </span><br><span class="line">除非你确定需要这样做（精准地捕获异常，不写 except:pass 风格的代码）</span><br><span class="line"></span><br><span class="line">In the face of ambiguity, refuse the temptation to guess.</span><br><span class="line">当存在多种可能，不要尝试去猜测</span><br><span class="line"></span><br><span class="line">There should be one-- and preferably only one --obvious way to do it.</span><br><span class="line">而是尽量找一种，最好是唯一一种明显的解决方案（如果不确定，就用穷举法）</span><br><span class="line"></span><br><span class="line">Although that way may not be obvious at first unless you&apos;re Dutch.</span><br><span class="line">虽然这并不容易，因为你不是 Python 之父（这里的 Dutch 是指 Guido ）</span><br><span class="line"></span><br><span class="line">Now is better than never.</span><br><span class="line">做也许好过不做</span><br><span class="line"></span><br><span class="line">Although never is often better than right now.</span><br><span class="line">但不假思索就动手还不如不做</span><br><span class="line"></span><br><span class="line">If the implementation is hard to explain, it&apos;s a bad idea.</span><br><span class="line">If the implementation is easy to explain, it may be a good idea.</span><br><span class="line">如果你无法向人描述你的方案，那肯定不是一个好方案；反之亦然（方案测评标准）</span><br><span class="line"></span><br><span class="line">Namespaces are one honking great idea -- let&apos;s do more of those!</span><br><span class="line">命名空间是一种绝妙的理念，我们应当多加利用（倡导与号召）</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
