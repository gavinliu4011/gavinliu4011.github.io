<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>gavinliu&#39;s blog</title>
  
  <subtitle>刘泰丞的个人博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://gavinliu4011.github.io/"/>
  <updated>2018-05-04T13:50:02.373Z</updated>
  <id>http://gavinliu4011.github.io/</id>
  
  <author>
    <name>GavinLiu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Scrapy 框架(二)之Scrapy Shell</title>
    <link href="http://gavinliu4011.github.io/post/a9fd3a36.html"/>
    <id>http://gavinliu4011.github.io/post/a9fd3a36.html</id>
    <published>2018-05-04T21:48:56.000Z</published>
    <updated>2018-05-04T13:50:02.373Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Scrapy-Shell"><a href="#Scrapy-Shell" class="headerlink" title="Scrapy Shell"></a>Scrapy Shell</h3><p>Scrapy终端是一个交互终端，我们可以在未启动spider的情况下尝试及调试代码，也可以用来测试XPath或CSS表达式，查看他们的工作方式，方便我们爬取的网页中提取的数据。 </p><h3 id="启动Scrapy-Shell"><a href="#启动Scrapy-Shell" class="headerlink" title="启动Scrapy Shell"></a>启动Scrapy Shell</h3><p>进入项目的根目录，执行下列命令来启动shell:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scrapy shell &quot;http://hr.tencent.com/position.php?&amp;start=0#a&quot;</span><br></pre></td></tr></table></figure><p><img src="../img/spider/20180725180430.png" alt="img"></p><p>Scrapy Shell根据下载的页面会自动创建一些方便使用的对象，例如 Response 对象，以及 <code>Selector 对象 (对HTML及XML内容)</code>。</p><ul><li>当shell载入后，将得到一个包含response数据的本地 response 变量，输入 <code>response.body</code>将输出response的包体，输出 <code>response.headers</code> 可以看到response的包头。</li><li>输入 <code>response.selector</code> 时， 将获取到一个response 初始化的类 Selector 的对象，此时可以通过使用 <code>response.selector.xpath()</code>或<code>response.selector.css()</code> 来对 response 进行查询。</li><li>Scrapy也提供了一些快捷方式, 例如 <code>response.xpath()</code>或<code>response.css()</code>同样可以生效。</li></ul><h3 id="Selectors选择器"><a href="#Selectors选择器" class="headerlink" title="Selectors选择器"></a>Selectors选择器</h3><blockquote><p>Scrapy Selectors 内置 XPath 和 CSS Selector 表达式机制</p></blockquote><p>Selector有四个基本的方法，最常用的还是xpath:</p><ul><li>xpath(): 传入xpath表达式，返回该表达式所对应的所有节点的selector list列表</li><li>extract(): 序列化该节点为Unicode字符串并返回list</li><li>css(): 传入CSS表达式，返回该表达式所对应的所有节点的selector list列表，语法同 BeautifulSoup4</li><li>re(): 根据传入的正则表达式对数据进行提取，返回Unicode字符串list列表</li></ul><h4 id="XPath表达式的例子及对应的含义"><a href="#XPath表达式的例子及对应的含义" class="headerlink" title="XPath表达式的例子及对应的含义:"></a>XPath表达式的例子及对应的含义:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/html/head/title: 选择&lt;HTML&gt;文档中 &lt;head&gt; 标签内的 &lt;title&gt; 元素</span><br><span class="line">/html/head/title/text(): 选择上面提到的 &lt;title&gt; 元素的文字</span><br><span class="line">//td: 选择所有的 &lt;td&gt; 元素</span><br><span class="line">//div[@class=&quot;mine&quot;]: 选择所有具有 class=&quot;mine&quot; 属性的 div 元素</span><br></pre></td></tr></table></figure><h4 id="尝试Selector"><a href="#尝试Selector" class="headerlink" title="尝试Selector"></a>尝试Selector</h4><p>我们用腾讯社招的网站<a href="http://hr.tencent.com/position.php?&amp;start=0#a" target="_blank" rel="noopener">http://hr.tencent.com/position.php?&amp;start=0#a</a>举例： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># 启动</span><br><span class="line">scrapy shell &quot;http://hr.tencent.com/position.php?&amp;start=0#a&quot;</span><br><span class="line"></span><br><span class="line"># 返回 xpath选择器对象列表</span><br><span class="line">response.xpath(&apos;//title&apos;)</span><br><span class="line"># [&lt;Selector xpath=&apos;//title&apos; data=&apos;&lt;title&gt;职位搜索 | 社会招聘 | Tencent 腾讯招聘&lt;/title&apos;&gt;]</span><br><span class="line"></span><br><span class="line"># 使用 extract()方法返回字符串列表</span><br><span class="line">response.xpath(&apos;//title&apos;).extract()</span><br><span class="line"># [&apos;&lt;title&gt;职位搜索 | 社会招聘 | Tencent 腾讯招聘&lt;/title&gt;&apos;]</span><br><span class="line"></span><br><span class="line"># 打印列表第一个元素</span><br><span class="line">print(response.xpath(&apos;//title&apos;).extract()[0])</span><br><span class="line"># &lt;title&gt;职位搜索 | 社会招聘 | Tencent 腾讯招聘&lt;/title&gt;</span><br><span class="line">print(response.xpath(&apos;//title&apos;).extract_first())</span><br><span class="line"># &lt;title&gt;职位搜索 | 社会招聘 | Tencent 腾讯招聘&lt;/title&gt;</span><br><span class="line"></span><br><span class="line"># 返回 xpath选择器对象列表</span><br><span class="line">response.xpath(&apos;//title/text()&apos;)</span><br><span class="line"># [&lt;Selector xpath=&apos;//title/text()&apos; data=&apos;职位搜索 | 社会招聘 | Tencent 腾讯招聘&apos;&gt;]</span><br></pre></td></tr></table></figure><p>以后做数据提取的时候，可以把现在Scrapy Shell中测试，测试通过后再应用到代码中。 </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Scrapy-Shell&quot;&gt;&lt;a href=&quot;#Scrapy-Shell&quot; class=&quot;headerlink&quot; title=&quot;Scrapy Shell&quot;&gt;&lt;/a&gt;Scrapy Shell&lt;/h3&gt;&lt;p&gt;Scrapy终端是一个交互终端，我们可以在未启动spider
      
    
    </summary>
    
      <category term="爬虫" scheme="http://gavinliu4011.github.io/categories/%E7%88%AC%E8%99%AB/"/>
    
    
      <category term="Python" scheme="http://gavinliu4011.github.io/tags/Python/"/>
    
      <category term="爬虫" scheme="http://gavinliu4011.github.io/tags/%E7%88%AC%E8%99%AB/"/>
    
      <category term="Scrapy" scheme="http://gavinliu4011.github.io/tags/Scrapy/"/>
    
  </entry>
  
  <entry>
    <title>Scrapy 框架(一)之简单入门</title>
    <link href="http://gavinliu4011.github.io/post/eb531509.html"/>
    <id>http://gavinliu4011.github.io/post/eb531509.html</id>
    <published>2018-05-04T14:35:14.000Z</published>
    <updated>2018-05-04T13:50:02.356Z</updated>
    
    <content type="html"><![CDATA[<p>很长时间不用Scrapy框架，都快忘记应该怎么使用了，重拾Scrapy我复习了两天，把这两天的成果写成文章，供以后查阅</p><h2 id="Scrapy-框架"><a href="#Scrapy-框架" class="headerlink" title="Scrapy 框架"></a>Scrapy 框架</h2><ul><li>Scrapy是用纯Python实现一个为了爬取网站数据、提取结构性数据而编写的应用框架，用途非常广泛。</li><li>框架的力量，用户只需要定制开发几个模块就可以轻松的实现一个爬虫，用来抓取网页内容以及各种图片，非常之方便。</li><li>Scrapy 使用了 Twisted<code>[&#39;twɪstɪd]</code>(其主要对手是Tornado)异步网络框架来处理网络通讯，可以加快我们的下载速度，不用自己去实现异步框架，并且包含了各种中间件接口，可以灵活的完成各种需求。</li></ul><h3 id="Scrapy架构图"><a href="#Scrapy架构图" class="headerlink" title="Scrapy架构图"></a>Scrapy架构图</h3><blockquote><p><strong>注意：</strong>绿线是数据流向</p></blockquote><p><img src="../img/spider/scrapy_all.png" alt="img"></p><ul><li><code>Scrapy Engine(引擎)</code>: 负责<code>Spider</code>、<code>ItemPipeline</code>、<code>Downloader</code>、<code>Scheduler</code>中间的通讯，信号、数据传递等。</li><li><code>Scheduler(调度器)</code>: 它负责接受<code>引擎</code>发送过来的Request请求，并按照一定的方式进行整理排列，入队，当<code>引擎</code>需要时，交还给<code>引擎</code>。</li><li><code>Downloader（下载器）</code>：负责下载<code>Scrapy Engine(引擎)</code>发送的所有Requests请求，并将其获取到的Responses交还给<code>Scrapy Engine(引擎)</code>，由<code>引擎</code>交给<code>Spider</code>来处理，</li><li><code>Spider（爬虫）</code>：它负责处理所有Responses,从中分析提取数据，获取Item字段需要的数据，并将需要跟进的URL提交给<code>引擎</code>，再次进入<code>Scheduler(调度器)</code>，</li><li><code>Item Pipeline(管道)</code>：它负责处理<code>Spider</code>中获取到的Item，并进行进行后期处理（详细分析、过滤、存储等）的地方.</li><li><code>Downloader Middlewares（下载中间件）</code>：你可以当作是一个可以自定义扩展下载功能的组件。</li><li><code>Spider Middlewares（Spider中间件）</code>：你可以理解为是一个可以自定扩展和操作<code>引擎</code>和<code>Spider</code>中间<code>通信</code>的功能组件（比如进入<code>Spider</code>的Responses;和从<code>Spider</code>出去的Requests）</li></ul><h3 id="Scrapy的运作流程-我认为这是重点重点重点"><a href="#Scrapy的运作流程-我认为这是重点重点重点" class="headerlink" title="Scrapy的运作流程(我认为这是重点重点重点)"></a>Scrapy的运作流程(我认为这是重点重点重点)</h3><p>代码写好，程序开始运行…</p><ol><li><code>引擎</code>：Hi！<code>Spider</code>, 你要处理哪一个网站？</li><li><code>Spider</code>：老大要我处理xxxx.com。</li><li><code>引擎</code>：你把第一个需要处理的URL给我吧。</li><li><code>Spider</code>：给你，第一个URL是xxxx.com。</li><li><code>引擎</code>：Hi！<code>调度器</code>，我这有request请求你帮我排序入队一下。</li><li><code>调度器</code>：好的，正在处理你等一下。</li><li><code>引擎</code>：Hi！<code>调度器</code>，把你处理好的request请求给我。</li><li><code>调度器</code>：给你，这是我处理好的request</li><li><code>引擎</code>：Hi！下载器，你按照老大的<code>下载中间件</code>的设置帮我下载一下这个request请求</li><li><code>下载器</code>：好的！给你，这是下载好的东西。（如果失败：sorry，这个request下载失败了。然后<code>引擎</code>告诉<code>调度器</code>，这个request下载失败了，你记录一下，我们待会儿再下载）</li><li><code>引擎</code>：Hi！<code>Spider</code>，这是下载好的东西，并且已经按照老大的<code>下载中间件</code>处理过了，你自己处理一下（注意！这儿responses默认是交给<code>def parse()</code>这个函数处理的）</li><li><code>Spider</code>：（处理完毕数据之后对于需要跟进的URL），Hi！<code>引擎</code>，我这里有两个结果，这个是我需要跟进的URL，还有这个是我获取到的Item数据。</li><li><code>引擎</code>：Hi ！<code>管道</code> 我这儿有个item你帮我处理一下！<code>调度器</code>！这是需要跟进URL你帮我处理下。然后从第四步开始循环，直到获取完老大需要全部信息。</li><li><code>管道``调度器</code>：好的，现在就做！</li></ol><p><strong>注意！只有当调度器中不存在任何request了，整个程序才会停止，（也就是说，对于下载失败的URL，Scrapy也会重新下载。）</strong></p><h3 id="Scrapy的配置安装"><a href="#Scrapy的配置安装" class="headerlink" title="Scrapy的配置安装"></a>Scrapy的配置安装</h3><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install Scrapy</span><br></pre></td></tr></table></figure><p>安装过程中会安装如下一些包，在之前的安装过程中，偶尔会出现Twisted失败的话，需要自己手动去安装。</p><p><img src="../img/spider/spider_scrapy_pip.png" alt="img"></p><p>在此也先安装另外一个必备的包pywin32，如果不安装该包的话，在运行爬虫的时候可能会提示<strong>“ModuleNotFoundError: No module named ‘win32api’”</strong>，因为Python没有自带访问windows系统API的库的，需要下载第三方库。库的名称叫pywin32。可以去网站上下载，<a href="https://sourceforge.net/projects/pywin32/files/pywin32/Build%20221/" target="_blank" rel="noopener">下载地址</a> </p><p><img src="../img/spider/scrapy_win32api.png" alt="img"></p><p>按照自己电脑上的python版本，进行下载安装。安装的时候，先进入虚拟环境中，然后执行easy_install pywin32-221.win-amd64-py3.6.exe 命令即可将包安装在我们当前的虚拟环境中了。 </p><p><img src="../img/spider/easyinstall_win32api.png" alt="img"></p><p>**具体Scrapy安装流程参考：<a href="http://doc.scrapy.org/en/latest/intro/install.html#intro-install-platform-notes" target="_blank" rel="noopener">http://doc.scrapy.org/en/latest/intro/install.html#intro-install-platform-notes</a> 里面有各个平台的安装方法</p><h4 id="简单Scrapy-爬虫-一共需要4步："><a href="#简单Scrapy-爬虫-一共需要4步：" class="headerlink" title="简单Scrapy 爬虫 一共需要4步："></a>简单Scrapy 爬虫 一共需要4步：</h4><ul><li>新建项目 (scrapy startproject xxx)：新建一个新的爬虫项目</li><li>明确目标 （编写items.py）：明确你想要抓取的目标</li><li>制作爬虫 （spiders/xxspider.py）：制作爬虫开始爬取网页</li><li>存储内容 （pipelines.py）：设计管道存储爬取内容</li></ul><h3 id="入门案例"><a href="#入门案例" class="headerlink" title="入门案例"></a>入门案例</h3><h4 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h4><ul><li>在开始爬取之前，必须创建一个新的Scrapy项目。进入自定义的项目目录中，运行下列命令：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scrapy startproject mySpider</span><br></pre></td></tr></table></figure><ul><li>其中， mySpider 为项目名称，可以看到将会创建一个 mySpider 文件夹，目录结构大致如下：</li></ul><p><img src="../img/spider/7.2.png" alt="img"></p><p>下面来简单介绍一下各个主要文件的作用：</p><blockquote><p>scrapy.cfg ：项目的配置文件，主要为Scrapy命令行工具提供一个基础的配置信息。（真正爬虫相关的配置信息在settings.py文件中） </p><p>mySpider/ ：项目的Python模块，将会从这里引用代码</p><p>mySpider/items.py ：设置数据存储模板，用于结构化数据，如：Django的Model </p><p>mySpider/pipelines.py ：项目的管道文件</p><p>mySpider/settings.py ：项目的设置文件</p><p>mySpider/spiders/ ：存储爬虫代码目录</p></blockquote><h4 id="制作爬虫"><a href="#制作爬虫" class="headerlink" title="制作爬虫"></a>制作爬虫</h4><ul><li>在当前目录下输入命令，将在<code>mySpider/spider</code>目录下创建一个名为<code>qidian</code>的爬虫，并指定爬取域的范围：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scrapy genspider qidian www.qidian.com</span><br></pre></td></tr></table></figure><ul><li>打开 mySpider/spider目录里的 qidian.py，默认增加了下列代码:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import scrapy</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class QidianSpider(scrapy.Spider):</span><br><span class="line">    name = &apos;qidian&apos;</span><br><span class="line">    allowed_domains = [&apos;www.qidian.com&apos;]</span><br><span class="line">    start_urls = [&apos;http://www.qidian.com/&apos;]</span><br><span class="line"></span><br><span class="line">    def parse(self, response):</span><br><span class="line">        pass</span><br></pre></td></tr></table></figure><blockquote><p><strong>其实也可以由我们自行创建qidian.py并编写上面的代码，只不过使用命令可以免去编写固定代码的麻烦</strong></p></blockquote><p>要建立一个Spider， 你必须用scrapy.Spider类创建一个子类，并确定了三个强制的属性 和 一个方法。</p><ul><li><code>name = &quot;&quot;</code> ：这个爬虫的识别名称，必须是唯一的，在不同的爬虫必须定义不同的名字。</li><li><code>allow_domains = []</code> 是搜索的域名范围，也就是爬虫的约束区域，规定爬虫只爬取这个域名下的网页，不存在的URL会被忽略。</li><li><code>start_urls = []</code> ：爬取的URL元祖/列表。爬虫从这里开始抓取数据，所以，第一次下载的数据将会从这些urls开始。其他子URL将会从这些起始URL中继承性生成。</li><li><code>parse(self, response)</code> ：解析的方法，每个初始URL完成下载后将被调用，调用的时候传入从每一个URL传回的Response对象来作为唯一参数，主要作用如下：<ol><li>负责解析返回的网页数据(response.body)，提取结构化数据(生成item)</li><li>生成需要下一页的URL请求。</li></ol></li></ul><h5 id="将start-urls的值修改为需要爬取的第一个url"><a href="#将start-urls的值修改为需要爬取的第一个url" class="headerlink" title="将start_urls的值修改为需要爬取的第一个url"></a>将start_urls的值修改为需要爬取的第一个url</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">start_urls = [&apos;http://www.qidian.com/&apos;]</span><br></pre></td></tr></table></figure><h5 id="修改parse-方法"><a href="#修改parse-方法" class="headerlink" title="修改parse()方法"></a>修改parse()方法</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">def parse(self, response):</span><br><span class="line">    # 爬取时请求的url</span><br><span class="line">    current_url = response.url</span><br><span class="line"></span><br><span class="line">    # 返回的html</span><br><span class="line">    body = response.body</span><br><span class="line"></span><br><span class="line">    # 返回的html unicode编码</span><br><span class="line">    unicode_body = response.body_as_unicode()</span><br><span class="line">    res = Selector(response)</span><br><span class="line"></span><br><span class="line">    # 获取小说的分类信息</span><br><span class="line">    xiaoshuo_type = res.xpath(&apos;//*[@id=&quot;pin-nav&quot;]/div/div[1]/ul/li/a/text()&apos;).extract()</span><br><span class="line"></span><br><span class="line">    xiaoshuo_href = res.xpath(&apos;//*[@id=&quot;pin-nav&quot;]/div/div[1]/ul/li/a/@href&apos;).extract()</span><br><span class="line"></span><br><span class="line">    print(xiaoshuo_type, xiaoshuo_href)</span><br></pre></td></tr></table></figure><p>然后运行一下看看，在mySpider目录下执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scrapy crawl qidian</span><br></pre></td></tr></table></figure><p>是的，就是 qidian，看上面代码，它是 QidianSpider类的 name 属性，也就是使用 <code>scrapy genspider</code>命令的唯一爬虫名。</p><p>运行之后，如果打印的日志出现 <code>[scrapy] INFO: Spider closed (finished)</code>，代表执行完成。</p><p>执行流程：</p><blockquote><p>name: spider对应不同的name</p><p>start_urls:是spider抓取网页的起始点，可以包括多个url。</p><p>parse()：spider抓到一个网页以后默认调用的callback，避免使用这个名字来定义自己的方法。当spider拿到url的内容以后，会调用parse方法，并且传递一个response参数给它，response包含了抓到的网页的内容，在parse方法里，你可以从抓到的网页里面解析数据。</p></blockquote><p>运行结果：</p><p><img src="../img/spider/scrapy_qidian_type.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;很长时间不用Scrapy框架，都快忘记应该怎么使用了，重拾Scrapy我复习了两天，把这两天的成果写成文章，供以后查阅&lt;/p&gt;
&lt;h2 id=&quot;Scrapy-框架&quot;&gt;&lt;a href=&quot;#Scrapy-框架&quot; class=&quot;headerlink&quot; title=&quot;Scrapy 
      
    
    </summary>
    
      <category term="爬虫" scheme="http://gavinliu4011.github.io/categories/%E7%88%AC%E8%99%AB/"/>
    
    
      <category term="Python" scheme="http://gavinliu4011.github.io/tags/Python/"/>
    
      <category term="爬虫" scheme="http://gavinliu4011.github.io/tags/%E7%88%AC%E8%99%AB/"/>
    
      <category term="Scrapy" scheme="http://gavinliu4011.github.io/tags/Scrapy/"/>
    
  </entry>
  
  <entry>
    <title>爬虫糗事百科实例</title>
    <link href="http://gavinliu4011.github.io/post/f825a662.html"/>
    <id>http://gavinliu4011.github.io/post/f825a662.html</id>
    <published>2018-05-02T23:18:08.000Z</published>
    <updated>2018-05-02T15:20:16.933Z</updated>
    
    <content type="html"><![CDATA[<h2 id="糗事百科实例："><a href="#糗事百科实例：" class="headerlink" title="糗事百科实例："></a>糗事百科实例：</h2><p>爬取糗事百科段子，假设页面的URL是 <a href="http://www.qiushibaike.com/8hr/page/1" target="_blank" rel="noopener">http://www.qiushibaike.com/8hr/page/1</a></p><h3 id="要求："><a href="#要求：" class="headerlink" title="要求："></a>要求：</h3><ol><li>使用requests获取页面信息，用XPath / re 做数据提取</li><li>获取每个帖子里的<code>用户头像链接</code>、<code>用户姓名</code>、<code>段子内容</code>、<code>点赞次数</code>和<code>评论次数</code></li><li>保存到 json 文件内</li></ol><h3 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line"></span><br><span class="line">page = <span class="number">1</span></span><br><span class="line">url = <span class="string">'http://www.qiushibaike.com/8hr/page/'</span> + str(page)</span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">'User-Agent'</span>: <span class="string">'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/52.0.2743.116 Safari/537.36'</span>,</span><br><span class="line">    <span class="string">'Accept-Language'</span>: <span class="string">'zh-CN,zh;q=0.8'</span>&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_page</span><span class="params">()</span>:</span></span><br><span class="line">    response = requests.get(url, headers=headers)</span><br><span class="line">    <span class="comment"># response.encoding = response.apparent_encoding</span></span><br><span class="line">    <span class="keyword">if</span> response.status_code == <span class="number">200</span>:</span><br><span class="line">        <span class="keyword">return</span> response.text</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse</span><span class="params">()</span>:</span></span><br><span class="line">    resHtml = get_page()</span><br><span class="line">    <span class="keyword">if</span> resHtml <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    html = etree.HTML(resHtml)</span><br><span class="line">    result = html.xpath(<span class="string">'//div[contains(@id,"qiushi_tag")]'</span>)</span><br><span class="line">    items = []</span><br><span class="line">    <span class="keyword">for</span> site <span class="keyword">in</span> result:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            item = &#123;&#125;</span><br><span class="line"></span><br><span class="line">            imgurl = site.xpath(<span class="string">'./div/a/img/@src'</span>)[<span class="number">0</span>]</span><br><span class="line">            <span class="comment"># username = site.xpath('./div/a/@title')[0]</span></span><br><span class="line">            username = site.xpath(<span class="string">'.//h2'</span>)[<span class="number">0</span>].text</span><br><span class="line">            content = site.xpath(<span class="string">'.//div[@class="content"]/span'</span>)[<span class="number">0</span>].text.strip()</span><br><span class="line">            <span class="comment"># 投票次数</span></span><br><span class="line">            vote = site.xpath(<span class="string">'.//i'</span>)[<span class="number">0</span>].text</span><br><span class="line">            <span class="comment"># print site.xpath('.//*[@class="number"]')[0].text</span></span><br><span class="line">            <span class="comment"># 评论信息</span></span><br><span class="line">            comments = site.xpath(<span class="string">'.//i'</span>)[<span class="number">1</span>].text</span><br><span class="line"></span><br><span class="line">            item[<span class="string">'imgurl'</span>] = imgurl</span><br><span class="line">            item[<span class="string">'username'</span>] = username</span><br><span class="line">            item[<span class="string">'content'</span>] = content</span><br><span class="line">            item[<span class="string">'vote'</span>] = vote</span><br><span class="line">            item[<span class="string">'comments'</span>] = comments</span><br><span class="line">            print(imgurl, username, content, vote, comments)</span><br><span class="line">            items.append(item)</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            print(e)</span><br><span class="line">    <span class="keyword">return</span> items</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">save_items</span><span class="params">(items)</span>:</span></span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">'qiushibaike.json'</span>, <span class="string">'w'</span>, encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(json.dumps(items))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    items = parse()</span><br><span class="line">    save_items(items)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;糗事百科实例：&quot;&gt;&lt;a href=&quot;#糗事百科实例：&quot; class=&quot;headerlink&quot; title=&quot;糗事百科实例：&quot;&gt;&lt;/a&gt;糗事百科实例：&lt;/h2&gt;&lt;p&gt;爬取糗事百科段子，假设页面的URL是 &lt;a href=&quot;http://www.qiushibaike
      
    
    </summary>
    
      <category term="爬虫" scheme="http://gavinliu4011.github.io/categories/%E7%88%AC%E8%99%AB/"/>
    
    
      <category term="Python" scheme="http://gavinliu4011.github.io/tags/Python/"/>
    
      <category term="爬虫" scheme="http://gavinliu4011.github.io/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>BeautifulSoup实例</title>
    <link href="http://gavinliu4011.github.io/post/f484e02f.html"/>
    <id>http://gavinliu4011.github.io/post/f484e02f.html</id>
    <published>2018-05-02T22:34:43.000Z</published>
    <updated>2018-05-02T15:20:16.930Z</updated>
    
    <content type="html"><![CDATA[<p>前面我们已经简单的使用BeautifulSoup，接下来我们以腾讯社招页面来做演示：<a href="https://hr.tencent.com/position.php?&amp;start=10#a" target="_blank" rel="noopener">https://hr.tencent.com/position.php?&amp;start=10#a</a></p><p>使用BeautifuSoup4解析器，将招聘网页上的职位名称、职位类别、招聘人数、工作地点、发布时间，以及每个职位详情的点击链接存储出来。 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"><span class="keyword">import</span> json  <span class="comment"># 使用了json格式存储</span></span><br><span class="line"></span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">'User-Agent'</span>: <span class="string">'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/52.0.2743.116 Safari/537.36'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">tencent</span><span class="params">()</span>:</span></span><br><span class="line">    url = <span class="string">'https://hr.tencent.com/position.php?&amp;start=10#a'</span></span><br><span class="line">    response = requests.get(url, headers=headers)</span><br><span class="line">    html = response.text</span><br><span class="line"></span><br><span class="line">    html = BeautifulSoup(html, <span class="string">'lxml'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建CSS选择器</span></span><br><span class="line">    result = html.select(<span class="string">'tr[class="even"]'</span>)</span><br><span class="line">    result2 = html.select(<span class="string">'tr[class="odd"]'</span>)</span><br><span class="line">    result += result2</span><br><span class="line"></span><br><span class="line">    items = []</span><br><span class="line">    <span class="keyword">for</span> site <span class="keyword">in</span> result:</span><br><span class="line">        item = &#123;&#125;</span><br><span class="line"></span><br><span class="line">        name = site.select(<span class="string">'td a'</span>)[<span class="number">0</span>].get_text()</span><br><span class="line">        detailLink = site.select(<span class="string">'td a'</span>)[<span class="number">0</span>].attrs[<span class="string">'href'</span>]</span><br><span class="line">        catalog = site.select(<span class="string">'td'</span>)[<span class="number">1</span>].get_text()</span><br><span class="line">        recruitNumber = site.select(<span class="string">'td'</span>)[<span class="number">2</span>].get_text()</span><br><span class="line">        workLocation = site.select(<span class="string">'td'</span>)[<span class="number">3</span>].get_text()</span><br><span class="line">        publishTime = site.select(<span class="string">'td'</span>)[<span class="number">4</span>].get_text()</span><br><span class="line"></span><br><span class="line">        item[<span class="string">'name'</span>] = name</span><br><span class="line">        item[<span class="string">'detailLink'</span>] = url + detailLink</span><br><span class="line">        item[<span class="string">'catalog'</span>] = catalog</span><br><span class="line">        item[<span class="string">'recruitNumber'</span>] = recruitNumber</span><br><span class="line">        item[<span class="string">'publishTime'</span>] = publishTime</span><br><span class="line"></span><br><span class="line">        items.append(item)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 禁用ascii编码，按utf-8编码</span></span><br><span class="line">    line = json.dumps(items, ensure_ascii=<span class="keyword">False</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">'tencent.json'</span>, <span class="string">'w'</span>, encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(line)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    tencent()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;前面我们已经简单的使用BeautifulSoup，接下来我们以腾讯社招页面来做演示：&lt;a href=&quot;https://hr.tencent.com/position.php?&amp;amp;start=10#a&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;ht
      
    
    </summary>
    
      <category term="爬虫" scheme="http://gavinliu4011.github.io/categories/%E7%88%AC%E8%99%AB/"/>
    
    
      <category term="Python" scheme="http://gavinliu4011.github.io/tags/Python/"/>
    
      <category term="爬虫" scheme="http://gavinliu4011.github.io/tags/%E7%88%AC%E8%99%AB/"/>
    
      <category term="BeautifulSoup" scheme="http://gavinliu4011.github.io/tags/BeautifulSoup/"/>
    
  </entry>
  
  <entry>
    <title>BeautifulSoup的使用</title>
    <link href="http://gavinliu4011.github.io/post/cd406da8.html"/>
    <id>http://gavinliu4011.github.io/post/cd406da8.html</id>
    <published>2018-05-02T20:24:49.000Z</published>
    <updated>2018-05-02T15:20:16.926Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>今天介绍一个强大的解析工具，叫做 BeautiSoup，它就是借助网页的结构和属性等特性来解析网页的工具，有了它我们不用再去写一些复杂的正则，只需要简单的几条语句就可以完成网页中某个元素的提取。 </p><p>在<a href="https://germey.gitbooks.io/python3webspider/4.2-BeautifulSoup%E7%9A%84%E4%BD%BF%E7%94%A8.html" target="_blank" rel="noopener">崔庆才</a>老师那里找了一遍很详细的BeautifulSoup的使用</p><blockquote><p>原文地址：<a href="https://germey.gitbooks.io/python3webspider/4.2-BeautifulSoup%E7%9A%84%E4%BD%BF%E7%94%A8.html" target="_blank" rel="noopener">https://germey.gitbooks.io/python3webspider/4.2-BeautifulSoup%E7%9A%84%E4%BD%BF%E7%94%A8.html</a></p></blockquote><h3 id="BeautifulSoup简介"><a href="#BeautifulSoup简介" class="headerlink" title="BeautifulSoup简介"></a>BeautifulSoup简介</h3><p>简单来说，BeautifulSoup 就是 Python 的一个 HTML 或 XML 的解析库，我们可以用它来方便地从网页中提取数据，官方的解释如下：</p><blockquote><p>BeautifulSoup提供一些简单的、Python式的函数用来处理导航、搜索、修改分析树等功能。它是一个工具箱，通过解析文档为用户提供需要抓取的数据，因为简单，所以不需要多少代码就可以写出一个完整的应用程序。 BeautifulSoup 自动将输入文档转换为 Unicode 编码，输出文档转换为 utf-8 编码。你不需要考虑编码方式，除非文档没有指定一个编码方式，这时你仅仅需要说明一下原始编码方式就可以了。 BeautifulSoup 已成为和 lxml、html6lib 一样出色的 Python 解释器，为用户灵活地提供不同的解析策略或强劲的速度。</p></blockquote><p>所以说，利用它我们可以省去很多繁琐的提取工作，提高解析效率。</p><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><h4 id="Pip安装"><a href="#Pip安装" class="headerlink" title="Pip安装"></a>Pip安装</h4><p>目前 BeautifulSoup 的最新版本是 4.x 版本，之前的版本已经停止开发了，推荐使用 Pip 来安装，安装命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install beautifulsoup4</span><br></pre></td></tr></table></figure><p>命令执行完毕之后即可完成安装。</p><h4 id="Wheel安装"><a href="#Wheel安装" class="headerlink" title="Wheel安装"></a>Wheel安装</h4><p>当然也可以从 PyPi 下载 Wheel 文件安装，链接如下： <a href="https://pypi.python.org/pypi/beautifulsoup4" target="_blank" rel="noopener">https://pypi.python.org/pypi/beautifulsoup4</a></p><p>然后 Pip 安装 Wheel 文件即可。</p><h3 id="解析器"><a href="#解析器" class="headerlink" title="解析器"></a>解析器</h3><p>BeautifulSoup 在解析的时候实际上是依赖于解析器的，它除了支持 Python 标准库中的 HTML 解析器，还支持一些第三方的解析器比如 LXML，下面我们对 BeautifulSoup 支持的解析器及它们的一些优缺点做一个简单的对比。</p><table><thead><tr><th>解析器</th><th>使用方法</th><th>优势</th><th>劣势</th></tr></thead><tbody><tr><td>Python标准库</td><td>BeautifulSoup(markup, “html.parser”)</td><td>Python的内置标准库、执行速度适中 、文档容错能力强</td><td>Python 2.7.3 or 3.2.2)前的版本中文容错能力差</td></tr><tr><td>LXML HTML 解析器</td><td>BeautifulSoup(markup, “lxml”)</td><td>速度快、文档容错能力强</td><td>需要安装C语言库</td></tr><tr><td>LXML XML 解析器</td><td>BeautifulSoup(markup, “xml”)</td><td>速度快、唯一支持XML的解析器</td><td>需要安装C语言库</td></tr><tr><td>html5lib</td><td>BeautifulSoup(markup, “html5lib”)</td><td>最好的容错性、以浏览器的方式解析文档、生成 HTML5 格式的文档</td><td>速度慢、不依赖外部扩展</td></tr></tbody></table><p>所以通过以上对比可以看出，LXML 这个解析器有解析 HTML 和 XML 的功能，而且速度快，容错能力强，所以推荐使用这个解析器来进行解析。</p><p>使用 LXML 这个解析器，在初始化 BeautifulSoup 的时候我们可以把第二个参数改为 lxml 即可，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">from bs4 import BeautifulSoup</span><br><span class="line">soup = BeautifulSoup(&apos;&lt;p&gt;Hello&lt;/p&gt;&apos;, &apos;lxml&apos;)</span><br><span class="line">print(soup.p.string)</span><br></pre></td></tr></table></figure><p>后面 BeautifulSoup 的用法实例也统一用这个解析器来演示。</p><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><p>下面我们首先用一个实例来感受一下 BeautifulSoup 的基本使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">html = &quot;&quot;&quot;</span><br><span class="line">&lt;html&gt;&lt;head&gt;&lt;title&gt;The Dormouse&apos;s story&lt;/title&gt;&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;p class=&quot;title&quot; name=&quot;dromouse&quot;&gt;&lt;b&gt;The Dormouse&apos;s story&lt;/b&gt;&lt;/p&gt;</span><br><span class="line">&lt;p class=&quot;story&quot;&gt;Once upon a time there were three little sisters; and their names were</span><br><span class="line">&lt;a href=&quot;http://example.com/elsie&quot; class=&quot;sister&quot; id=&quot;link1&quot;&gt;&lt;!-- Elsie --&gt;&lt;/a&gt;,</span><br><span class="line">&lt;a href=&quot;http://example.com/lacie&quot; class=&quot;sister&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt; and</span><br><span class="line">&lt;a href=&quot;http://example.com/tillie&quot; class=&quot;sister&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;;</span><br><span class="line">and they lived at the bottom of a well.&lt;/p&gt;</span><br><span class="line">&lt;p class=&quot;story&quot;&gt;...&lt;/p&gt;</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">from bs4 import BeautifulSoup</span><br><span class="line">soup = BeautifulSoup(html, &apos;lxml&apos;)</span><br><span class="line">print(soup.prettify())</span><br><span class="line">print(soup.title.string)</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line"> &lt;head&gt;</span><br><span class="line">  &lt;title&gt;</span><br><span class="line">   The Dormouse&apos;s story</span><br><span class="line">  &lt;/title&gt;</span><br><span class="line"> &lt;/head&gt;</span><br><span class="line"> &lt;body&gt;</span><br><span class="line">  &lt;p class=&quot;title&quot; name=&quot;dromouse&quot;&gt;</span><br><span class="line">   &lt;b&gt;</span><br><span class="line">    The Dormouse&apos;s story</span><br><span class="line">   &lt;/b&gt;</span><br><span class="line">  &lt;/p&gt;</span><br><span class="line">  &lt;p class=&quot;story&quot;&gt;</span><br><span class="line">   Once upon a time there were three little sisters; and their names were</span><br><span class="line">   &lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;</span><br><span class="line">    &lt;!-- Elsie --&gt;</span><br><span class="line">   &lt;/a&gt;</span><br><span class="line">   ,</span><br><span class="line">   &lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;</span><br><span class="line">    Lacie</span><br><span class="line">   &lt;/a&gt;</span><br><span class="line">   and</span><br><span class="line">   &lt;a class=&quot;sister&quot; href=&quot;http://example.com/tillie&quot; id=&quot;link3&quot;&gt;</span><br><span class="line">    Tillie</span><br><span class="line">   &lt;/a&gt;</span><br><span class="line">   ;</span><br><span class="line">and they lived at the bottom of a well.</span><br><span class="line">  &lt;/p&gt;</span><br><span class="line">  &lt;p class=&quot;story&quot;&gt;</span><br><span class="line">   ...</span><br><span class="line">  &lt;/p&gt;</span><br><span class="line"> &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line">The Dormouse&apos;s story</span><br></pre></td></tr></table></figure><p>首先我们声明了一个变量 html，它是一个 HTML 字符串，但是注意到，它并不是一个完整的 HTML 字符串，body 和 html 节点都没有闭合，但是我们将它当作第一个参数传给 BeautifulSoup 对象，第二个参数传入的是解析器的类型，在这里我们使用 lxml，这样就完成了 BeaufulSoup 对象的初始化，将它赋值给 soup 这个变量。</p><p>那么接下来我们就可以通过调用 soup 的各个方法和属性对这串 HTM L代码解析了。</p><p>我们首先调用了 prettify() 方法，这个方法可以把要解析的字符串以标准的缩进格式输出，在这里注意到输出结果里面包含了 body 和 html 节点，也就是说对于不标准的 HTML 字符串 BeautifulSoup 可以自动更正格式，这一步实际上不是由 prettify() 方法做的，这个更正实际上在初始化 BeautifulSoup 时就完成了。</p><p>然后我们调用了 soup.title.string ，这个实际上是输出了 HTML 中 title 节点的文本内容。所以 soup.title 就可以选择出 HTML 中的 title 节点，再调用 string 属性就可以得到里面的文本了，所以我们就可以通过简单地调用几个属性就可以完成文本的提取了，是不是非常方便？</p><h3 id="节点选择器"><a href="#节点选择器" class="headerlink" title="节点选择器"></a>节点选择器</h3><p>刚才我们选择元素的时候直接通过调用节点的名称就可以选择节点元素了，然后再调用 string 属性就可以得到节点内的文本了，这种选择方式速度非常快，如果单个节点结构话层次非常清晰，可以选用这种方式来解析。</p><h4 id="选择元素"><a href="#选择元素" class="headerlink" title="选择元素"></a>选择元素</h4><p>下面我们再用一个例子详细说明一下它的选择方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">html = &quot;&quot;&quot;</span><br><span class="line">&lt;html&gt;&lt;head&gt;&lt;title&gt;The Dormouse&apos;s story&lt;/title&gt;&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;p class=&quot;title&quot; name=&quot;dromouse&quot;&gt;&lt;b&gt;The Dormouse&apos;s story&lt;/b&gt;&lt;/p&gt;</span><br><span class="line">&lt;p class=&quot;story&quot;&gt;Once upon a time there were three little sisters; and their names were</span><br><span class="line">&lt;a href=&quot;http://example.com/elsie&quot; class=&quot;sister&quot; id=&quot;link1&quot;&gt;&lt;!-- Elsie --&gt;&lt;/a&gt;,</span><br><span class="line">&lt;a href=&quot;http://example.com/lacie&quot; class=&quot;sister&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt; and</span><br><span class="line">&lt;a href=&quot;http://example.com/tillie&quot; class=&quot;sister&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;;</span><br><span class="line">and they lived at the bottom of a well.&lt;/p&gt;</span><br><span class="line">&lt;p class=&quot;story&quot;&gt;...&lt;/p&gt;</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">from bs4 import BeautifulSoup</span><br><span class="line">soup = BeautifulSoup(html, &apos;lxml&apos;)</span><br><span class="line">print(soup.title)</span><br><span class="line">print(type(soup.title))</span><br><span class="line">print(soup.title.string)</span><br><span class="line">print(soup.head)</span><br><span class="line">print(soup.p)</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;title&gt;The Dormouse&apos;s story&lt;/title&gt;</span><br><span class="line">&lt;class &apos;bs4.element.Tag&apos;&gt;</span><br><span class="line">The Dormouse&apos;s story</span><br><span class="line">&lt;head&gt;&lt;title&gt;The Dormouse&apos;s story&lt;/title&gt;&lt;/head&gt;</span><br><span class="line">&lt;p class=&quot;title&quot; name=&quot;dromouse&quot;&gt;&lt;b&gt;The Dormouse&apos;s story&lt;/b&gt;&lt;/p&gt;</span><br></pre></td></tr></table></figure><p>在这里我们依然选用了刚才的 HTML 代码，我们首先打印输出了 title 节点的选择结果，输出结果正是 title 节点加里面的文字内容。接下来输出了它的类型，是 bs4.element.Tag 类型，这是 BeautifulSoup 中的一个重要的数据结构，经过选择器选择之后，选择结果都是这种 Tag 类型，它具有一些属性比如 string 属性，调用 Tag 的 string 属性，就可以得到节点的文本内容了，所以接下来的输出结果正是节点的文本内容。</p><p>接下来我们又尝试选择了 head 节点，结果也是节点加其内部的所有内容，再接下来选择了 p 节点，不过这次情况比较特殊，我们发现结果是第一个 p 节点的内容，后面的几个 p 节点并没有选择到，也就是说，当有多个节点时，这种选择方式只会选择到第一个匹配的节点，其他的后面的节点都会忽略。</p><h4 id="提取信息"><a href="#提取信息" class="headerlink" title="提取信息"></a>提取信息</h4><p>在上面我们演示了调用 string 属性来获取文本的值，那我们要获取节点属性值怎么办呢？获取节点名怎么办呢？下面我们来统一梳理一下信息的提取方式</p><h5 id="获取名称"><a href="#获取名称" class="headerlink" title="获取名称"></a>获取名称</h5><p>可以利用 name 属性来获取节点的名称。还是以上面的文本为例，我们选取 title 节点，然后调用 name 属性就可以得到节点名称。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(soup.title.name)</span><br></pre></td></tr></table></figure><p>运行结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">title</span><br></pre></td></tr></table></figure><h5 id="获取属性"><a href="#获取属性" class="headerlink" title="获取属性"></a>获取属性</h5><p>每个节点可能有多个属性，比如 id，class 等等，我们选择到这个节点元素之后，可以调用 attrs 获取所有属性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(soup.p.attrs)</span><br><span class="line">print(soup.p.attrs[&apos;name&apos;])</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;&apos;class&apos;: [&apos;title&apos;], &apos;name&apos;: &apos;dromouse&apos;&#125;</span><br><span class="line">dromouse</span><br></pre></td></tr></table></figure><p>可以看到 attrs 的返回结果是字典形式，把选择的节点的所有属性和属性值组合成一个字典，接下来如果要获取 name 属性，就相当于从字典中获取某个键值，只需要用中括号加属性名称就可以得到结果了，比如获取 name 属性就可以通过 attrs[‘name’] 得到相应的属性值。</p><p>其实这样的写法还有点繁琐，还有一种更简单的获取方式，我们可以不用写 attrs，直接节点元素后面加中括号，传入属性名就可以达到属性值了，样例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(soup.p[&apos;name&apos;])</span><br><span class="line">print(soup.p[&apos;class&apos;])</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dromouse</span><br><span class="line">[&apos;title&apos;]</span><br></pre></td></tr></table></figure><p>在这里注意到有的返回结果是字符串，有的返回结果是字符串组成的列表。比如 name 属性的值是唯一的，返回的结果就是单个字符串，而对于 class，一个节点元素可能由多个 class，所以返回的是列表，所以在实际处理过程中要注意判断类型。</p><h5 id="获取内容"><a href="#获取内容" class="headerlink" title="获取内容"></a>获取内容</h5><p>可以利用 string 属性获取节点元素包含的文本内容，比如上面的文本我们获取第一个 p 节点的文本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(soup.p.string)</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The Dormouse&apos;s story</span><br></pre></td></tr></table></figure><p>再次注意一下这里选择到的 p 节点是第一个 p 节点，获取的文本也就是第一个 p 节点里面的文本。</p><h4 id="嵌套选择"><a href="#嵌套选择" class="headerlink" title="嵌套选择"></a>嵌套选择</h4><p>在上面的例子中我们知道每一个返回结果都是 bs4.element.Tag 类型，它同样可以继续调用节点进行下一步的选择，比如我们获取了 head 节点元素，我们可以继续调用 head 来选取其内部的 head 节点元素。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">html = &quot;&quot;&quot;</span><br><span class="line">&lt;html&gt;&lt;head&gt;&lt;title&gt;The Dormouse&apos;s story&lt;/title&gt;&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">from bs4 import BeautifulSoup</span><br><span class="line">soup = BeautifulSoup(html, &apos;lxml&apos;)</span><br><span class="line">print(soup.head.title)</span><br><span class="line">print(type(soup.head.title))</span><br><span class="line">print(soup.head.title.string)</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;title&gt;The Dormouse&apos;s story&lt;/title&gt;</span><br><span class="line">&lt;class &apos;bs4.element.Tag&apos;&gt;</span><br><span class="line">The Dormouse&apos;s story</span><br></pre></td></tr></table></figure><p>第一行结果是我们调用了 head 之后再次调用了 title 来选择的 title 节点元素，然后我们紧接着打印输出了它的类型，可以看到它仍然是 bs4.element.Tag 类型，也就是说我们在 Tag 类型的基础上再次选择得到的依然还是 Tag 类型，每次返回的结果都相同，所以这样我们就可以这样做嵌套的选择了。</p><p>最后输出了一下它的 string 属性，也就是节点里的文本内容。</p><h4 id="关联选择"><a href="#关联选择" class="headerlink" title="关联选择"></a>关联选择</h4><p>我们在做选择的时候有时候不能做到一步就可以选择到想要的节点元素，有时候在选择的时候需要先选中某一个节点元素，然后以它为基准再选择它的子节点、父节点、兄弟节点等等。所以在这里我们就介绍下如何来选择这些节点元素。</p><h5 id="子节点和子孙节点"><a href="#子节点和子孙节点" class="headerlink" title="子节点和子孙节点"></a>子节点和子孙节点</h5><p>选取到了一个节点元素之后，如果想要获取它的直接子节点可以调用 contents 属性，我们用一个实例来感受一下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">html = &quot;&quot;&quot;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;head&gt;</span><br><span class="line">        &lt;title&gt;The Dormouse&apos;s story&lt;/title&gt;</span><br><span class="line">    &lt;/head&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">        &lt;p class=&quot;story&quot;&gt;</span><br><span class="line">            Once upon a time there were three little sisters; and their names were</span><br><span class="line">            &lt;a href=&quot;http://example.com/elsie&quot; class=&quot;sister&quot; id=&quot;link1&quot;&gt;</span><br><span class="line">                &lt;span&gt;Elsie&lt;/span&gt;</span><br><span class="line">            &lt;/a&gt;</span><br><span class="line">            &lt;a href=&quot;http://example.com/lacie&quot; class=&quot;sister&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt; </span><br><span class="line">            and</span><br><span class="line">            &lt;a href=&quot;http://example.com/tillie&quot; class=&quot;sister&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;</span><br><span class="line">            and they lived at the bottom of a well.</span><br><span class="line">        &lt;/p&gt;</span><br><span class="line">        &lt;p class=&quot;story&quot;&gt;...&lt;/p&gt;</span><br><span class="line">&quot;&quot;&quot;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[&apos;\n            Once upon a time there were three little sisters; and their names were\n            &apos;, &lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;</span><br><span class="line">&lt;span&gt;Elsie&lt;/span&gt;</span><br><span class="line">&lt;/a&gt;, &apos;\n&apos;, &lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt;, &apos; \n            and\n            &apos;, &lt;a class=&quot;sister&quot; href=&quot;http://example.com/tillie&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;, &apos;\n            and they lived at the bottom of a well.\n        &apos;]</span><br></pre></td></tr></table></figure><p>返回的结果是列表形式，p 节点里面既包含文本，又包含节点，返回的结果会将他们以列表形式都统一返回。</p><p>注意得到的列表的每一个元素都是 p 节点的直接子节点，比如第一个 a 节点里面包含了一层 span 节点，这个就相当于孙子节点了，但是返回结果中并没有单独把 span 节点选出来作为结果的一部分，所以说 contents 属性得到的结果是直接子节点的列表。</p><p>同样地我们可以调用 children 属性，得到相应的结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">from bs4 import BeautifulSoup</span><br><span class="line">soup = BeautifulSoup(html, &apos;lxml&apos;)</span><br><span class="line">print(soup.p.children)</span><br><span class="line">for i, child in enumerate(soup.p.children):</span><br><span class="line">    print(i, child)</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;list_iterator object at 0x1064f7dd8&gt;</span><br><span class="line">0 </span><br><span class="line">            Once upon a time there were three little sisters; and their names were</span><br><span class="line"></span><br><span class="line">1 &lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;</span><br><span class="line">&lt;span&gt;Elsie&lt;/span&gt;</span><br><span class="line">&lt;/a&gt;</span><br><span class="line">2 </span><br><span class="line"></span><br><span class="line">3 &lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt;</span><br><span class="line">4  </span><br><span class="line">            and</span><br><span class="line"></span><br><span class="line">5 &lt;a class=&quot;sister&quot; href=&quot;http://example.com/tillie&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;</span><br><span class="line">6 </span><br><span class="line">            and they lived at the bottom of a well.</span><br></pre></td></tr></table></figure><p>还是同样的 HTML 文本，在这里我们调用了 children 属性来进行选择，返回结果可以看到是生成器类型，所以接下来我们用 for 循环输出了一下相应的内容，内容其实是一样的，只不过 children 返回的是生成器类型，而 contents 返回的是列表类型。</p><p>如果我们要得到所有的子孙节点的话可以调用 descendants 属性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">from bs4 import BeautifulSoup</span><br><span class="line">soup = BeautifulSoup(html, &apos;lxml&apos;)</span><br><span class="line">print(soup.p.descendants)</span><br><span class="line">for i, child in enumerate(soup.p.descendants):</span><br><span class="line">    print(i, child)</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;generator object descendants at 0x10650e678&gt;</span><br><span class="line">0 </span><br><span class="line">            Once upon a time there were three little sisters; and their names were</span><br><span class="line"></span><br><span class="line">1 &lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;</span><br><span class="line">&lt;span&gt;Elsie&lt;/span&gt;</span><br><span class="line">&lt;/a&gt;</span><br><span class="line">2 </span><br><span class="line"></span><br><span class="line">3 &lt;span&gt;Elsie&lt;/span&gt;</span><br><span class="line">4 Elsie</span><br><span class="line">5 </span><br><span class="line"></span><br><span class="line">6 </span><br><span class="line"></span><br><span class="line">7 &lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt;</span><br><span class="line">8 Lacie</span><br><span class="line">9  </span><br><span class="line">            and</span><br><span class="line"></span><br><span class="line">10 &lt;a class=&quot;sister&quot; href=&quot;http://example.com/tillie&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;</span><br><span class="line">11 Tillie</span><br><span class="line">12 </span><br><span class="line">            and they lived at the bottom of a well.</span><br></pre></td></tr></table></figure><p>返回结果还是生成器，遍历输出一下可以看到这次的输出结果就包含了 span 节点，descendants 会递归地查询所有子节点，得到的是所有的子孙节点。</p><h5 id="父节点和祖先节点"><a href="#父节点和祖先节点" class="headerlink" title="父节点和祖先节点"></a>父节点和祖先节点</h5><p>如果要获取某个节点元素的父节点，可以调用 parent 属性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">html = &quot;&quot;&quot;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;head&gt;</span><br><span class="line">        &lt;title&gt;The Dormouse&apos;s story&lt;/title&gt;</span><br><span class="line">    &lt;/head&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">        &lt;p class=&quot;story&quot;&gt;</span><br><span class="line">            Once upon a time there were three little sisters; and their names were</span><br><span class="line">            &lt;a href=&quot;http://example.com/elsie&quot; class=&quot;sister&quot; id=&quot;link1&quot;&gt;</span><br><span class="line">                &lt;span&gt;Elsie&lt;/span&gt;</span><br><span class="line">            &lt;/a&gt;</span><br><span class="line">        &lt;/p&gt;</span><br><span class="line">        &lt;p class=&quot;story&quot;&gt;...&lt;/p&gt;</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">from bs4 import BeautifulSoup</span><br><span class="line">soup = BeautifulSoup(html, &apos;lxml&apos;)</span><br><span class="line">print(soup.a.parent)</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;p class=&quot;story&quot;&gt;</span><br><span class="line">            Once upon a time there were three little sisters; and their names were</span><br><span class="line">            &lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;</span><br><span class="line">&lt;span&gt;Elsie&lt;/span&gt;</span><br><span class="line">&lt;/a&gt;</span><br><span class="line">&lt;/p&gt;</span><br></pre></td></tr></table></figure><p>在这里我们选择的是第一个 a 节点的父节点元素，很明显它的父节点是 p 节点，输出结果便是 p 节点及其内部的内容。</p><p>注意到这里输出的仅仅是 a 节点的直接父节点，而没有再向外寻找父节点的祖先节点，如果我们要想获取所有的祖先节点，可以调用 parents 属性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">html = &quot;&quot;&quot;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">        &lt;p class=&quot;story&quot;&gt;</span><br><span class="line">            &lt;a href=&quot;http://example.com/elsie&quot; class=&quot;sister&quot; id=&quot;link1&quot;&gt;</span><br><span class="line">                &lt;span&gt;Elsie&lt;/span&gt;</span><br><span class="line">            &lt;/a&gt;</span><br><span class="line">        &lt;/p&gt;</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">from bs4 import BeautifulSoup</span><br><span class="line">soup = BeautifulSoup(html, &apos;lxml&apos;)</span><br><span class="line">print(type(soup.a.parents))</span><br><span class="line">print(list(enumerate(soup.a.parents)))</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;class &apos;generator&apos;&gt;</span><br><span class="line">[(0, &lt;p class=&quot;story&quot;&gt;</span><br><span class="line">&lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;</span><br><span class="line">&lt;span&gt;Elsie&lt;/span&gt;</span><br><span class="line">&lt;/a&gt;</span><br><span class="line">&lt;/p&gt;), (1, &lt;body&gt;</span><br><span class="line">&lt;p class=&quot;story&quot;&gt;</span><br><span class="line">&lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;</span><br><span class="line">&lt;span&gt;Elsie&lt;/span&gt;</span><br><span class="line">&lt;/a&gt;</span><br><span class="line">&lt;/p&gt;</span><br><span class="line">&lt;/body&gt;), (2, &lt;html&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;p class=&quot;story&quot;&gt;</span><br><span class="line">&lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;</span><br><span class="line">&lt;span&gt;Elsie&lt;/span&gt;</span><br><span class="line">&lt;/a&gt;</span><br><span class="line">&lt;/p&gt;</span><br><span class="line">&lt;/body&gt;&lt;/html&gt;), (3, &lt;html&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;p class=&quot;story&quot;&gt;</span><br><span class="line">&lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;</span><br><span class="line">&lt;span&gt;Elsie&lt;/span&gt;</span><br><span class="line">&lt;/a&gt;</span><br><span class="line">&lt;/p&gt;</span><br><span class="line">&lt;/body&gt;&lt;/html&gt;)]</span><br></pre></td></tr></table></figure><p>返回结果是一个生成器类型，我们在这里用列表输出了它的索引和内容，可以发现列表中的元素就是 a 节点的祖先节点。</p><h5 id="兄弟节点"><a href="#兄弟节点" class="headerlink" title="兄弟节点"></a>兄弟节点</h5><p>上面说明了子节点和父节点的获取方式，如果要获取同级的节点也就是兄弟节点应该怎么办？我们先用一个实例来感受一下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">html = &quot;&quot;&quot;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">        &lt;p class=&quot;story&quot;&gt;</span><br><span class="line">            Once upon a time there were three little sisters; and their names were</span><br><span class="line">            &lt;a href=&quot;http://example.com/elsie&quot; class=&quot;sister&quot; id=&quot;link1&quot;&gt;</span><br><span class="line">                &lt;span&gt;Elsie&lt;/span&gt;</span><br><span class="line">            &lt;/a&gt;</span><br><span class="line">            Hello</span><br><span class="line">            &lt;a href=&quot;http://example.com/lacie&quot; class=&quot;sister&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt; </span><br><span class="line">            and</span><br><span class="line">            &lt;a href=&quot;http://example.com/tillie&quot; class=&quot;sister&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;</span><br><span class="line">            and they lived at the bottom of a well.</span><br><span class="line">        &lt;/p&gt;</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">from bs4 import BeautifulSoup</span><br><span class="line">soup = BeautifulSoup(html, &apos;lxml&apos;)</span><br><span class="line">print(&apos;Next Sibling&apos;, soup.a.next_sibling)</span><br><span class="line">print(&apos;Prev Sibling&apos;, soup.a.previous_sibling)</span><br><span class="line">print(&apos;Next Siblings&apos;, list(enumerate(soup.a.next_siblings)))</span><br><span class="line">print(&apos;Prev Siblings&apos;, list(enumerate(soup.a.previous_siblings)))</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Next Sibling </span><br><span class="line">            Hello</span><br><span class="line"></span><br><span class="line">Prev Sibling </span><br><span class="line">            Once upon a time there were three little sisters; and their names were</span><br><span class="line"></span><br><span class="line">Next Siblings [(0, &apos;\n            Hello\n            &apos;), (1, &lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt;), (2, &apos; \n            and\n            &apos;), (3, &lt;a class=&quot;sister&quot; href=&quot;http://example.com/tillie&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;), (4, &apos;\n            and they lived at the bottom of a well.\n        &apos;)]</span><br><span class="line">Prev Siblings [(0, &apos;\n            Once upon a time there were three little sisters; and their names were\n            &apos;)]</span><br></pre></td></tr></table></figure><p>可以看到在这里我们调用了四个不同的属性，next_sibling 和 previous_sibling 分别可以获取节点的下一个和上一个兄弟元素，next_siblings 和 previous_siblings 则分别返回所有前面和后面的兄弟节点的生成器。</p><h5 id="提取信息-1"><a href="#提取信息-1" class="headerlink" title="提取信息"></a>提取信息</h5><p>在上面我们讲解了关联元素节点的选择方法，如果我们想要获取它们的一些信息，比如文本、属性等等也是同样的方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">html = &quot;&quot;&quot;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">        &lt;p class=&quot;story&quot;&gt;</span><br><span class="line">            Once upon a time there were three little sisters; and their names were</span><br><span class="line">            &lt;a href=&quot;http://example.com/elsie&quot; class=&quot;sister&quot; id=&quot;link1&quot;&gt;Bob&lt;/a&gt;&lt;a href=&quot;http://example.com/lacie&quot; class=&quot;sister&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt; </span><br><span class="line">        &lt;/p&gt;</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">from bs4 import BeautifulSoup</span><br><span class="line">soup = BeautifulSoup(html, &apos;lxml&apos;)</span><br><span class="line">print(&apos;Next Sibling:&apos;)</span><br><span class="line">print(type(soup.a.next_sibling))</span><br><span class="line">print(soup.a.next_sibling)</span><br><span class="line">print(soup.a.next_sibling.string)</span><br><span class="line">print(&apos;Parent:&apos;)</span><br><span class="line">print(type(soup.a.parents))</span><br><span class="line">print(list(soup.a.parents)[0])</span><br><span class="line">print(list(soup.a.parents)[0].attrs[&apos;class&apos;])</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Next Sibling:</span><br><span class="line">&lt;class &apos;bs4.element.Tag&apos;&gt;</span><br><span class="line">&lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt;</span><br><span class="line">Lacie</span><br><span class="line">Parent:</span><br><span class="line">&lt;class &apos;generator&apos;&gt;</span><br><span class="line">&lt;p class=&quot;story&quot;&gt;</span><br><span class="line">            Once upon a time there were three little sisters; and their names were</span><br><span class="line">            &lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;Bob&lt;/a&gt;&lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt;</span><br><span class="line">&lt;/p&gt;</span><br><span class="line">[&apos;story&apos;]</span><br></pre></td></tr></table></figure><p>如果返回结果是单个节点，那么可以直接调用 string、attrs 等属性来获得其文本和属性，如果返回结果是多个节点的生成器，则可以转为列表后取出某个元素，然后再调用 string、attrs 等属性来获取其对应节点等文本和属性。</p><h3 id="方法选择器"><a href="#方法选择器" class="headerlink" title="方法选择器"></a>方法选择器</h3><p>前面我们所讲的选择方法都是通过属性来选择元素的，这种选择方法非常快，但是如果要进行比较复杂的选择的话则会比较繁琐，不够灵活。所以 BeautifulSoup 还为我们提供了一些查询的方法，比如 find_all()、find() 等方法，我们可以调用方法然后传入相应等参数就可以灵活地进行查询了。</p><p>最常用的查询方法莫过于 find_all() 和 find() 了，下面我们对它们的用法进行详细的介绍。</p><h4 id="find-all"><a href="#find-all" class="headerlink" title="find_all()"></a>find_all()</h4><p>find_all，顾名思义，就是查询所有符合条件的元素，可以给它传入一些属性或文本来得到符合条件的元素，功能十分强大。</p><p>它的API如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find_all(name , attrs , recursive , text , **kwargs)</span><br></pre></td></tr></table></figure><h5 id="name"><a href="#name" class="headerlink" title="name"></a>name</h5><p>我们可以根据节点名来查询元素，下面我们用一个实例来感受一下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">html=&apos;&apos;&apos;</span><br><span class="line">&lt;div class=&quot;panel&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;panel-heading&quot;&gt;</span><br><span class="line">        &lt;h4&gt;Hello&lt;/h4&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;panel-body&quot;&gt;</span><br><span class="line">        &lt;ul class=&quot;list&quot; id=&quot;list-1&quot;&gt;</span><br><span class="line">            &lt;li class=&quot;element&quot;&gt;Foo&lt;/li&gt;</span><br><span class="line">            &lt;li class=&quot;element&quot;&gt;Bar&lt;/li&gt;</span><br><span class="line">            &lt;li class=&quot;element&quot;&gt;Jay&lt;/li&gt;</span><br><span class="line">        &lt;/ul&gt;</span><br><span class="line">        &lt;ul class=&quot;list list-small&quot; id=&quot;list-2&quot;&gt;</span><br><span class="line">            &lt;li class=&quot;element&quot;&gt;Foo&lt;/li&gt;</span><br><span class="line">            &lt;li class=&quot;element&quot;&gt;Bar&lt;/li&gt;</span><br><span class="line">        &lt;/ul&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&apos;&apos;&apos;</span><br><span class="line">from bs4 import BeautifulSoup</span><br><span class="line">soup = BeautifulSoup(html, &apos;lxml&apos;)</span><br><span class="line">print(soup.find_all(name=&apos;ul&apos;))</span><br><span class="line">print(type(soup.find_all(name=&apos;ul&apos;)[0]))</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[&lt;ul class=&quot;list&quot; id=&quot;list-1&quot;&gt;</span><br><span class="line">&lt;li class=&quot;element&quot;&gt;Foo&lt;/li&gt;</span><br><span class="line">&lt;li class=&quot;element&quot;&gt;Bar&lt;/li&gt;</span><br><span class="line">&lt;li class=&quot;element&quot;&gt;Jay&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;, &lt;ul class=&quot;list list-small&quot; id=&quot;list-2&quot;&gt;</span><br><span class="line">&lt;li class=&quot;element&quot;&gt;Foo&lt;/li&gt;</span><br><span class="line">&lt;li class=&quot;element&quot;&gt;Bar&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;]</span><br><span class="line">&lt;class &apos;bs4.element.Tag&apos;&gt;</span><br></pre></td></tr></table></figure><p>在这里我们调用了 find_all() 方法，传入了一个 name 参数，参数值为 ul，也就是说我们想要查询所有 ul 节点，返回结果是列表类型，长度为 2，每个元素依然都是 bs4.element.Tag 类型。</p><p>因为都是 Tag 类型，所以我们依然可以进行嵌套查询，还是同样的文本，在这里我们查询出所有 ul 节点后再继续查询其内部的 li 节点。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for ul in soup.find_all(name=&apos;ul&apos;):</span><br><span class="line">    print(ul.find_all(name=&apos;li&apos;))</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[&lt;li class=&quot;element&quot;&gt;Foo&lt;/li&gt;, &lt;li class=&quot;element&quot;&gt;Bar&lt;/li&gt;, &lt;li class=&quot;element&quot;&gt;Jay&lt;/li&gt;]</span><br><span class="line">[&lt;li class=&quot;element&quot;&gt;Foo&lt;/li&gt;, &lt;li class=&quot;element&quot;&gt;Bar&lt;/li&gt;]</span><br></pre></td></tr></table></figure><p>返回结果是列表类型，列表中的每个元素依然还是 Tag 类型。</p><p>接下来我们就可以遍历每个 li 获取它的文本了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for ul in soup.find_all(name=&apos;ul&apos;):</span><br><span class="line">    print(ul.find_all(name=&apos;li&apos;))</span><br><span class="line">    for li in ul.find_all(name=&apos;li&apos;):</span><br><span class="line">        print(li.string)</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[&lt;li class=&quot;element&quot;&gt;Foo&lt;/li&gt;, &lt;li class=&quot;element&quot;&gt;Bar&lt;/li&gt;, &lt;li class=&quot;element&quot;&gt;Jay&lt;/li&gt;]</span><br><span class="line">Foo</span><br><span class="line">Bar</span><br><span class="line">Jay</span><br><span class="line">[&lt;li class=&quot;element&quot;&gt;Foo&lt;/li&gt;, &lt;li class=&quot;element&quot;&gt;Bar&lt;/li&gt;]</span><br><span class="line">Foo</span><br><span class="line">Bar</span><br></pre></td></tr></table></figure><h5 id="attrs"><a href="#attrs" class="headerlink" title="attrs"></a>attrs</h5><p>除了根据节点名查询，我们也可以传入一些属性来进行查询，我们用一个实例感受一下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">html=&apos;&apos;&apos;</span><br><span class="line">&lt;div class=&quot;panel&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;panel-heading&quot;&gt;</span><br><span class="line">        &lt;h4&gt;Hello&lt;/h4&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;panel-body&quot;&gt;</span><br><span class="line">        &lt;ul class=&quot;list&quot; id=&quot;list-1&quot; name=&quot;elements&quot;&gt;</span><br><span class="line">            &lt;li class=&quot;element&quot;&gt;Foo&lt;/li&gt;</span><br><span class="line">            &lt;li class=&quot;element&quot;&gt;Bar&lt;/li&gt;</span><br><span class="line">            &lt;li class=&quot;element&quot;&gt;Jay&lt;/li&gt;</span><br><span class="line">        &lt;/ul&gt;</span><br><span class="line">        &lt;ul class=&quot;list list-small&quot; id=&quot;list-2&quot;&gt;</span><br><span class="line">            &lt;li class=&quot;element&quot;&gt;Foo&lt;/li&gt;</span><br><span class="line">            &lt;li class=&quot;element&quot;&gt;Bar&lt;/li&gt;</span><br><span class="line">        &lt;/ul&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&apos;&apos;&apos;</span><br><span class="line">from bs4 import BeautifulSoup</span><br><span class="line">soup = BeautifulSoup(html, &apos;lxml&apos;)</span><br><span class="line">print(soup.find_all(attrs=&#123;&apos;id&apos;: &apos;list-1&apos;&#125;))</span><br><span class="line">print(soup.find_all(attrs=&#123;&apos;name&apos;: &apos;elements&apos;&#125;))</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[&lt;ul class=&quot;list&quot; id=&quot;list-1&quot; name=&quot;elements&quot;&gt;</span><br><span class="line">&lt;li class=&quot;element&quot;&gt;Foo&lt;/li&gt;</span><br><span class="line">&lt;li class=&quot;element&quot;&gt;Bar&lt;/li&gt;</span><br><span class="line">&lt;li class=&quot;element&quot;&gt;Jay&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;]</span><br><span class="line">[&lt;ul class=&quot;list&quot; id=&quot;list-1&quot; name=&quot;elements&quot;&gt;</span><br><span class="line">&lt;li class=&quot;element&quot;&gt;Foo&lt;/li&gt;</span><br><span class="line">&lt;li class=&quot;element&quot;&gt;Bar&lt;/li&gt;</span><br><span class="line">&lt;li class=&quot;element&quot;&gt;Jay&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;]</span><br></pre></td></tr></table></figure><p>在这里我们查询的时候传入的是 attrs 参数，参数的类型是字典类型，比如我们要查询 id 为 list-1 的节点，那就可以传入attrs={‘id’: ‘list-1’} 的查询条件，得到的结果是列表形式，包含的内容就是符合 id 为 list-1 的所有节点，上面的例子中符合条件的元素个数是 1，所以结果是长度为 1 的列表。</p><p>对于一些常用的属性比如 id、class 等，我们可以不用 attrs 来传递，比如我们要查询 id 为 list-1 的节点，我们可以直接传入 id 这个参数，还是上面的文本，我们换一种方式来查询。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">from bs4 import BeautifulSoup</span><br><span class="line">soup = BeautifulSoup(html, &apos;lxml&apos;)</span><br><span class="line">print(soup.find_all(id=&apos;list-1&apos;))</span><br><span class="line">print(soup.find_all(class_=&apos;element&apos;))</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[&lt;ul class=&quot;list&quot; id=&quot;list-1&quot;&gt;</span><br><span class="line">&lt;li class=&quot;element&quot;&gt;Foo&lt;/li&gt;</span><br><span class="line">&lt;li class=&quot;element&quot;&gt;Bar&lt;/li&gt;</span><br><span class="line">&lt;li class=&quot;element&quot;&gt;Jay&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;]</span><br><span class="line">[&lt;li class=&quot;element&quot;&gt;Foo&lt;/li&gt;, &lt;li class=&quot;element&quot;&gt;Bar&lt;/li&gt;, &lt;li class=&quot;element&quot;&gt;Jay&lt;/li&gt;, &lt;li class=&quot;element&quot;&gt;Foo&lt;/li&gt;, &lt;li class=&quot;element&quot;&gt;Bar&lt;/li&gt;]</span><br></pre></td></tr></table></figure><p>在这里我们直接传入 id=’list-1’ 就可以查询 id 为 list-1 的节点元素了。而对于 class 来说，由于 class 在 python 里是一个关键字，所以在这里后面需要加一个下划线，class_=’element’，返回的结果依然还是 Tag 组成的列表。</p><h5 id="text"><a href="#text" class="headerlink" title="text"></a>text</h5><p>text 参数可以用来匹配节点的文本，传入的形式可以是字符串，可以是正则表达式对象，我们用一个实例来感受一下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import re</span><br><span class="line">html=&apos;&apos;&apos;</span><br><span class="line">&lt;div class=&quot;panel&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;panel-body&quot;&gt;</span><br><span class="line">        &lt;a&gt;Hello, this is a link&lt;/a&gt;</span><br><span class="line">        &lt;a&gt;Hello, this is a link, too&lt;/a&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&apos;&apos;&apos;</span><br><span class="line">from bs4 import BeautifulSoup</span><br><span class="line">soup = BeautifulSoup(html, &apos;lxml&apos;)</span><br><span class="line">print(soup.find_all(text=re.compile(&apos;link&apos;)))</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&apos;Hello, this is a link&apos;, &apos;Hello, this is a link, too&apos;]</span><br></pre></td></tr></table></figure><p>在这里有两个 a 节点，其内部包含有文本信息，在这里我们调用 find_all() 方法传入 text 参数，参数为正则表达式对象，结果会返回所有匹配正则表达式的节点文本组成的列表。</p><h4 id="find"><a href="#find" class="headerlink" title="find()"></a>find()</h4><p>除了 find_all() 方法，还有 find() 方法，只不过 find() 方法返回的是单个元素，也就是第一个匹配的元素，而 find_all() 返回的是所有匹配的元素组成的列表。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">html=&apos;&apos;&apos;</span><br><span class="line">&lt;div class=&quot;panel&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;panel-heading&quot;&gt;</span><br><span class="line">        &lt;h4&gt;Hello&lt;/h4&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;panel-body&quot;&gt;</span><br><span class="line">        &lt;ul class=&quot;list&quot; id=&quot;list-1&quot;&gt;</span><br><span class="line">            &lt;li class=&quot;element&quot;&gt;Foo&lt;/li&gt;</span><br><span class="line">            &lt;li class=&quot;element&quot;&gt;Bar&lt;/li&gt;</span><br><span class="line">            &lt;li class=&quot;element&quot;&gt;Jay&lt;/li&gt;</span><br><span class="line">        &lt;/ul&gt;</span><br><span class="line">        &lt;ul class=&quot;list list-small&quot; id=&quot;list-2&quot;&gt;</span><br><span class="line">            &lt;li class=&quot;element&quot;&gt;Foo&lt;/li&gt;</span><br><span class="line">            &lt;li class=&quot;element&quot;&gt;Bar&lt;/li&gt;</span><br><span class="line">        &lt;/ul&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&apos;&apos;&apos;</span><br><span class="line">from bs4 import BeautifulSoup</span><br><span class="line">soup = BeautifulSoup(html, &apos;lxml&apos;)</span><br><span class="line">print(soup.find(name=&apos;ul&apos;))</span><br><span class="line">print(type(soup.find(name=&apos;ul&apos;)))</span><br><span class="line">print(soup.find(class_=&apos;list&apos;))</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul class=&quot;list&quot; id=&quot;list-1&quot;&gt;</span><br><span class="line">&lt;li class=&quot;element&quot;&gt;Foo&lt;/li&gt;</span><br><span class="line">&lt;li class=&quot;element&quot;&gt;Bar&lt;/li&gt;</span><br><span class="line">&lt;li class=&quot;element&quot;&gt;Jay&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">&lt;class &apos;bs4.element.Tag&apos;&gt;</span><br><span class="line">&lt;ul class=&quot;list&quot; id=&quot;list-1&quot;&gt;</span><br><span class="line">&lt;li class=&quot;element&quot;&gt;Foo&lt;/li&gt;</span><br><span class="line">&lt;li class=&quot;element&quot;&gt;Bar&lt;/li&gt;</span><br><span class="line">&lt;li class=&quot;element&quot;&gt;Jay&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure><p>返回结果不再是列表形式，而是第一个匹配的节点元素，类型依然是 Tag 类型。</p><p>另外还有许多的查询方法，用法与前面介绍的 find_all()、find() 方法完全相同，只不过查询范围不同，在此做一下简单的说明。</p><h4 id="find-parents-find-parent"><a href="#find-parents-find-parent" class="headerlink" title="find_parents() find_parent()"></a>find_parents() find_parent()</h4><p>find_parents() 返回所有祖先节点，find_parent() 返回直接父节点。</p><h4 id="find-next-siblings-find-next-sibling"><a href="#find-next-siblings-find-next-sibling" class="headerlink" title="find_next_siblings() find_next_sibling()"></a>find_next_siblings() find_next_sibling()</h4><p>find_next_siblings() 返回后面所有兄弟节点，find_next_sibling() 返回后面第一个兄弟节点。</p><h4 id="find-previous-siblings-find-previous-sibling"><a href="#find-previous-siblings-find-previous-sibling" class="headerlink" title="find_previous_siblings() find_previous_sibling()"></a>find_previous_siblings() find_previous_sibling()</h4><p>find_previous_siblings() 返回前面所有兄弟节点，find_previous_sibling() 返回前面第一个兄弟节点。</p><h4 id="find-all-next-find-next"><a href="#find-all-next-find-next" class="headerlink" title="find_all_next() find_next()"></a>find_all_next() find_next()</h4><p>find_all_next() 返回节点后所有符合条件的节点, find_next() 返回第一个符合条件的节点。</p><h4 id="find-all-previous-和-find-previous"><a href="#find-all-previous-和-find-previous" class="headerlink" title="find_all_previous() 和 find_previous()"></a>find_all_previous() 和 find_previous()</h4><p>find_all_previous() 返回节点后所有符合条件的节点, find_previous() 返回第一个符合条件的节点</p><h3 id="CSS选择器"><a href="#CSS选择器" class="headerlink" title="CSS选择器"></a>CSS选择器</h3><p>BeautifulSoup 还提供了另外一种选择器，那就是 CSS 选择器，如果对 Web 开发熟悉对话，CSS 选择器肯定也不陌生，如果不熟悉的话，可以看一下：<a href="http://www.w3school.com.cn/cssref/css_selectors.asp" target="_blank" rel="noopener">http://www.w3school.com.cn/cssref/css_selectors.asp</a>。</p><p>使用 CSS 选择器，只需要调用 select() 方法，传入相应的 CSS 选择器即可，我们用一个实例来感受一下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">html=&apos;&apos;&apos;</span><br><span class="line">&lt;div class=&quot;panel&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;panel-heading&quot;&gt;</span><br><span class="line">        &lt;h4&gt;Hello&lt;/h4&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;panel-body&quot;&gt;</span><br><span class="line">        &lt;ul class=&quot;list&quot; id=&quot;list-1&quot;&gt;</span><br><span class="line">            &lt;li class=&quot;element&quot;&gt;Foo&lt;/li&gt;</span><br><span class="line">            &lt;li class=&quot;element&quot;&gt;Bar&lt;/li&gt;</span><br><span class="line">            &lt;li class=&quot;element&quot;&gt;Jay&lt;/li&gt;</span><br><span class="line">        &lt;/ul&gt;</span><br><span class="line">        &lt;ul class=&quot;list list-small&quot; id=&quot;list-2&quot;&gt;</span><br><span class="line">            &lt;li class=&quot;element&quot;&gt;Foo&lt;/li&gt;</span><br><span class="line">            &lt;li class=&quot;element&quot;&gt;Bar&lt;/li&gt;</span><br><span class="line">        &lt;/ul&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&apos;&apos;&apos;</span><br><span class="line">from bs4 import BeautifulSoup</span><br><span class="line">soup = BeautifulSoup(html, &apos;lxml&apos;)</span><br><span class="line">print(soup.select(&apos;.panel .panel-heading&apos;))</span><br><span class="line">print(soup.select(&apos;ul li&apos;))</span><br><span class="line">print(soup.select(&apos;#list-2 .element&apos;))</span><br><span class="line">print(type(soup.select(&apos;ul&apos;)[0]))</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[&lt;div class=&quot;panel-heading&quot;&gt;</span><br><span class="line">&lt;h4&gt;Hello&lt;/h4&gt;</span><br><span class="line">&lt;/div&gt;]</span><br><span class="line">[&lt;li class=&quot;element&quot;&gt;Foo&lt;/li&gt;, &lt;li class=&quot;element&quot;&gt;Bar&lt;/li&gt;, &lt;li class=&quot;element&quot;&gt;Jay&lt;/li&gt;, &lt;li class=&quot;element&quot;&gt;Foo&lt;/li&gt;, &lt;li class=&quot;element&quot;&gt;Bar&lt;/li&gt;]</span><br><span class="line">[&lt;li class=&quot;element&quot;&gt;Foo&lt;/li&gt;, &lt;li class=&quot;element&quot;&gt;Bar&lt;/li&gt;]</span><br><span class="line">&lt;class &apos;bs4.element.Tag&apos;&gt;</span><br></pre></td></tr></table></figure><p>在这里我们用了三次 CSS 选择器，返回的结果均是符合 CSS 选择器的节点组成的列表。例如 select(‘ul li’) 则是选择所有 ul 节点下面的所有 li 节点，结果便是所有的 li 节点组成的列表。</p><p>最后一句我们打印输出了列表中元素的类型，可以看到类型依然是 Tag 类型。</p><h4 id="嵌套选择-1"><a href="#嵌套选择-1" class="headerlink" title="嵌套选择"></a>嵌套选择</h4><p>select() 方法同样支持嵌套选择，例如我们先选择所有 ul 节点，再遍历每个 ul 节点选择其 li 节点，样例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">from bs4 import BeautifulSoup</span><br><span class="line">soup = BeautifulSoup(html, &apos;lxml&apos;)</span><br><span class="line">for ul in soup.select(&apos;ul&apos;):</span><br><span class="line">    print(ul.select(&apos;li&apos;))</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[&lt;li class=&quot;element&quot;&gt;Foo&lt;/li&gt;, &lt;li class=&quot;element&quot;&gt;Bar&lt;/li&gt;, &lt;li class=&quot;element&quot;&gt;Jay&lt;/li&gt;]</span><br><span class="line">[&lt;li class=&quot;element&quot;&gt;Foo&lt;/li&gt;, &lt;li class=&quot;element&quot;&gt;Bar&lt;/li&gt;]</span><br></pre></td></tr></table></figure><p>可以看到正常输出了遍历每个 ul 节点之后，其下的所有 li 节点组成的列表。</p><h4 id="获取属性-1"><a href="#获取属性-1" class="headerlink" title="获取属性"></a>获取属性</h4><p>我们知道节点类型是 Tag 类型，所以获取属性还是可以用原来的方法获取，仍然是上面的 HTML 文本，我们在这里尝试获取每个 ul 节点的 id 属性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">from bs4 import BeautifulSoup</span><br><span class="line">soup = BeautifulSoup(html, &apos;lxml&apos;)</span><br><span class="line">for ul in soup.select(&apos;ul&apos;):</span><br><span class="line">    print(ul[&apos;id&apos;])</span><br><span class="line">    print(ul.attrs[&apos;id&apos;])</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">list-1</span><br><span class="line">list-1</span><br><span class="line">list-2</span><br><span class="line">list-2</span><br></pre></td></tr></table></figure><p>可以看到直接传入中括号和属性名和通过 attrs 属性获取属性值都是可以成功的。</p><h4 id="获取文本"><a href="#获取文本" class="headerlink" title="获取文本"></a>获取文本</h4><p>那么获取文本当然也可以用前面所讲的 string 属性，还有一个方法那就是 get_text()，同样可以获取文本值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">from bs4 import BeautifulSoup</span><br><span class="line">soup = BeautifulSoup(html, &apos;lxml&apos;)</span><br><span class="line">for li in soup.select(&apos;li&apos;):</span><br><span class="line">    print(&apos;Get Text:&apos;, li.get_text())</span><br><span class="line">    print(&apos;String:&apos;, li.string)</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Get Text: Foo</span><br><span class="line">String: Foo</span><br><span class="line">Get Text: Bar</span><br><span class="line">String: Bar</span><br><span class="line">Get Text: Jay</span><br><span class="line">String: Jay</span><br><span class="line">Get Text: Foo</span><br><span class="line">String: Foo</span><br><span class="line">Get Text: Bar</span><br><span class="line">String: Bar</span><br></pre></td></tr></table></figure><p>二者的效果是完全一致的，都可以获取到节点的文本值。</p><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><blockquote><ul><li>推荐使用 LXML 解析库，必要时使用 html.parser。</li><li>节点选择筛选功能弱但是速度快。</li><li>建议使用 find()、find_all() 查询匹配单个结果或者多个结果。</li><li>如果对 CSS 选择器熟悉的话可以使用 select() 选择法。</li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;今天介绍一个强大的解析工具，叫做 BeautiSoup，它就是借助网页的结构和属性等特性来解析网页的工具，有了它我们不用再去写一些复杂的正则
      
    
    </summary>
    
      <category term="爬虫" scheme="http://gavinliu4011.github.io/categories/%E7%88%AC%E8%99%AB/"/>
    
    
      <category term="Python" scheme="http://gavinliu4011.github.io/tags/Python/"/>
    
      <category term="爬虫" scheme="http://gavinliu4011.github.io/tags/%E7%88%AC%E8%99%AB/"/>
    
      <category term="BeautifulSoup" scheme="http://gavinliu4011.github.io/tags/BeautifulSoup/"/>
    
  </entry>
  
  <entry>
    <title>XPath 和 lxml库</title>
    <link href="http://gavinliu4011.github.io/post/606df891.html"/>
    <id>http://gavinliu4011.github.io/post/606df891.html</id>
    <published>2018-04-28T23:35:20.000Z</published>
    <updated>2018-05-02T15:20:16.921Z</updated>
    
    <content type="html"><![CDATA[<h3 id="关于Python爬虫，我们需要学习的有："><a href="#关于Python爬虫，我们需要学习的有：" class="headerlink" title="关于Python爬虫，我们需要学习的有："></a>关于Python爬虫，我们需要学习的有：</h3><h5 id="1-Python基础语法学习（基础知识）"><a href="#1-Python基础语法学习（基础知识）" class="headerlink" title="1. Python基础语法学习（基础知识）"></a>1. Python基础语法学习（基础知识）</h5><h5 id="2-HTML页面的内容抓取（数据抓取）"><a href="#2-HTML页面的内容抓取（数据抓取）" class="headerlink" title="2. HTML页面的内容抓取（数据抓取）"></a>2. HTML页面的内容抓取（数据抓取）</h5><h5 id="3-HTML页面的数据提取（数据清洗）"><a href="#3-HTML页面的数据提取（数据清洗）" class="headerlink" title="3. HTML页面的数据提取（数据清洗）"></a>3. HTML页面的数据提取（数据清洗）</h5><h5 id="4-Scrapy框架以及scrapy-redis分布式策略（第三方框架）"><a href="#4-Scrapy框架以及scrapy-redis分布式策略（第三方框架）" class="headerlink" title="4. Scrapy框架以及scrapy-redis分布式策略（第三方框架）"></a>4. Scrapy框架以及scrapy-redis分布式策略（第三方框架）</h5><h5 id="6-爬虫-Spider-、反爬虫-Anti-Spider-、反反爬虫-Anti-Anti-Spider-之间的斗争…"><a href="#6-爬虫-Spider-、反爬虫-Anti-Spider-、反反爬虫-Anti-Anti-Spider-之间的斗争…" class="headerlink" title="6. 爬虫(Spider)、反爬虫(Anti-Spider)、反反爬虫(Anti-Anti-Spider)之间的斗争…."></a>6. 爬虫(Spider)、反爬虫(Anti-Spider)、反反爬虫(Anti-Anti-Spider)之间的斗争….</h5><p>为了重拾爬虫部分，决定写博客复习一下，废话不多说，这篇文章主要说一下 XPath与lxml类库 </p><h2 id="什么是XPath？"><a href="#什么是XPath？" class="headerlink" title="什么是XPath？"></a>什么是XPath？</h2><blockquote><p>XPath (XML Path Language) 是一门在 XML 文档中查找信息的语言，可用来在 XML 文档中对元素和属性进行遍历。</p><p>W3School官方文档：<a href="http://www.w3school.com.cn/xpath/index.asp" target="_blank" rel="noopener">http://www.w3school.com.cn/xpath/index.asp</a></p></blockquote><h3 id="XPath-开发工具"><a href="#XPath-开发工具" class="headerlink" title="XPath 开发工具"></a>XPath 开发工具</h3><ol><li>开源的XPath表达式编辑工具:XMLQuire(XML格式文件可用)</li><li>Chrome插件XPath Helper</li><li>Firefox插件 XPath Checker</li></ol><h3 id="选取节点"><a href="#选取节点" class="headerlink" title="选取节点"></a>选取节点</h3><p>XPath 使用路径表达式来选取 XML 文档中的节点或者节点集。这些路径表达式和我们在常规的电脑文件系统中看到的表达式非常相似。</p><p>下面列出了最常用的路径表达式：</p><table><thead><tr><th>表达式</th><th>描述</th></tr></thead><tbody><tr><td>nodename</td><td>选取此节点的所有子节点。</td></tr><tr><td>/</td><td>从根节点选取。</td></tr><tr><td>//</td><td>从匹配选择的当前节点选择文档中的节点，而不考虑它们的位置。</td></tr><tr><td>.</td><td>选取当前节点。</td></tr><tr><td>..</td><td>选取当前节点的父节点。</td></tr><tr><td>@</td><td>选取属性。</td></tr></tbody></table><p>在下面的表格中，我们已列出了一些路径表达式以及表达式的结果：</p><table><thead><tr><th></th><th>路径表达式</th></tr></thead><tbody><tr><td>bookstore</td><td>选取 bookstore 元素的所有子节点。</td></tr><tr><td>/bookstore</td><td>选取根元素 bookstore。注释：假如路径起始于正斜杠( / )，则此路径始终代表到某元素的绝对路径！</td></tr><tr><td>bookstore/book</td><td>选取属于 bookstore 的子元素的所有 book 元素。</td></tr><tr><td>//book</td><td>选取所有 book 子元素，而不管它们在文档中的位置。</td></tr><tr><td>bookstore//book</td><td>选择属于 bookstore 元素的后代的所有 book 元素，而不管它们位于 bookstore 之下的什么位置。</td></tr><tr><td>//@lang</td><td>选取名为 lang 的所有属性。</td></tr></tbody></table><h3 id="谓语（Predicates）"><a href="#谓语（Predicates）" class="headerlink" title="谓语（Predicates）"></a>谓语（Predicates）</h3><p>谓语用来查找某个特定的节点或者包含某个指定的值的节点，被嵌在方括号中。</p><p>在下面的表格中，我们列出了带有谓语的一些路径表达式，以及表达式的结果：</p><table><thead><tr><th>路径表达式</th><th>结果</th></tr></thead><tbody><tr><td>/bookstore/book[1]</td><td>选取属于 bookstore 子元素的第一个 book 元素。</td></tr><tr><td>/bookstore/book[last()]</td><td>选取属于 bookstore 子元素的最后一个 book 元素。</td></tr><tr><td>/bookstore/book[last()-1]</td><td>选取属于 bookstore 子元素的倒数第二个 book 元素。</td></tr><tr><td>/bookstore/book[position()&lt;3]</td><td>选取最前面的两个属于 bookstore 元素的子元素的 book 元素。</td></tr><tr><td>//title[@lang]</td><td>选取所有拥有名为 lang 的属性的 title 元素。</td></tr><tr><td>//title[@lang=’eng’]</td><td>选取所有 title 元素，且这些元素拥有值为 eng 的 lang 属性。</td></tr><tr><td>/bookstore/book[price&gt;35.00]</td><td>选取 bookstore 元素的所有 book 元素，且其中的 price 元素的值须大于 35.00。</td></tr><tr><td>/bookstore/book[price&gt;35.00]/title</td><td>选取 bookstore 元素中的 book 元素的所有 title 元素，且其中的 price 元素的值须大于 35.00。</td></tr></tbody></table><h3 id="选取未知节点"><a href="#选取未知节点" class="headerlink" title="选取未知节点"></a>选取未知节点</h3><p>XPath 通配符可用来选取未知的 XML 元素。</p><table><thead><tr><th>通配符</th><th>描述</th></tr></thead><tbody><tr><td>*</td><td>匹配任何元素节点。</td></tr><tr><td>@*</td><td>匹配任何属性节点。</td></tr><tr><td>node()</td><td>匹配任何类型的节点。</td></tr></tbody></table><p>在下面的表格中，我们列出了一些路径表达式，以及这些表达式的结果：</p><table><thead><tr><th>路径表达式</th><th>结果</th></tr></thead><tbody><tr><td>/bookstore/*</td><td>选取 bookstore 元素的所有子元素。</td></tr><tr><td>//*</td><td>选取文档中的所有元素。</td></tr><tr><td>//title[@*]</td><td>选取所有带有属性的 title 元素。</td></tr></tbody></table><h3 id="选取若干路径"><a href="#选取若干路径" class="headerlink" title="选取若干路径"></a>选取若干路径</h3><p>通过在路径表达式中使用“|”运算符，您可以选取若干个路径。</p><p>实例</p><p>在下面的表格中，我们列出了一些路径表达式，以及这些表达式的结果：</p><table><thead><tr><th>路径表达式</th><th>结果</th></tr></thead><tbody><tr><td>//book/title \</td><td>//book/price</td><td>选取 book 元素的所有 title 和 price 元素。</td></tr><tr><td>//title \</td><td>//price</td><td>选取文档中的所有 title 和 price 元素。</td></tr><tr><td>/bookstore/book/title \</td><td>//price</td><td>选取属于 bookstore 元素的 book 元素的所有 title 元素，以及文档中所有的 price 元素。</td></tr></tbody></table><h3 id="XPath的运算符"><a href="#XPath的运算符" class="headerlink" title="XPath的运算符"></a>XPath的运算符</h3><p>下面列出了可用在 XPath 表达式中的运算符：</p><p><img src="../img/spider/xpath.png" alt="img"></p><h5 id="这些就是XPath的语法内容，在运用到Python抓取时要先转换为xml。"><a href="#这些就是XPath的语法内容，在运用到Python抓取时要先转换为xml。" class="headerlink" title="这些就是XPath的语法内容，在运用到Python抓取时要先转换为xml。"></a>这些就是XPath的语法内容，在运用到Python抓取时要先转换为xml。</h5><h2 id="lxml库"><a href="#lxml库" class="headerlink" title="lxml库"></a>lxml库</h2><blockquote><p>lxml 是 一个HTML/XML的解析器，主要的功能是如何解析和提取 HTML/XML 数据。</p><p>lxml和正则一样，也是用 C 实现的，是一款高性能的 Python HTML/XML 解析器，我们可以利用之前学习的XPath语法，来快速的定位特定元素以及节点信息。</p><p>lxml python 官方文档：<a href="http://lxml.de/index.html" target="_blank" rel="noopener">http://lxml.de/index.html</a></p><p>需要安装C语言库，可使用 pip 安装：<code>pip install lxml</code> （或通过wheel方式安装）</p></blockquote><h3 id="初步使用"><a href="#初步使用" class="headerlink" title="初步使用"></a>初步使用</h3><p>我们利用它来解析 HTML 代码，简单示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"># 使用 lxml 的 etree 库</span><br><span class="line">from lxml import etree </span><br><span class="line"></span><br><span class="line">text = &apos;&apos;&apos;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">         &lt;li class=&quot;item-0&quot;&gt;&lt;a href=&quot;link1.html&quot;&gt;first item&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">         &lt;li class=&quot;item-1&quot;&gt;&lt;a href=&quot;link2.html&quot;&gt;second item&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">         &lt;li class=&quot;item-inactive&quot;&gt;&lt;a href=&quot;link3.html&quot;&gt;third item&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">         &lt;li class=&quot;item-1&quot;&gt;&lt;a href=&quot;link4.html&quot;&gt;fourth item&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">         &lt;li class=&quot;item-0&quot;&gt;&lt;a href=&quot;link5.html&quot;&gt;fifth item&lt;/a&gt; # 注意，此处缺少一个 &lt;/li&gt; 闭合标签</span><br><span class="line">     &lt;/ul&gt;</span><br><span class="line"> &lt;/div&gt;</span><br><span class="line">&apos;&apos;&apos;</span><br><span class="line"></span><br><span class="line">#利用etree.HTML，将字符串解析为HTML文档</span><br><span class="line">html = etree.HTML(text) </span><br><span class="line"></span><br><span class="line"># 按字符串序列化HTML文档</span><br><span class="line">result = etree.tostring(html) </span><br><span class="line"></span><br><span class="line">print(result)</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;&lt;body&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">         &lt;li class=&quot;item-0&quot;&gt;&lt;a href=&quot;link1.html&quot;&gt;first item&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">         &lt;li class=&quot;item-1&quot;&gt;&lt;a href=&quot;link2.html&quot;&gt;second item&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">         &lt;li class=&quot;item-inactive&quot;&gt;&lt;a href=&quot;link3.html&quot;&gt;third item&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">         &lt;li class=&quot;item-1&quot;&gt;&lt;a href=&quot;link4.html&quot;&gt;fourth item&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">         &lt;li class=&quot;item-0&quot;&gt;&lt;a href=&quot;link5.html&quot;&gt;fifth item&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line"> &lt;/div&gt;</span><br><span class="line">&lt;/body&gt;&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>lxml 可以自动修正 html 代码，例子里不仅补全了 li 标签，还添加了 body，html 标签。</p><h3 id="文件读取："><a href="#文件读取：" class="headerlink" title="文件读取："></a>文件读取：</h3><p>除了直接读取字符串，lxml还支持从文件里读取内容。我们新建一个hello.html文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- hello.html --&gt;</span><br><span class="line"></span><br><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">         &lt;li class=&quot;item-0&quot;&gt;&lt;a href=&quot;link1.html&quot;&gt;first item&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">         &lt;li class=&quot;item-1&quot;&gt;&lt;a href=&quot;link2.html&quot;&gt;second item&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">         &lt;li class=&quot;item-inactive&quot;&gt;&lt;a href=&quot;link3.html&quot;&gt;&lt;span class=&quot;bold&quot;&gt;third item&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">         &lt;li class=&quot;item-1&quot;&gt;&lt;a href=&quot;link4.html&quot;&gt;fourth item&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">         &lt;li class=&quot;item-0&quot;&gt;&lt;a href=&quot;link5.html&quot;&gt;fifth item&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">     &lt;/ul&gt;</span><br><span class="line"> &lt;/div&gt;</span><br></pre></td></tr></table></figure><p>再利用 etree.parse() 方法来读取文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">from lxml import etree</span><br><span class="line"></span><br><span class="line"># 读取外部文件 hello.html</span><br><span class="line">html = etree.parse(&apos;./hello.html&apos;)</span><br><span class="line">result = etree.tostring(html, pretty_print=True)</span><br><span class="line"></span><br><span class="line">print(result)</span><br></pre></td></tr></table></figure><p>输出结果与之前相同：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;&lt;body&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">         &lt;li class=&quot;item-0&quot;&gt;&lt;a href=&quot;link1.html&quot;&gt;first item&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">         &lt;li class=&quot;item-1&quot;&gt;&lt;a href=&quot;link2.html&quot;&gt;second item&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">         &lt;li class=&quot;item-inactive&quot;&gt;&lt;a href=&quot;link3.html&quot;&gt;third item&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">         &lt;li class=&quot;item-1&quot;&gt;&lt;a href=&quot;link4.html&quot;&gt;fourth item&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">         &lt;li class=&quot;item-0&quot;&gt;&lt;a href=&quot;link5.html&quot;&gt;fifth item&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line"> &lt;/div&gt;</span><br><span class="line">&lt;/body&gt;&lt;/html&gt;</span><br></pre></td></tr></table></figure><h3 id="XPath实例测试"><a href="#XPath实例测试" class="headerlink" title="XPath实例测试"></a>XPath实例测试</h3><h4 id="1-获取所有的-lt-li-gt-标签"><a href="#1-获取所有的-lt-li-gt-标签" class="headerlink" title="1. 获取所有的 &lt;li&gt; 标签"></a>1. 获取所有的 <code>&lt;li&gt;</code> 标签</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">from lxml import etree</span><br><span class="line"></span><br><span class="line">html = etree.parse(&apos;hello.html&apos;)</span><br><span class="line">print(type(html))  # 显示etree.parse() 返回类型</span><br><span class="line"></span><br><span class="line">result = html.xpath(&apos;//li&apos;)</span><br><span class="line"></span><br><span class="line">print(result)  # 打印&lt;li&gt;标签的元素集合</span><br><span class="line">print(len(result))</span><br><span class="line">print(type(result))</span><br><span class="line">print(type(result[0]))</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;class &apos;lxml.etree._ElementTree&apos;&gt;</span><br><span class="line">[&lt;Element li at 0x2cec9e0&gt;, &lt;Element li at 0x2cec9b8&gt;, &lt;Element li at 0x2cec990&gt;, &lt;Element li at 0x2cec968&gt;, &lt;Element li at 0x2cec6c0&gt;]</span><br><span class="line">5</span><br><span class="line">&lt;class &apos;list&apos;&gt;</span><br><span class="line">&lt;class &apos;lxml.etree._Element&apos;&gt;</span><br></pre></td></tr></table></figure><h4 id="2-继续获取-lt-li-gt-标签的所有-class属性"><a href="#2-继续获取-lt-li-gt-标签的所有-class属性" class="headerlink" title="2. 继续获取&lt;li&gt; 标签的所有 class属性"></a>2. 继续获取<code>&lt;li&gt;</code> 标签的所有 <code>class</code>属性</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">from lxml import etree</span><br><span class="line"></span><br><span class="line">html = etree.parse(&apos;hello.html&apos;)</span><br><span class="line">result = html.xpath(&apos;//li/@class&apos;)</span><br><span class="line"></span><br><span class="line">print(result)</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&apos;item-0&apos;, &apos;item-1&apos;, &apos;item-inactive&apos;, &apos;item-1&apos;, &apos;item-0&apos;]</span><br></pre></td></tr></table></figure><h4 id="3-继续获取-lt-li-gt-标签下hre-为-link1-html-的-lt-a-gt-标签"><a href="#3-继续获取-lt-li-gt-标签下hre-为-link1-html-的-lt-a-gt-标签" class="headerlink" title="3. 继续获取&lt;li&gt;标签下hre 为 link1.html 的 &lt;a&gt; 标签"></a>3. 继续获取<code>&lt;li&gt;</code>标签下<code>hre</code> 为 <code>link1.html</code> 的 <code>&lt;a&gt;</code> 标签</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">from lxml import etree</span><br><span class="line"></span><br><span class="line">html = etree.parse(&apos;hello.html&apos;)</span><br><span class="line">result = html.xpath(&apos;//li/a[@href=&quot;link1.html&quot;]&apos;)</span><br><span class="line"></span><br><span class="line">print(result)</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&lt;Element a at 0x8dc9b8&gt;]</span><br></pre></td></tr></table></figure><h4 id="4-获取-lt-li-gt-标签下的所有-lt-span-gt-标签"><a href="#4-获取-lt-li-gt-标签下的所有-lt-span-gt-标签" class="headerlink" title="4. 获取&lt;li&gt; 标签下的所有 &lt;span&gt; 标签"></a>4. 获取<code>&lt;li&gt;</code> 标签下的所有 <code>&lt;span&gt;</code> 标签</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">from lxml import etree</span><br><span class="line"></span><br><span class="line">html = etree.parse(&apos;hello.html&apos;)</span><br><span class="line"></span><br><span class="line"># result = html.xpath(&apos;//li/span&apos;)</span><br><span class="line"># 注意这么写是不对的：</span><br><span class="line"># 因为 / 是用来获取子元素的，而 &lt;span&gt; 并不是 &lt;li&gt; 的子元素，所以，要用双斜杠</span><br><span class="line"></span><br><span class="line">result = html.xpath(&apos;//li//span&apos;)</span><br><span class="line"></span><br><span class="line">print(result)</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&lt;Element span at 0x363c9e0&gt;]</span><br></pre></td></tr></table></figure><h4 id="5-获取-lt-li-gt-标签下的-lt-a-gt-标签里的所有-class"><a href="#5-获取-lt-li-gt-标签下的-lt-a-gt-标签里的所有-class" class="headerlink" title="5. 获取 &lt;li&gt; 标签下的&lt;a&gt;标签里的所有 class"></a>5. 获取 <code>&lt;li&gt;</code> 标签下的<code>&lt;a&gt;</code>标签里的所有 class</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">from lxml import etree</span><br><span class="line"></span><br><span class="line">html = etree.parse(&apos;hello.html&apos;)</span><br><span class="line">result = html.xpath(&apos;//li/a//@class&apos;)</span><br><span class="line"></span><br><span class="line">print(result)</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&apos;blod&apos;]</span><br></pre></td></tr></table></figure><h4 id="6-获取最后一个-lt-li-gt-的-lt-a-gt-的-href"><a href="#6-获取最后一个-lt-li-gt-的-lt-a-gt-的-href" class="headerlink" title="6. 获取最后一个 &lt;li&gt; 的 &lt;a&gt; 的 href"></a>6. 获取最后一个 <code>&lt;li&gt;</code> 的 <code>&lt;a&gt;</code> 的 href</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">from lxml import etree</span><br><span class="line"></span><br><span class="line">html = etree.parse(&apos;hello.html&apos;)</span><br><span class="line"></span><br><span class="line">result = html.xpath(&apos;//li[last()]/a/@href&apos;)</span><br><span class="line"># 谓语 [last()] 可以找到最后一个元素</span><br><span class="line"></span><br><span class="line">print(result)</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&apos;link5.html&apos;]</span><br></pre></td></tr></table></figure><h4 id="7-获取倒数第二个元素的内容"><a href="#7-获取倒数第二个元素的内容" class="headerlink" title="7. 获取倒数第二个元素的内容"></a>7. 获取倒数第二个元素的内容</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">from lxml import etree</span><br><span class="line"></span><br><span class="line">html = etree.parse(&apos;hello.html&apos;)</span><br><span class="line">result = html.xpath(&apos;//li[last()-1]/a&apos;)</span><br><span class="line"></span><br><span class="line"># text 方法可以获取元素内容</span><br><span class="line">print(result[0].text)</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fourth item</span><br></pre></td></tr></table></figure><h4 id="8-获取-class-值为-bold-的标签名"><a href="#8-获取-class-值为-bold-的标签名" class="headerlink" title="8. 获取 class 值为 bold 的标签名"></a>8. 获取 <code>class</code> 值为 <code>bold</code> 的标签名</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">from lxml import etree</span><br><span class="line"></span><br><span class="line">html = etree.parse(&apos;hello.html&apos;)</span><br><span class="line"></span><br><span class="line">result = html.xpath(&apos;//*[@class=&quot;bold&quot;]&apos;)</span><br><span class="line"></span><br><span class="line"># tag方法可以获取标签名</span><br><span class="line">print(result[0].tag)</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">span</span><br></pre></td></tr></table></figure><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><p>现在我们用XPath来做一个简单的爬虫，我们尝试爬取某个贴吧里的所有帖子，并且将该这个帖子里每个楼层发布的图片下载到本地 。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Spider</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.tiebaName = input(<span class="string">"请需要访问的贴吧："</span>)</span><br><span class="line">        self.beginPage = int(input(<span class="string">"请输入起始页："</span>))</span><br><span class="line">        self.endPage = int(input(<span class="string">"请输入终止页："</span>))</span><br><span class="line"></span><br><span class="line">        self.url = <span class="string">'http://tieba.baidu.com/f'</span></span><br><span class="line">        self.ua_header = &#123;<span class="string">"User-Agent"</span>: <span class="string">"Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1 Trident/5.0;"</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">tieba_spider</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> page <span class="keyword">in</span> range(self.beginPage, self.endPage + <span class="number">1</span>):</span><br><span class="line">            pn = (page - <span class="number">1</span>) * <span class="number">50</span>  <span class="comment"># page number</span></span><br><span class="line">            word = &#123;<span class="string">'pn'</span>: pn, <span class="string">'kw'</span>: self.tiebaName&#125;</span><br><span class="line"></span><br><span class="line">            word = urllib.parse.urlencode(word)  <span class="comment"># 转换成url编码格式（字符串）</span></span><br><span class="line">            url = self.url + <span class="string">"?"</span> + word</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 示例：http://tieba.baidu.com/f? kw=%E7%BE%8E%E5%A5%B3 &amp; pn=50</span></span><br><span class="line">            <span class="comment"># 调用 页面处理函数 load_Page</span></span><br><span class="line">            <span class="comment"># 并且获取页面所有帖子链接,</span></span><br><span class="line">            self.load_page(url)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">load_page</span><span class="params">(self, url)</span>:</span></span><br><span class="line">        <span class="string">"""读取页面内容"""</span></span><br><span class="line">        req = requests.get(url, headers=self.ua_header)</span><br><span class="line">        html = req.text</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 解析html 为 HTML 文档</span></span><br><span class="line">        selector = etree.HTML(html)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 抓取当前页面的所有帖子的url的后半部分，也就是帖子编号</span></span><br><span class="line">        <span class="comment"># http://tieba.baidu.com/p/4884069807里的 “p/4884069807”</span></span><br><span class="line">        links = selector.xpath(<span class="string">'//div[@class="threadlist_lz clearfix"]/div/a/@href'</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># links 类型为 etreeElementString 列表</span></span><br><span class="line">        <span class="comment"># 遍历列表，并且合并成一个帖子地址，调用 图片处理函数 loadImage</span></span><br><span class="line">        <span class="keyword">for</span> link <span class="keyword">in</span> links:</span><br><span class="line">            link = <span class="string">"http://tieba.baidu.com"</span> + link</span><br><span class="line">            self.load_images(link)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 获取图片</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">load_images</span><span class="params">(self, link)</span>:</span></span><br><span class="line">        req = urllib.request.Request(link, headers=self.ua_header)</span><br><span class="line">        html = urllib.request.urlopen(req).read()</span><br><span class="line"></span><br><span class="line">        selector = etree.HTML(html)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 获取这个帖子里所有图片的src路径</span></span><br><span class="line">        images_links = selector.xpath(<span class="string">'//img[@class="BDE_Image"]/@src'</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 依次取出图片路径，下载保存</span></span><br><span class="line">        <span class="keyword">for</span> images_link <span class="keyword">in</span> images_links:</span><br><span class="line">            self.write_images(images_link)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">write_images</span><span class="params">(self, images_link)</span>:</span></span><br><span class="line">        <span class="string">"""将 images 里的二进制内容存入到 userNname 文件中"""</span></span><br><span class="line"></span><br><span class="line">        print(images_link)</span><br><span class="line">        file_name = os.path.basename(images_link)</span><br><span class="line">        print(<span class="string">"正在存储文件 %s ..."</span> % file_name)</span><br><span class="line"></span><br><span class="line">        images = requests.get(images_link).content</span><br><span class="line"></span><br><span class="line">        <span class="keyword">with</span> open(<span class="string">'./images/'</span> + str(file_name), <span class="string">'wb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">            f.write(images)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    <span class="comment"># 首先创建爬虫对象</span></span><br><span class="line">    mySpider = Spider()</span><br><span class="line">    <span class="comment"># 调用爬虫对象的方法，开始工作</span></span><br><span class="line">    mySpider.tieba_spider()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;关于Python爬虫，我们需要学习的有：&quot;&gt;&lt;a href=&quot;#关于Python爬虫，我们需要学习的有：&quot; class=&quot;headerlink&quot; title=&quot;关于Python爬虫，我们需要学习的有：&quot;&gt;&lt;/a&gt;关于Python爬虫，我们需要学习的有：&lt;/h3&gt;&lt;
      
    
    </summary>
    
      <category term="爬虫" scheme="http://gavinliu4011.github.io/categories/%E7%88%AC%E8%99%AB/"/>
    
    
      <category term="Python" scheme="http://gavinliu4011.github.io/tags/Python/"/>
    
      <category term="爬虫" scheme="http://gavinliu4011.github.io/tags/%E7%88%AC%E8%99%AB/"/>
    
      <category term="XPath" scheme="http://gavinliu4011.github.io/tags/XPath/"/>
    
      <category term="lxml" scheme="http://gavinliu4011.github.io/tags/lxml/"/>
    
  </entry>
  
  <entry>
    <title>Flask(二)</title>
    <link href="http://gavinliu4011.github.io/post/dc6a7e6c.html"/>
    <id>http://gavinliu4011.github.io/post/dc6a7e6c.html</id>
    <published>2018-04-09T23:40:03.000Z</published>
    <updated>2018-04-09T15:40:55.529Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h3><p>Flask除请求对象之外，还有一个 session 对象。它允许你在不同请求间存储特定用户的信息。它是在 Cookies 的基础上实现的，并且对 Cookies 进行密钥签名要使用会话，你需要设置一个密钥。 </p><ul><li>设置：session[‘username’] ＝ ‘xxx’</li><li>删除：session.pop(‘username’, None)</li></ul><h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, session, redirect, url_for, escape, request</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route('/')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="string">'username'</span> <span class="keyword">in</span> session:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'Logged in as %s'</span> % escape(session[<span class="string">'username'</span>])</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'You are not logged in'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route('/login', methods=['GET', 'POST'])</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">login</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">'POST'</span>:</span><br><span class="line">        session[<span class="string">'username'</span>] = request.form[<span class="string">'username'</span>]</span><br><span class="line">        <span class="keyword">return</span> redirect(url_for(<span class="string">'index'</span>))</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'''</span></span><br><span class="line"><span class="string">        &lt;form action="" method="post"&gt;</span></span><br><span class="line"><span class="string">            &lt;p&gt;&lt;input type=text name=username&gt;</span></span><br><span class="line"><span class="string">            &lt;p&gt;&lt;input type=submit value=Login&gt;</span></span><br><span class="line"><span class="string">        &lt;/form&gt;</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route('/logout')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">logout</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># remove the username from the session if it's there</span></span><br><span class="line">    session.pop(<span class="string">'username'</span>, <span class="keyword">None</span>)</span><br><span class="line">    <span class="keyword">return</span> redirect(url_for(<span class="string">'index'</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># set the secret key.  keep this really secret:</span></span><br><span class="line">app.secret_key = <span class="string">'A0Zr98j/3yX R~XHH!jmN]LWX/,?RT'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    app.run()</span><br></pre></td></tr></table></figure><h4 id="第三方session（我喜欢用这种类型）"><a href="#第三方session（我喜欢用这种类型）" class="headerlink" title="第三方session（我喜欢用这种类型）"></a>第三方session（我喜欢用这种类型）</h4><p>这里使用Redis类型，首先在虚拟环境安装两个包，分别是<code>pip install redis</code>和<code>pip install flask-session</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, session, redirect</span><br><span class="line"><span class="keyword">from</span> flask_session <span class="keyword">import</span> Session</span><br><span class="line"><span class="keyword">from</span> redis <span class="keyword">import</span> Redis</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line">app.debug = <span class="keyword">True</span></span><br><span class="line"><span class="comment"># 这里可以任意填写一个字符串，我这里是采用base64.b64encode(os.urandom(48))</span></span><br><span class="line">app.secret_key = <span class="string">'ix4En7l1Hau10aPq8kv8tuzcVl1s2Zo6eA+5+R+CXor8G3Jo0IJvcj001jz3XuXl'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app.config[<span class="string">'SESSION_TYPE'</span>] = <span class="string">'redis'</span></span><br><span class="line">app.config[<span class="string">'SESSION_REDIS'</span>] = Redis(host=<span class="string">'127.0.0.1'</span>, port=<span class="string">'6379'</span>)</span><br><span class="line">Session(app)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route('/login')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">login</span><span class="params">()</span>:</span></span><br><span class="line">    session[<span class="string">'username'</span>] = <span class="string">'gavinliu'</span></span><br><span class="line">    <span class="keyword">return</span> redirect(<span class="string">'/index'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route('/index')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">()</span>:</span></span><br><span class="line">    name = session[<span class="string">'username'</span>]</span><br><span class="line">    <span class="keyword">return</span> name</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    app.run()</span><br></pre></td></tr></table></figure><h3 id="蓝图"><a href="#蓝图" class="headerlink" title="蓝图"></a>蓝图</h3><h4 id="什么是蓝图"><a href="#什么是蓝图" class="headerlink" title="什么是蓝图"></a>什么是蓝图</h4><p>在Flask项目中可以用Blueprint(蓝图)实现模块化的应用，使用蓝图可以让应用层次更清晰，开发者更容易去维护和开发项目。蓝图将作用于相同的URL前缀的请求地址，将具有相同前缀的请求都放在一个模块中，这样查找问题，一看路由就很快的可以找到对应的视图，并解决问题了。 </p><h4 id="使用蓝图"><a href="#使用蓝图" class="headerlink" title="使用蓝图"></a>使用蓝图</h4><h5 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install flask_blueprint</span><br></pre></td></tr></table></figure><h5 id="实例化蓝图"><a href="#实例化蓝图" class="headerlink" title="实例化蓝图"></a>实例化蓝图</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">blue = Blueprint(&apos;first&apos;，__name__)</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意：</strong>Blueprint中传入了两个参数，第一个是蓝图的名称，第二个是蓝图所在的包或模块，<code>__name__</code>代表当前模块名或者包名 </p></blockquote><h5 id="注册蓝图"><a href="#注册蓝图" class="headerlink" title="注册蓝图"></a>注册蓝图</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line">app.register_blueprint(blue, url_prefix=<span class="string">'/user'</span>)</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意：</strong>注意：第一个参数即我们定义初始化定义的蓝图对象，第二个参数url_prefix表示该蓝图下，所有的url请求必须以/user开始。这样对一个模块的url可以很好的进行统一管理 </p></blockquote><h5 id="使用蓝图-1"><a href="#使用蓝图-1" class="headerlink" title="使用蓝图"></a>使用蓝图</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@blue.route('/', methods=['GET', 'POST'], endpoint='index')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 视图函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Hello World'</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>注意：</strong>这时候访问应该是127.0.0.1:5000/user/ </p></blockquote><h5 id="url-for反向解析"><a href="#url-for反向解析" class="headerlink" title="url_for反向解析"></a>url_for反向解析</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">url_for(endpoint, 参数名=value)  # 如果在路由上没有配置endpoint，第一个参数可以传递&quot;蓝图中定义的第一个参数.函数名&quot;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> url_for, redirect</span><br><span class="line"></span><br><span class="line"><span class="meta">@blue.route('/redirect/')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_redirect</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> redirect(url_for(<span class="string">'index'</span>))</span><br></pre></td></tr></table></figure><h3 id="请求扩展（装饰器实现）"><a href="#请求扩展（装饰器实现）" class="headerlink" title="请求扩展（装饰器实现）"></a>请求扩展（装饰器实现）</h3><ul><li>@app.before_request</li><li>@app.after_request</li><li>@app.errorhandler                # 状态码错误信息</li><li>@app.before_first_request   # 请求来只执行第一次</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line">app.debug = <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.before_request</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">process_request1</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">    print(<span class="string">'process_request1进来了'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.before_request</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">process_request2</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">    print(<span class="string">'process_request2进来了'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.after_request</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">process_response1</span><span class="params">(response)</span>:</span></span><br><span class="line">    print(<span class="string">'process_response1走了'</span>)</span><br><span class="line">    <span class="keyword">return</span> response</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.after_request</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">process_response2</span><span class="params">(response)</span>:</span></span><br><span class="line">    print(<span class="string">'process_response2走了'</span>)</span><br><span class="line">    <span class="keyword">return</span> response</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.before_first_request</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">first</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">    print(<span class="string">'first'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.errorhandler(404)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">error_404</span><span class="params">(arg)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'404错误了'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 可自定义模板</span></span><br><span class="line"><span class="meta">@app.template_global()</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sb</span><span class="params">(a1, a2)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> a1 + a2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用方式：&#123;&#123;sb(1,2)&#125;&#125;</span></span><br><span class="line"><span class="meta">@app.template_filter()</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">db</span><span class="params">(a1, a2, a3)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> a1 + a2 + a3</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用方式：&#123;&#123; 1|db(2,3)&#125;&#125;</span></span><br><span class="line"><span class="meta">@app.route('/')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'index函数'</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Hello World!'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    app.run()</span><br></pre></td></tr></table></figure><p>这个执行流程类似django中间件，可以参考<a href="https://gavinliu4011.github.io/post/11a0df73.html">django中间件</a></p><h3 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h3><p>其实Flask也有中间件，Django中也有中间件，但是Flask中的请求扩展就相当于Django中的中间件，而Django中的中间件却不相当于Flask中的中间件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route('/')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Hello World!'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Md</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, old_wsgi_app)</span>:</span></span><br><span class="line">        self.old_wsgi_app = old_wsgi_app</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, environ, start_response)</span>:</span></span><br><span class="line">        print(<span class="string">'开始之前'</span>)</span><br><span class="line">        ret = self.old_wsgi_app(environ, start_response)</span><br><span class="line">        print(<span class="string">'结束之后'</span>)</span><br><span class="line">        <span class="keyword">return</span> ret</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    app.wsgi_app = Md(app.wsgi_app)</span><br><span class="line">    app.run()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Session&quot;&gt;&lt;a href=&quot;#Session&quot; class=&quot;headerlink&quot; title=&quot;Session&quot;&gt;&lt;/a&gt;Session&lt;/h3&gt;&lt;p&gt;Flask除请求对象之外，还有一个 session 对象。它允许你在不同请求间存储特定用户的信息。它
      
    
    </summary>
    
      <category term="Flask" scheme="http://gavinliu4011.github.io/categories/Flask/"/>
    
    
      <category term="Python" scheme="http://gavinliu4011.github.io/tags/Python/"/>
    
      <category term="Flask" scheme="http://gavinliu4011.github.io/tags/Flask/"/>
    
  </entry>
  
  <entry>
    <title>Flask(一)</title>
    <link href="http://gavinliu4011.github.io/post/735be50e.html"/>
    <id>http://gavinliu4011.github.io/post/735be50e.html</id>
    <published>2018-04-08T20:32:28.000Z</published>
    <updated>2018-04-09T15:40:55.532Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Flask介绍"><a href="#Flask介绍" class="headerlink" title="Flask介绍"></a>Flask介绍</h3><p>Flask是一个用Python编写的Web应用程序框架。 它由Armin Ronacher开发，他领导着一个名为Pocco的Python爱好者的国际组织。 Flask基于Werkzeug WSGI工具包和Jinja2模板引擎。 </p><h4 id="WSGI"><a href="#WSGI" class="headerlink" title="WSGI"></a>WSGI</h4><p>Web服务器网关接口(WSGI)已被采纳为Python Web应用程序开发的标准。 WSGI是Web服务器和Web应用程序之间通用接口的规范。 </p><h4 id="WERKZEUG"><a href="#WERKZEUG" class="headerlink" title="WERKZEUG"></a>WERKZEUG</h4><p>它是一个WSGI工具包，它实现了请求，响应对象和其他实用程序功能。 这可以在其上构建Web框架。 Flask框架使用Werkzeug作为其一个基础模块之一。 </p><h3 id="浅谈Django、Flask和Tornado区别？"><a href="#浅谈Django、Flask和Tornado区别？" class="headerlink" title="浅谈Django、Flask和Tornado区别？"></a>浅谈Django、Flask和Tornado区别？</h3><ul><li><strong>Django：</strong>简单的说Django是一个大而全的Web框架，内置了很多组件，ORM、admin、Form、</li></ul><p>ModelForm、中间件、信号和缓存等。基于wsgi协议部署的，使用wsgiref模块实现此协议；</p><ul><li><strong>Flask：</strong>微型的小而精的Web框架，可扩展性强，内置的组件很少，需要引入第三方组件实现功能业务，如果开发简单的项目，使用Flask比较快速和方便。如果开发大型项目，需要引入大量的第三方组件，这时Flask会越来越像Django框架。基于wsgi协议部署，使用werkzeug模块实现此协议，模板系统由 Jinja2提<br>供。</li><li><strong>Tornado：</strong>是一个轻量级的Web框架，可扩展性强，用于快速开发简单程序，用于强大的异步非阻塞<br>和内置WebSocket功能。</li></ul><h3 id="Flask快速入门"><a href="#Flask快速入门" class="headerlink" title="Flask快速入门"></a>Flask快速入门</h3><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>在创建项目之前我们需要安装Flask，当然在这之前应该创建虚拟环境,在虚拟环境中安装Flask，在这里就不多说：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install Flask</span><br></pre></td></tr></table></figure><h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route('/')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello_world</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Hello World!'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    app.run()</span><br></pre></td></tr></table></figure><p>参数介绍：</p><p>flask(import_name, static_url_path, template_folder, instance_path, instance_relative_config, root_path, static_folder)</p><ul><li><strong>import_name：</strong>要创建的app的名称 </li><li><strong>static_url_path：</strong>用来指定url路径中<code>static</code>代表的路径，可以看作别名，类似Django中的<code>STATICFILES_DIRS</code>配置，static用来存放静态文件，默认为<code>static</code> </li><li><strong>static_folder：</strong>指定静态文件的存放目录，默认为<code>static</code> </li><li><strong>template_folder：</strong>指定模板文件的存放目录，默认为<code>templates</code> </li><li><strong>root_path：</strong>应用搜索<code>static、templates</code>等目录的根目录，也就是说，会在<code>root_path</code>指定的目录下搜索<code>static、templates</code>文件夹 <ul><li>如果你没有指定<code>root_path</code>，那么Flask就会将<code>import_name</code>所在的目录作为<code>root_oath</code></li></ul></li><li><strong>instance_relative_config：</strong>这个参数只在为app生成配置的时候有用，app在生成Config的时候，<code>make_config</code>传递进入的是<code>root_path</code>还是在实例化<code>app</code>时指定的<code>instance_path</code></li><li><strong>instance_path：</strong>当<code>instance_relative_config=True</code>的时候该参数才有效 ，如果<code>instance_path=None(默认)</code>，默认搜索配置文件的路径就是<code>root_path</code>下的<code>instance/</code>目录</li></ul><h4 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h4><p>flask中的配置文件是一个flask.config.Config对象（继承字典）,默认配置为 :</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        &apos;DEBUG&apos;: get_debug_flag(default=False),  # 是否开启Debug模式</span><br><span class="line">        &apos;TESTING&apos;: False,  # 是否开启测试模式</span><br><span class="line">        &apos;PROPAGATE_EXCEPTIONS&apos;: None,</span><br><span class="line">        &apos;PRESERVE_CONTEXT_ON_EXCEPTION&apos;: None,</span><br><span class="line">        &apos;SECRET_KEY&apos;: None,</span><br><span class="line">        &apos;PERMANENT_SESSION_LIFETIME&apos;: timedelta(days=31),</span><br><span class="line">        &apos;USE_X_SENDFILE&apos;: False,</span><br><span class="line">        &apos;LOGGER_NAME&apos;: None,</span><br><span class="line">        &apos;LOGGER_HANDLER_POLICY&apos;: &apos;always&apos;,</span><br><span class="line">        &apos;SERVER_NAME&apos;: None,</span><br><span class="line">        &apos;APPLICATION_ROOT&apos;: None,</span><br><span class="line">        &apos;SESSION_COOKIE_NAME&apos;: &apos;session&apos;,</span><br><span class="line">        &apos;SESSION_COOKIE_DOMAIN&apos;: None,</span><br><span class="line">        &apos;SESSION_COOKIE_PATH&apos;: None,</span><br><span class="line">        &apos;SESSION_COOKIE_HTTPONLY&apos;: True,</span><br><span class="line">        &apos;SESSION_COOKIE_SECURE&apos;: False,</span><br><span class="line">        &apos;SESSION_REFRESH_EACH_REQUEST&apos;: True,</span><br><span class="line">        &apos;MAX_CONTENT_LENGTH&apos;: None,</span><br><span class="line">        &apos;SEND_FILE_MAX_AGE_DEFAULT&apos;: timedelta(hours=12),</span><br><span class="line">        &apos;TRAP_BAD_REQUEST_ERRORS&apos;: False,</span><br><span class="line">        &apos;TRAP_HTTP_EXCEPTIONS&apos;: False,</span><br><span class="line">        &apos;EXPLAIN_TEMPLATE_LOADING&apos;: False,</span><br><span class="line">        &apos;PREFERRED_URL_SCHEME&apos;: &apos;http&apos;,</span><br><span class="line">        &apos;JSON_AS_ASCII&apos;: True,</span><br><span class="line">        &apos;JSON_SORT_KEYS&apos;: True,</span><br><span class="line">        &apos;JSONIFY_PRETTYPRINT_REGULAR&apos;: True,</span><br><span class="line">        &apos;JSONIFY_MIMETYPE&apos;: &apos;application/json&apos;,</span><br><span class="line">        &apos;TEMPLATES_AUTO_RELOAD&apos;: None,</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>如果需要修改配置，可以根据下面的方式修改：</p><ol><li><p>方式一</p><p>app.config[DEBUG]=True</p><blockquote><p>注意：由于Config对象本质上是字典，可以使用app.config.update(…)</p></blockquote></li><li><p>方式二</p><p>app.config.form_pyfile(‘python文件名称’)</p><p>如:settings.py </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DEBUG = <span class="keyword">True</span></span><br></pre></td></tr></table></figure><p>app.config.from_pyfile(‘settings.py’) </p></li><li><p>方式三</p><p>app.config.form_envvar(‘环境变量名称’)</p><p>环境变量的值为python文件名称，内部调用form_pyfile方法</p></li><li><p>方式四</p><p>app.config.form_json(‘json文件名称’)</p><p>json文件必须是json格式，内部会执行json.loads</p></li><li><p>方式五</p><p>app.config.from_mapping({‘DEBUG’:True}) </p></li><li><p>方式六（推荐使用）</p><p>app.config.from_object(‘python类或类的路径’)   #默认从根目录开始 </p><ul><li>settings.py文件</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">class Config(object):</span><br><span class="line">    &quot;&quot;&quot;应用程序配置类&quot;&quot;&quot;</span><br><span class="line">    # 开启调试模式</span><br><span class="line">    DEBUG = True</span><br><span class="line"></span><br><span class="line">    # logging等级</span><br><span class="line">    LOGGIONG_LEVEL = logging.DEBUG</span><br><span class="line">    # flask-sqlalchemy使用的参数</span><br><span class="line">    SQLALCHEMY_DATABASE_URI = &apos;mysql+pymysql://root:root@127.0.0.1:3306/ehome&apos;</span><br><span class="line">    # 追踪数据库的修改行为，如果不设置会报警告，不影响代码的执行</span><br><span class="line">    SQLALCHEMY_TRACK_MODIFICATIONS = True</span><br><span class="line">    # 显示sql语句</span><br><span class="line">    # SQLALCHEMY_ECHO = True</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class DevelopConfig(Config):</span><br><span class="line">    &quot;&quot;&quot;开发阶段下的配置子类&quot;&quot;&quot;</span><br><span class="line">    # logging等级</span><br><span class="line">    LOGGIONG_LEVEL = logging.DEBUG</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class UnitTestConfig(Config):</span><br><span class="line">    &quot;&quot;&quot;单元测试配置子类&quot;&quot;&quot;</span><br><span class="line">    # logging等级</span><br><span class="line">    LOGGIONG_LEVEL = logging.DEBUG</span><br><span class="line">    SQLALCHEMY_DATABASE_URI = &apos;mysql://root:root@127.0.0.1:3306/ehome_test&apos;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class ProductionConfig(Config):</span><br><span class="line">    &quot;&quot;&quot;生产环境下配置子类&quot;&quot;&quot;</span><br><span class="line">    # logging等级</span><br><span class="line">    LOGGIONG_LEVEL = logging.WARNING</span><br><span class="line">    DEBUG = False</span><br><span class="line">    SQLALCHEMY_DATABASE_URI = &apos;mysql://root:root@47.106.93.190:3306127.0.0.1:3306/ehome&apos;</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意：</strong>settings.py文件默认路径要放在程序root_path目录，如果instance_relative_config为<code>True</code>，则就是instance_path目录</p></blockquote></li></ol><h4 id="路由系统"><a href="#路由系统" class="headerlink" title="路由系统"></a>路由系统</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># @app.route('/user/&lt;username&gt;')</span></span><br><span class="line"><span class="comment"># @app.route('/post/&lt;int:post_id&gt;')</span></span><br><span class="line"><span class="comment"># @app.route('/post/float:post_id')</span></span><br><span class="line"><span class="comment"># @app.route('/post/path:path')</span></span><br><span class="line"><span class="comment"># @app.route('/login', methods=['GET', 'POST'])</span></span><br></pre></td></tr></table></figure><p>以上五种路由是最常用的，下面再来了解一下路由的执行过程：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@app.route('/', methods=['GET','POST'], endpoint='hello')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Hello World!'</span></span><br></pre></td></tr></table></figure><ol><li><p>当执行app.route(‘/‘,methods=[‘GET’,’POST’],endpoint=’hello’)时会执行如下代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">route</span><span class="params">(self, rule, **options)</span>:</span></span><br><span class="line">    <span class="comment"># self 是app对象</span></span><br><span class="line">    <span class="comment"># rule = '/'</span></span><br><span class="line">    <span class="comment"># options = &#123;methods=['GET','POST'], endpoint='hello'&#125;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decorator</span><span class="params">(f)</span>:</span></span><br><span class="line">        endpoint = options.pop(<span class="string">'endpoint'</span>, <span class="keyword">None</span>)</span><br><span class="line">        self.add_url_rule(rule, endpoint, f, **options)</span><br><span class="line">    <span class="keyword">return</span> f</span><br><span class="line">    <span class="keyword">return</span> decorator</span><br></pre></td></tr></table></figure><p>实质就是<strong>decorator = app.route(‘/‘,methods=[‘GET’,’POST’],endpoint=’hello’)</strong></p></li><li><p>有返回值后，实际上就是<strong>@decorator</strong>，这次执行decorator函数会把index函数当做参数传入</p></li></ol><p>我们这里写的路由其实就是执行了<strong>app.add_url_rule(‘/‘, ‘hello’, index, methods=[‘GET’,’POST‘])</strong>这句代码，这就跟django框架一样了</p><p>在来看看 @app.route和app.add_url_rule常用参数（只是部分）：</p><ul><li><p>rule：URL规则</p></li><li><p>view_func：视图函数名称</p></li><li><p>defaults=None：默认值，当URL中无参数，函数需要参数时，使用defaults={‘k’:’v’}为函数提供参数</p></li><li><p>endpoint=None：名称，用于反向生成URL，即： url_for(‘名称’)</p></li><li><p>methods=None：允许的请求方式，如：[‘GET’,’POST’]</p></li><li><p>strict_slashes=None：对URL最后的 / 符号是否严格要求</p></li><li><p>redirect_to=None：重定向到指定地址，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@app.route(&apos;/index/&lt;int:nid&gt;&apos;, redirect_to=&apos;/home/&lt;nid&gt;&apos;)</span><br><span class="line">或</span><br><span class="line">def func(adapter, nid):</span><br><span class="line">return &quot;/home/888&quot;</span><br><span class="line">@app.route(&apos;/index/&lt;int:nid&gt;&apos;, redirect_to=func)</span><br></pre></td></tr></table></figure></li></ul><p>所有的路由系统都是基于一下对应关系来处理 ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">DEFAULT_CONVERTERS = &#123;</span><br><span class="line">    &apos;default&apos;:          UnicodeConverter,</span><br><span class="line">    &apos;string&apos;:           UnicodeConverter,</span><br><span class="line">    &apos;any&apos;:              AnyConverter,</span><br><span class="line">    &apos;path&apos;:             PathConverter,</span><br><span class="line">    &apos;int&apos;:              IntegerConverter,</span><br><span class="line">    &apos;float&apos;:            FloatConverter,</span><br><span class="line">    &apos;uuid&apos;:             UUIDConverter,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：此配置在werkzeug包下routing.py文件中</p></blockquote><p>以上的路由其实已经够用了，但是不排除有一些比较另类的，这时可以考虑自定制正则路由匹配</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, views, url_for</span><br><span class="line"><span class="keyword">from</span> werkzeug.routing <span class="keyword">import</span> BaseConverter</span><br><span class="line"></span><br><span class="line">app = Flask(import_name=__name__)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RegexConverter</span><span class="params">(BaseConverter)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    自定义URL匹配正则表达式</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, url_map, regex)</span>:</span></span><br><span class="line">        super(RegexConverter, self).__init__(url_map)</span><br><span class="line">        self.regex = regex</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">to_python</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        路由匹配时，匹配成功后传递给视图函数中参数的值</span></span><br><span class="line"><span class="string">        :param value: </span></span><br><span class="line"><span class="string">        :return: </span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> int(value)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">to_url</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        使用url_for反向生成URL时，传递的参数经过该方法处理，返回的值用于生成URL中的参数</span></span><br><span class="line"><span class="string">        :param value: </span></span><br><span class="line"><span class="string">        :return: </span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        val = super(RegexConverter, self).to_url(value)</span><br><span class="line">        <span class="keyword">return</span> val</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="comment"># 为app中的url路由添加正则表达式匹配</span></span><br><span class="line">app.url_map.converters[<span class="string">'regex'</span>] = RegexConverter</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route('/index/&lt;regex("\d+"):nid&gt;')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">(nid)</span>:</span></span><br><span class="line">    print(url_for(<span class="string">'index'</span>, nid=<span class="string">'666'</span>))</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Index'</span></span><br></pre></td></tr></table></figure><h4 id="请求和响应"><a href="#请求和响应" class="headerlink" title="请求和响应"></a>请求和响应</h4><h5 id="请求相关信息"><a href="#请求相关信息" class="headerlink" title="请求相关信息"></a>请求相关信息</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># request.method</span></span><br><span class="line"><span class="comment"># request.args</span></span><br><span class="line"><span class="comment"># request.form</span></span><br><span class="line"><span class="comment"># request.values</span></span><br><span class="line"><span class="comment"># request.cookies</span></span><br><span class="line"><span class="comment"># request.headers</span></span><br><span class="line"><span class="comment"># request.path</span></span><br><span class="line"><span class="comment"># request.full_path</span></span><br><span class="line"><span class="comment"># request.script_root</span></span><br><span class="line"><span class="comment"># request.url</span></span><br><span class="line"><span class="comment"># request.base_url</span></span><br><span class="line"><span class="comment"># request.url_root</span></span><br><span class="line"><span class="comment"># request.host_url</span></span><br><span class="line"><span class="comment"># request.host</span></span><br><span class="line"><span class="comment"># request.files</span></span><br><span class="line"><span class="comment"># obj = request.files['the_file_name']</span></span><br><span class="line"><span class="comment"># obj.save('/var/www/uploads/' + secure_filename(f.filename))</span></span><br></pre></td></tr></table></figure><h5 id="响应相关信息"><a href="#响应相关信息" class="headerlink" title="响应相关信息"></a>响应相关信息</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># return '字符串'</span></span><br><span class="line"><span class="comment"># return render_template('html模板路径',**&#123;&#125;)</span></span><br><span class="line"><span class="comment"># return redirect('/index.html')</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># response = make_response(render_template('index.html'))</span></span><br><span class="line"><span class="comment"># response是flask.wrappers.Response类型</span></span><br><span class="line"><span class="comment"># response.delete_cookie('key')</span></span><br><span class="line"><span class="comment"># response.set_cookie('key', 'value')</span></span><br><span class="line"><span class="comment"># response.headers['X-Something'] = 'A value'</span></span><br><span class="line"><span class="comment"># return response</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Flask介绍&quot;&gt;&lt;a href=&quot;#Flask介绍&quot; class=&quot;headerlink&quot; title=&quot;Flask介绍&quot;&gt;&lt;/a&gt;Flask介绍&lt;/h3&gt;&lt;p&gt;Flask是一个用Python编写的Web应用程序框架。 它由Armin Ronacher开发，他领
      
    
    </summary>
    
      <category term="Flask" scheme="http://gavinliu4011.github.io/categories/Flask/"/>
    
    
      <category term="Python" scheme="http://gavinliu4011.github.io/tags/Python/"/>
    
      <category term="Flask" scheme="http://gavinliu4011.github.io/tags/Flask/"/>
    
  </entry>
  
  <entry>
    <title>Python版RabbitMQ消息队列之RPC（六）</title>
    <link href="http://gavinliu4011.github.io/post/8d587096.html"/>
    <id>http://gavinliu4011.github.io/post/8d587096.html</id>
    <published>2018-03-22T23:26:15.000Z</published>
    <updated>2018-03-22T15:26:38.638Z</updated>
    
    <content type="html"><![CDATA[<h2 id="远程过程调用（RPC）"><a href="#远程过程调用（RPC）" class="headerlink" title="远程过程调用（RPC）"></a>远程过程调用（RPC）</h2><p>在第二篇教程中我们介绍了如何使用工作队列（work queue）在多个工作者（woker）中间分发耗时的任务。</p><p>可是如果我们需要将一个函数运行在远程计算机上并且等待从那儿获取结果时，该怎么办呢？这就是另外的故事了。这种模式通常被称为远程过程调用（Remote Procedure Call）或者RPC。</p><p>这篇教程中，我们会使用RabbitMQ来构建一个RPC系统：包含一个客户端和一个RPC服务器。现在的情况是，我们没有一个值得被分发的足够耗时的任务，所以接下来，我们会创建一个模拟RPC服务来返回斐波那契数列。</p><h3 id="客户端接口"><a href="#客户端接口" class="headerlink" title="客户端接口"></a>客户端接口</h3><p>为了展示RPC服务如何使用，我们创建了一个简单的客户端类。它会暴露出一个名为“call”的方法用来发送一个RPC请求，并且在收到回应前保持阻塞。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fibonacci_rpc = FibonacciRpcClient()</span><br><span class="line">result = fibonacci_rpc.call(4)</span><br><span class="line">print(&quot;fib(4) is %r&quot; % (result,))</span><br></pre></td></tr></table></figure><blockquote><h4 id="关于RPC的注意事项："><a href="#关于RPC的注意事项：" class="headerlink" title="关于RPC的注意事项："></a>关于RPC的注意事项：</h4><p>尽管RPC在计算领域是一个常用模式，但它也经常被诟病。当一个问题被抛出的时候，程序员往往意识不到这到底是由本地调用还是由较慢的RPC调用引起的。同样的困惑还来自于系统的不可预测性和给调试工作带来的不必要的复杂性。跟软件精简不同的是，滥用RPC会导致不可维护的<a href="http://zh.wikipedia.org/wiki/%E9%9D%A2%E6%9D%A1%E5%BC%8F%E4%BB%A3%E7%A0%81" target="_blank" rel="noopener">面条代码</a>.</p><p>考虑到这一点，牢记以下建议：</p><p>确保能够明确的搞清楚哪个函数是本地调用的，哪个函数是远程调用的。给你的系统编写文档。保持各个组件间的依赖明确。处理错误案例。明了客户端改如何处理RPC服务器的宕机和长时间无响应情况。</p><p>当对避免使用RPC有疑问的时候。如果可以的话，你应该尽量使用异步管道来代替RPC类的阻塞。结果被异步地推送到下一个计算场景。</p></blockquote><h3 id="回调队列"><a href="#回调队列" class="headerlink" title="回调队列"></a>回调队列</h3><p>一般来说通过RabbitMQ来实现RPC是很容易的。一个客户端发送请求信息，服务器端将其应用到一个回复信息中。为了接收到回复信息，客户端需要在发送请求的时候同时发送一个回调队列（callback queue）的地址。我们试试看：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">result = channel.queue_declare(exclusive=True)</span><br><span class="line">callback_queue = result.method.queue</span><br><span class="line"></span><br><span class="line">channel.basic_publish(exchange=&apos;&apos;,</span><br><span class="line">                      routing_key=&apos;rpc_queue&apos;,</span><br><span class="line">                      properties=pika.BasicProperties(</span><br><span class="line">                            reply_to = callback_queue,</span><br><span class="line">                            ),</span><br><span class="line">                      body=request)</span><br><span class="line"></span><br><span class="line"># ... and some code to read a response message from the callback_queue ...</span><br></pre></td></tr></table></figure><blockquote><h4 id="消息属性"><a href="#消息属性" class="headerlink" title="消息属性"></a>消息属性</h4><p>AMQP协议给消息预定义了一系列的14个属性。大多数属性很少会用到，除了以下几个：</p><ul><li>delivery_mode（投递模式）：将消息标记为持久的（值为2）或暂存的（除了2之外的其他任何值）。第二篇教程里接触过这个属性，记得吧？</li><li>content_type（内容类型）:用来描述编码的mime-type。例如在实际使用中常常使用application/json来描述JOSN编码类型。</li><li>reply_to（回复目标）：通常用来命名回调队列。</li><li>correlation_id（关联标识）：用来将RPC的响应和请求关联起来。</li></ul></blockquote><h3 id="关联标识"><a href="#关联标识" class="headerlink" title="关联标识"></a>关联标识</h3><p>上边介绍的方法中，我们建议给每一个RPC请求新建一个回调队列。这不是一个高效的做法，幸好这儿有一个更好的办法 —— 我们可以为每个客户端只建立一个独立的回调队列。</p><p>这就带来一个新问题，当此队列接收到一个响应的时候它无法辨别出这个响应是属于哪个请求的。<strong>correlation_id</strong> 就是为了解决这个问题而来的。我们给每个请求设置一个独一无二的值。稍后，当我们从回调队列中接收到一个消息的时候，我们就可以查看这条属性从而将响应和请求匹配起来。如果我们接手到的消息的correlation_id是未知的，那就直接销毁掉它，因为它不属于我们的任何一条请求。</p><p>你也许会问，为什么我们接收到未知消息的时候不抛出一个错误，而是要将它忽略掉？这是为了解决服务器端有可能发生的竞争情况。尽管可能性不大，但RPC服务器还是有可能在已将应答发送给我们但还未将确认消息发送给请求的情况下死掉。如果这种情况发生，RPC在重启后会重新处理请求。这就是为什么我们必须在客户端优雅的处理重复响应，同时RPC也需要尽可能保持幂等性。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><img src="http://www.rabbitmq.com/img/tutorials/python-six.png" alt="img"></p><p>我们的RPC如此工作:</p><ul><li>当客户端启动的时候，它创建一个匿名独享的回调队列。</li><li>在RPC请求中，客户端发送带有两个属性的消息：一个是设置回调队列的 <em>reply_to</em> 属性，另一个是设置唯一值的 <em>correlation_id</em> 属性。</li><li>将请求发送到一个 <em>rpc_queue</em> 队列中。</li><li>RPC工作者（又名：服务器）等待请求发送到这个队列中来。当请求出现的时候，它执行他的工作并且将带有执行结果的消息发送给reply_to字段指定的队列。</li><li>客户端等待回调队列里的数据。当有消息出现的时候，它会检查correlation_id属性。如果此属性的值与请求匹配，将它返回给应用。</li></ul><h2 id="整合到一起"><a href="#整合到一起" class="headerlink" title="整合到一起"></a>整合到一起</h2><p>rpc_server.py代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line">import pika</span><br><span class="line"></span><br><span class="line">connection = pika.BlockingConnection(pika.ConnectionParameters(</span><br><span class="line">        host=&apos;localhost&apos;))</span><br><span class="line"></span><br><span class="line">channel = connection.channel()</span><br><span class="line"></span><br><span class="line">channel.queue_declare(queue=&apos;rpc_queue&apos;)</span><br><span class="line"></span><br><span class="line">def fib(n):</span><br><span class="line">    if n == 0:</span><br><span class="line">        return 0</span><br><span class="line">    elif n == 1:</span><br><span class="line">        return 1</span><br><span class="line">    else:</span><br><span class="line">        return fib(n-1) + fib(n-2)</span><br><span class="line"></span><br><span class="line">def on_request(ch, method, props, body):</span><br><span class="line">    n = int(body)</span><br><span class="line"></span><br><span class="line">    print(&quot; [.] fib(%s)&quot;  % (n,))</span><br><span class="line">    response = fib(n)</span><br><span class="line"></span><br><span class="line">    ch.basic_publish(exchange=&apos;&apos;,</span><br><span class="line">                     routing_key=props.reply_to,</span><br><span class="line">                     properties=pika.BasicProperties(correlation_id = \</span><br><span class="line">                                                     props.correlation_id),</span><br><span class="line">                     body=str(response))</span><br><span class="line">    ch.basic_ack(delivery_tag = method.delivery_tag)</span><br><span class="line"></span><br><span class="line">channel.basic_qos(prefetch_count=1)</span><br><span class="line">channel.basic_consume(on_request, queue=&apos;rpc_queue&apos;)</span><br><span class="line"></span><br><span class="line">print(&quot; [x] Awaiting RPC requests&quot;)</span><br><span class="line">channel.start_consuming()</span><br></pre></td></tr></table></figure><p>服务器端代码相当简单：</p><ul><li>（4）像往常一样，我们建立连接，声明队列</li><li>（11）我们声明我们的fibonacci函数，它假设只有合法的正整数当作输入。（别指望这个函数能处理很大的数值，函数递归你们都懂得…）</li><li>（19）我们为 basic_consume 声明了一个回调函数，这是RPC服务器端的核心。它执行实际的操作并且作出响应。</li><li>（32）或许我们希望能在服务器上多开几个线程。为了能将负载平均地分摊到多个服务器，我们需要将 prefetch_count 设置好。</li></ul><p>rpc_client.py 代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line">import pika</span><br><span class="line">import uuid</span><br><span class="line"></span><br><span class="line">class FibonacciRpcClient(object):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.connection = pika.BlockingConnection(pika.ConnectionParameters(</span><br><span class="line">                host=&apos;localhost&apos;))</span><br><span class="line"></span><br><span class="line">        self.channel = self.connection.channel()</span><br><span class="line"></span><br><span class="line">        result = self.channel.queue_declare(exclusive=True)</span><br><span class="line">        self.callback_queue = result.method.queue</span><br><span class="line"></span><br><span class="line">        self.channel.basic_consume(self.on_response, no_ack=True,</span><br><span class="line">                                   queue=self.callback_queue)</span><br><span class="line"></span><br><span class="line">    def on_response(self, ch, method, props, body):</span><br><span class="line">        if self.corr_id == props.correlation_id:</span><br><span class="line">            self.response = body</span><br><span class="line"></span><br><span class="line">    def call(self, n):</span><br><span class="line">        self.response = None</span><br><span class="line">        self.corr_id = str(uuid.uuid4())</span><br><span class="line">        self.channel.basic_publish(exchange=&apos;&apos;,</span><br><span class="line">                                   routing_key=&apos;rpc_queue&apos;,</span><br><span class="line">                                   properties=pika.BasicProperties(</span><br><span class="line">                                         reply_to = self.callback_queue,</span><br><span class="line">                                         correlation_id = self.corr_id,</span><br><span class="line">                                         ),</span><br><span class="line">                                   body=str(n))</span><br><span class="line">        while self.response is None:</span><br><span class="line">            self.connection.process_data_events()</span><br><span class="line">        return int(self.response)</span><br><span class="line"></span><br><span class="line">fibonacci_rpc = FibonacciRpcClient()</span><br><span class="line"></span><br><span class="line">print(&quot; [x] Requesting fib(30)&quot;)</span><br><span class="line">response = fibonacci_rpc.call(30)</span><br><span class="line">print(&quot; [.] Got %r&quot; % (response,))</span><br></pre></td></tr></table></figure><p>客户端代码稍微有点难懂：</p><ul><li>（7）建立连接、通道并且为回复（replies）声明独享的回调队列。</li><li>（16）我们订阅这个回调队列，以便接收RPC的响应。</li><li>（18）“on_response”回调函数对每一个响应执行一个非常简单的操作，检查每一个响应消息的correlation_id属性是否与我们期待的一致，如果一致，将响应结果赋给self.response，然后跳出consuming循环。</li><li>（23）接下来，我们定义我们的主要方法 call 方法。它执行真正的RPC请求。</li><li>（24）在这个方法中，首先我们生成一个唯一的 correlation_id 值并且保存起来，’on_response’回调函数会用它来获取符合要求的响应。</li><li>（25）接下来，我们将带有 reply_to 和 correlation_id 属性的消息发布出去。</li><li>（32）现在我们可以坐下来，等待正确的响应到来。</li><li>（33）最后，我们将响应返回给用户。</li></ul><p>我们的RPC服务已经准备就绪了，现在启动服务器端：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ python rpc_server.py</span><br><span class="line"> [x] Awaiting RPC requests</span><br></pre></td></tr></table></figure><p>运行客户端，请求一个fibonacci队列。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ python rpc_client.py</span><br><span class="line"> [x] Requesting fib(30)</span><br></pre></td></tr></table></figure><p>此处呈现的设计并不是实现RPC服务的唯一方式，但是他有一些重要的优势：</p><ul><li>如果RPC服务器运行的过慢的时候，你可以通过运行另外一个服务器端轻松扩展它。试试在控制台中运行第二个 rpc_server.py 。</li><li>在客户端，RPC请求只发送或接收一条消息。不需要像 queue_declare 这样的异步调用。所以RPC客户端的单个请求只需要一个网络往返。</li></ul><p>我们的代码依旧非常简单，而且没有试图去解决一些复杂（但是重要）的问题，如：</p><ul><li>当没有服务器运行时，客户端如何作出反映。</li><li>客户端是否需要实现类似RPC超时的东西。</li><li>如果服务器发生故障，并且抛出异常，应该被转发到客户端吗？</li><li>在处理前，防止混入无效的信息（例如检查边界）</li></ul><blockquote><p>如果你想做一些实验，你会发现<a href="http://www.rabbitmq.com/plugins.html" target="_blank" rel="noopener">rabbitmq-management plugin</a>在观测队列方面是很有用处的。</p></blockquote><p>（完整的<a href="https://github.com/rabbitmq/rabbitmq-tutorials/blob/master/python/rpc_client.py" target="_blank" rel="noopener">rpc_client.py</a> 和 <a href="https://github.com/rabbitmq/rabbitmq-tutorials/blob/master/python/rpc_server.py" target="_blank" rel="noopener">rpc_server.py</a>代码)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;远程过程调用（RPC）&quot;&gt;&lt;a href=&quot;#远程过程调用（RPC）&quot; class=&quot;headerlink&quot; title=&quot;远程过程调用（RPC）&quot;&gt;&lt;/a&gt;远程过程调用（RPC）&lt;/h2&gt;&lt;p&gt;在第二篇教程中我们介绍了如何使用工作队列（work queue）在多
      
    
    </summary>
    
      <category term="RabbitMQ" scheme="http://gavinliu4011.github.io/categories/RabbitMQ/"/>
    
    
      <category term="Python" scheme="http://gavinliu4011.github.io/tags/Python/"/>
    
      <category term="RabbitMQ" scheme="http://gavinliu4011.github.io/tags/RabbitMQ/"/>
    
      <category term="消息队列" scheme="http://gavinliu4011.github.io/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>Python版RabbitMQ消息队列之主题交换机（五）</title>
    <link href="http://gavinliu4011.github.io/post/3a0f7196.html"/>
    <id>http://gavinliu4011.github.io/post/3a0f7196.html</id>
    <published>2018-03-21T13:47:52.000Z</published>
    <updated>2018-03-22T15:26:38.641Z</updated>
    
    <content type="html"><![CDATA[<h2 id="为什么需要主题交换机？"><a href="#为什么需要主题交换机？" class="headerlink" title="为什么需要主题交换机？"></a>为什么需要主题交换机？</h2><p>上一篇教程里，我们改进了我们的日志系统。我们使用直连交换机替代了扇型交换机，从只能盲目的广播消息改进为有可能选择性的接收日志。</p><p>尽管直连交换机能够改善我们的系统，但是它也有它的限制 —— 没办法基于多个标准执行路由操作。</p><p>在我们的日志系统中，我们不只希望订阅基于严重程度的日志，同时还希望订阅基于发送来源的日志。Unix工具<a href="http://en.wikipedia.org/wiki/Syslog" target="_blank" rel="noopener">syslog</a>就是同时基于严重程度-severity (info/warn/crit…) 和 设备-facility (auth/cron/kern…)来路由日志的。</p><p>如果这样的话，将会给予我们非常大的灵活性，我们既可以监听来源于“cron”的严重程度为“critical errors”的日志，也可以监听来源于“kern”的所有日志。</p><p>为了实现这个目的，接下来我们学习如何使用另一种更复杂的交换机 —— 主题交换机。</p><h2 id="主题交换机"><a href="#主题交换机" class="headerlink" title="主题交换机"></a>主题交换机</h2><p>发送到主题交换机（topic exchange）的消息不可以携带随意什么样子的路由键（routing_key），它的路由键必须是一个由<code>.</code>分隔开的词语列表。这些单词随便是什么都可以，但是最好是跟携带它们的消息有关系的词汇。以下是几个推荐的例子：”stock.usd.nyse”, “nyse.vmw”, “quick.orange.rabbit”。词语的个数可以随意，但是不要超过255字节。</p><p>绑定键也必须拥有同样的格式。主题交换机背后的逻辑跟直连交换机很相似 —— 一个携带着特定路由键的消息会被主题交换机投递给绑定键与之想匹配的队列。但是它的绑定键和路由键有两个特殊应用方式：</p><ul><li><code>*</code> (星号) 用来表示一个单词.</li><li><code>#</code> (井号) 用来表示任意数量（零个或多个）单词。</li></ul><p>下边用图说明：<br><img src="http://www.rabbitmq.com/img/tutorials/python-five.png" alt="None"></p><p>这个例子里，我们发送的所有消息都是用来描述小动物的。发送的消息所携带的路由键是由三个单词所组成的，这三个单词被两个<code>.</code>分割开。路由键里的第一个单词描述的是动物的手脚的利索程度，第二个单词是动物的颜色，第三个是动物的种类。所以它看起来是这样的： <code>&lt;celerity&gt;.&lt;colour&gt;.&lt;species&gt;</code>。</p><p>我们创建了三个绑定：Q1的绑定键为 <code>*.orange.*</code>，Q2的绑定键为 <code>*.*.rabbit</code> 和 <code>lazy.#</code> 。</p><p>这三个绑定键被可以总结为：</p><ul><li>Q1 对<em>所有的桔黄色动物</em>都感兴趣。</li><li>Q2 则是对<em>所有的兔子</em>和<em>所有懒惰的动物</em>感兴趣。</li></ul><p>一个携带有 <code>quick.orange.rabbit</code> 的消息将会被分别投递给这两个队列。携带着 <code>lazy.orange.elephant</code> 的消息同样也会给两个队列都投递过去。另一方面携带有 <code>quick.orange.fox</code> 的消息会投递给第一个队列，携带有 <code>lazy.brown.fox</code> 的消息会投递给第二个队列。携带有 <code>lazy.pink.rabbit</code> 的消息只会被投递给第二个队列一次，即使它同时匹配第二个队列的两个绑定。携带着 <code>quick.brown.fox</code> 的消息不会投递给任何一个队列。</p><p>如果我们违反约定，发送了一个携带有一个单词或者四个单词（<code>&quot;orange&quot;</code> or <code>&quot;quick.orange.male.rabbit&quot;</code>）的消息时，发送的消息不会投递给任何一个队列，而且会丢失掉。</p><p>但是另一方面，即使 <code>&quot;lazy.orange.male.rabbit&quot;</code> 有四个单词，他还是会匹配最后一个绑定，并且被投递到第二个队列中。</p><blockquote><h4 id="主题交换机-1"><a href="#主题交换机-1" class="headerlink" title="主题交换机"></a>主题交换机</h4><p>主题交换机是很强大的，它可以表现出跟其他交换机类似的行为</p><p>当一个队列的绑定键为 “#”（井号） 的时候，这个队列将会无视消息的路由键，接收所有的消息。</p><p>当 <code>*</code> (星号) 和 <code>#</code> (井号) 这两个特殊字符都未在绑定键中出现的时候，此时主题交换机就拥有的直连交换机的行为。</p></blockquote><h2 id="组合在一起"><a href="#组合在一起" class="headerlink" title="组合在一起"></a>组合在一起</h2><p>接下来我们会将主题交换机应用到我们的日志系统中。在开始工作前，我们假设日志的路由键由两个单词组成，路由键看起来是这样的：<code>&lt;facility&gt;.&lt;severity&gt;</code></p><p>代码跟上一篇教程差不多。</p><p>emit_log_topic.py的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line">import pika</span><br><span class="line">import sys</span><br><span class="line"></span><br><span class="line">connection = pika.BlockingConnection(pika.ConnectionParameters(</span><br><span class="line">        host=&apos;localhost&apos;))</span><br><span class="line">channel = connection.channel()</span><br><span class="line"></span><br><span class="line">channel.exchange_declare(exchange=&apos;topic_logs&apos;,</span><br><span class="line">                         type=&apos;topic&apos;)</span><br><span class="line"></span><br><span class="line">routing_key = sys.argv[1] if len(sys.argv) &gt; 1 else &apos;anonymous.info&apos;</span><br><span class="line">message = &apos; &apos;.join(sys.argv[2:]) or &apos;Hello World!&apos;</span><br><span class="line">channel.basic_publish(exchange=&apos;topic_logs&apos;,</span><br><span class="line">                      routing_key=routing_key,</span><br><span class="line">                      body=message)</span><br><span class="line">print(&quot; [x] Sent %r:%r&quot; % (routing_key, message))</span><br><span class="line">connection.close()</span><br></pre></td></tr></table></figure><p>receive_logs_topic.py的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line">import pika</span><br><span class="line">import sys</span><br><span class="line"></span><br><span class="line">connection = pika.BlockingConnection(pika.ConnectionParameters(</span><br><span class="line">        host=&apos;localhost&apos;))</span><br><span class="line">channel = connection.channel()</span><br><span class="line"></span><br><span class="line">channel.exchange_declare(exchange=&apos;topic_logs&apos;,</span><br><span class="line">                         type=&apos;topic&apos;)</span><br><span class="line"></span><br><span class="line">result = channel.queue_declare(exclusive=True)</span><br><span class="line">queue_name = result.method.queue</span><br><span class="line"></span><br><span class="line">binding_keys = sys.argv[1:]</span><br><span class="line">if not binding_keys:</span><br><span class="line">    sys.stderr.write(&quot;Usage: %s [info] [warning] [error]\n&quot; % sys.argv[0]) #定义了三种接收消息方式info,warning,error</span><br><span class="line">    sys.exit(1)</span><br><span class="line"></span><br><span class="line">for binding_key in binding_keys:</span><br><span class="line">    channel.queue_bind(exchange=&apos;topic_logs&apos;,</span><br><span class="line">                       queue=queue_name,</span><br><span class="line">                       routing_key=binding_key)</span><br><span class="line"></span><br><span class="line">print(&apos; [*] Waiting for logs. To exit press CTRL+C&apos;)</span><br><span class="line"></span><br><span class="line">def callback(ch, method, properties, body):</span><br><span class="line">    print(&quot; [x] %r:%r&quot; % (method.routing_key, body,))</span><br><span class="line"></span><br><span class="line">channel.basic_consume(callback,</span><br><span class="line">                      queue=queue_name,</span><br><span class="line">                      no_ack=True)</span><br><span class="line"></span><br><span class="line">channel.start_consuming()</span><br></pre></td></tr></table></figure><p>执行下边命令 接收所有日志：<br><code>python receive_logs_topic.py &quot;#&quot;</code></p><p>执行下边命令 接收来自”kern“设备的日志：<br><code>python receive_logs_topic.py &quot;kern.*&quot;</code></p><p>执行下边命令 只接收严重程度为”critical“的日志：<br><code>python receive_logs_topic.py &quot;*.critical&quot;</code></p><p>执行下边命令 建立多个绑定：<br><code>python receive_logs_topic.py &quot;kern.*&quot; &quot;*.critical&quot;</code></p><p>执行下边命令 发送路由键为 “kern.critical” 的日志：<br><code>python emit_log_topic.py &quot;kern.critical&quot; &quot;A critical kernel error&quot;</code></p><p>执行上边命令试试看效果吧。另外，上边代码不会对路由键和绑定键做任何假设，所以你可以在命令中使用超过两个路由键参数。</p><h3 id="如果你现在还没被搞晕，想想下边问题"><a href="#如果你现在还没被搞晕，想想下边问题" class="headerlink" title="如果你现在还没被搞晕，想想下边问题:"></a>如果你现在还没被搞晕，想想下边问题:</h3><ul><li>绑定键为 <code>*</code> 的队列会取到一个路由键为空的消息吗？</li><li>绑定键为 <code>#.*</code> 的队列会获取到一个名为<code>..</code>的路由键的消息吗？它会取到一个路由键为单个单词的消息吗？</li><li><code>a.*.#</code> 和 <code>a.#</code>的区别在哪儿？</li></ul><p>（完整代码参见<a href="https://github.com/rabbitmq/rabbitmq-tutorials/blob/master/python/emit_log_topic.py" target="_blank" rel="noopener">emit_logs_topic.py</a> and <a href="https://github.com/rabbitmq/rabbitmq-tutorials/blob/master/python/receive_logs_topic.py" target="_blank" rel="noopener">receive_logs_topic.py</a>)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;为什么需要主题交换机？&quot;&gt;&lt;a href=&quot;#为什么需要主题交换机？&quot; class=&quot;headerlink&quot; title=&quot;为什么需要主题交换机？&quot;&gt;&lt;/a&gt;为什么需要主题交换机？&lt;/h2&gt;&lt;p&gt;上一篇教程里，我们改进了我们的日志系统。我们使用直连交换机替代了扇型
      
    
    </summary>
    
      <category term="RabbitMQ" scheme="http://gavinliu4011.github.io/categories/RabbitMQ/"/>
    
    
      <category term="Python" scheme="http://gavinliu4011.github.io/tags/Python/"/>
    
      <category term="RabbitMQ" scheme="http://gavinliu4011.github.io/tags/RabbitMQ/"/>
    
      <category term="消息队列" scheme="http://gavinliu4011.github.io/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>Python版RabbitMQ消息队列之路由（四）</title>
    <link href="http://gavinliu4011.github.io/post/9d637a8e.html"/>
    <id>http://gavinliu4011.github.io/post/9d637a8e.html</id>
    <published>2018-03-20T22:50:24.000Z</published>
    <updated>2018-03-22T15:26:38.651Z</updated>
    
    <content type="html"><![CDATA[<h2 id="路由-Routing"><a href="#路由-Routing" class="headerlink" title="路由(Routing)"></a>路由(Routing)</h2><p>在前面的教程中，我们实现了一个简单的日志系统。可以把日志消息广播给多个接收者。</p><p>本篇教程中我们打算新增一个功能 —— 使得它能够只订阅消息的一个字集。例如，我们只需要把严重的错误日志信息写入日志文件（存储到磁盘），但同时仍然把所有的日志信息输出到控制台中</p><h2 id="绑定（Bindings）"><a href="#绑定（Bindings）" class="headerlink" title="绑定（Bindings）"></a>绑定（Bindings）</h2><p>前面的例子，我们已经创建过绑定（bindings），代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.queue_bind(exchange=exchange_name, queue=queue_name)</span><br></pre></td></tr></table></figure><p>绑定（binding）是指交换机（exchange）和队列（queue）的关系。可以简单理解为：这个队列（queue）对这个交换机（exchange）的消息感兴趣。</p><p>绑定的时候可以带上一个额外的routing_key参数。为了避免与basic_publish的参数混淆，我们把它叫做绑定键（binding key）。以下是如何创建一个带绑定键的绑定。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.queue_bind(exchange=exchange_name, queue=queue_name, routing_key=&apos;black&apos;)</span><br></pre></td></tr></table></figure><p>绑定键的意义取决于交换机（exchange）的类型。我们之前使用过的扇型交换机（fanout exchanges）会忽略这个值。</p><h2 id="直连交换机（Direct-exchange）"><a href="#直连交换机（Direct-exchange）" class="headerlink" title="直连交换机（Direct exchange）"></a>直连交换机（Direct exchange）</h2><p>我们的日志系统广播所有的消息给所有的消费者（consumers）。我们打算扩展它，使其基于日志的严重程度进行消息过滤。例如我们也许只是希望将比较严重的错误（error）日志写入磁盘，以免在警告（warning）或者信息（info）日志上浪费磁盘空间。</p><p>我们使用的扇型交换机（fanout exchange）没有足够的灵活性 —— 它能做的仅仅是广播。</p><p>我们将会使用直连交换机（direct exchange）来代替。路由的算法很简单 —— 交换机将会对绑定键（binding key）和路由键（routing key）进行精确匹配，从而确定消息该分发到哪个队列。</p><p>下图能够很好的描述这个场景：</p><p><img src="http://www.rabbitmq.com/img/tutorials/direct-exchange.png" alt="img"></p><p>在这个场景中，我们可以看到直连交换机 X和两个队列进行了绑定。第一个队列使用orange作为绑定键，第二个队列有两个绑定，一个使用black作为绑定键，另外一个使用green。</p><p>这样以来，当路由键为orange的消息发布到交换机，就会被路由到队列Q1。路由键为black或者green的消息就会路由到Q2。其他的所有消息都将会被丢弃。</p><h2 id="多个绑定（Multiple-bindings）"><a href="#多个绑定（Multiple-bindings）" class="headerlink" title="多个绑定（Multiple bindings）"></a>多个绑定（Multiple bindings）</h2><p><img src="http://www.rabbitmq.com/img/tutorials/direct-exchange-multiple.png" alt="img"></p><p>多个队列使用相同的绑定键是合法的。这个例子中，我们可以添加一个X和Q1之间的绑定，使用black绑定键。这样一来，直连交换机就和扇型交换机的行为一样，会将消息广播到所有匹配的队列。带有black路由键的消息会同时发送到Q1和Q2。</p><h2 id="发送日志"><a href="#发送日志" class="headerlink" title="发送日志"></a>发送日志</h2><p>我们将会发送消息到一个直连交换机，把日志级别作为路由键。这样接收日志的脚本就可以根据严重级别来选择它想要处理的日志。我们先看看发送日志。</p><p>我们需要创建一个交换机（exchange）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.exchange_declare(exchange=&apos;direct_logs&apos;, type=&apos;direct&apos;)</span><br></pre></td></tr></table></figure><p>然后我们发送一则消息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.basic_publish(exchange=&apos;direct_logs&apos;, routing_key=severity, body=message)</span><br></pre></td></tr></table></figure><p>我们先假设“severity”的值是info、warning、error中的一个。</p><h2 id="订阅"><a href="#订阅" class="headerlink" title="订阅"></a>订阅</h2><p>处理接收消息的方式和之前差不多，只有一个例外，我们将会为我们感兴趣的每个严重级别分别创建一个新的绑定。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">result = channel.queue_declare(exclusive=True)</span><br><span class="line">queue_name = result.method.queue</span><br><span class="line"></span><br><span class="line">for severity in severities:</span><br><span class="line">    channel.queue_bind(exchange=&apos;direct_logs&apos;, queue=queue_name, routing_key=severity)</span><br></pre></td></tr></table></figure><h2 id="代码整合"><a href="#代码整合" class="headerlink" title="代码整合"></a>代码整合</h2><p><img src="http://www.rabbitmq.com/img/tutorials/python-four.png" alt="img"></p><p>emit_log_direct.py的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line">import pika</span><br><span class="line">import sys</span><br><span class="line"></span><br><span class="line">connection = pika.BlockingConnection(pika.ConnectionParameters(host=&apos;localhost&apos;))</span><br><span class="line">channel = connection.channel()</span><br><span class="line"></span><br><span class="line">channel.exchange_declare(exchange=&apos;direct_logs&apos;, type=&apos;direct&apos;)</span><br><span class="line"></span><br><span class="line">severity = sys.argv[1] if len(sys.argv) &gt; 1 else &apos;info&apos;</span><br><span class="line">message = &apos; &apos;.join(sys.argv[2:]) or &apos;Hello World!&apos;</span><br><span class="line">channel.basic_publish(exchange=&apos;direct_logs&apos;, routing_key=severity, body=message)</span><br><span class="line">print(&quot; [x] Sent %r:%r&quot; % (severity, message))</span><br><span class="line">connection.close()</span><br></pre></td></tr></table></figure><p>receive_logs_direct.py的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line">import pika</span><br><span class="line">import sys</span><br><span class="line"></span><br><span class="line">connection = pika.BlockingConnection(pika.ConnectionParameters(host=&apos;localhost&apos;))</span><br><span class="line">channel = connection.channel()</span><br><span class="line"></span><br><span class="line">channel.exchange_declare(exchange=&apos;direct_logs&apos;, type=&apos;direct&apos;)</span><br><span class="line"></span><br><span class="line">result = channel.queue_declare(exclusive=True)</span><br><span class="line">queue_name = result.method.queue</span><br><span class="line"></span><br><span class="line">severities = sys.argv[1:]</span><br><span class="line">if not severities:</span><br><span class="line">    sys.stderr.write(&quot;Usage: %s [info] [warning] [error]\n&quot; % sys.argv[0]) #定义了三种接收消息方式info,warning,error</span><br><span class="line">    sys.exit(1)</span><br><span class="line"></span><br><span class="line">for severity in severities:</span><br><span class="line">    channel.queue_bind(exchange=&apos;direct_logs&apos;,</span><br><span class="line">                       queue=queue_name,</span><br><span class="line">                       routing_key=severity)</span><br><span class="line"></span><br><span class="line">print(&apos; [*] Waiting for logs. To exit press CTRL+C&apos;)</span><br><span class="line"></span><br><span class="line">def callback(ch, method, properties, body):</span><br><span class="line">    print(&quot; [x] %r:%r&quot; % (method.routing_key, body))</span><br><span class="line"></span><br><span class="line">channel.basic_consume(callback,</span><br><span class="line">                      queue=queue_name,</span><br><span class="line">                      no_ack=True)</span><br><span class="line"></span><br><span class="line">channel.start_consuming()</span><br></pre></td></tr></table></figure><p>如果你希望只是保存warning和error级别的日志到磁盘，只需要打开控制台并输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ python receive_logs_direct.py warning error &gt; logs_from_rabbit.log</span><br></pre></td></tr></table></figure><p>如果你希望所有的日志信息都输出到屏幕中，打开一个新的终端，然后输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ python receive_logs_direct.py info warning error</span><br><span class="line"> [*] Waiting for logs. To exit press CTRL+C</span><br></pre></td></tr></table></figure><p>如果要触发一个error级别的日志，只需要输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ python emit_log_direct.py error &quot;Run. Run. Or it will explode.&quot;</span><br><span class="line"> [x] Sent &apos;error&apos;:&apos;Run. Run. Or it will explode.&apos;</span><br></pre></td></tr></table></figure><p>这里是完整的代码：(<a href="https://github.com/rabbitmq/rabbitmq-tutorials/blob/master/python/emit_log_direct.py" target="_blank" rel="noopener">emit_log_direct.py</a>和<a href="https://github.com/rabbitmq/rabbitmq-tutorials/blob/master/python/receive_logs_direct.py" target="_blank" rel="noopener">receive_logs_direct.py</a>)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;路由-Routing&quot;&gt;&lt;a href=&quot;#路由-Routing&quot; class=&quot;headerlink&quot; title=&quot;路由(Routing)&quot;&gt;&lt;/a&gt;路由(Routing)&lt;/h2&gt;&lt;p&gt;在前面的教程中，我们实现了一个简单的日志系统。可以把日志消息广播给多个接
      
    
    </summary>
    
      <category term="RabbitMQ" scheme="http://gavinliu4011.github.io/categories/RabbitMQ/"/>
    
    
      <category term="Python" scheme="http://gavinliu4011.github.io/tags/Python/"/>
    
      <category term="RabbitMQ" scheme="http://gavinliu4011.github.io/tags/RabbitMQ/"/>
    
      <category term="消息队列" scheme="http://gavinliu4011.github.io/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>Python版RabbitMQ消息队列之发布／订阅（三）</title>
    <link href="http://gavinliu4011.github.io/post/2092e5cc.html"/>
    <id>http://gavinliu4011.github.io/post/2092e5cc.html</id>
    <published>2018-03-19T22:34:51.000Z</published>
    <updated>2018-03-22T15:26:38.645Z</updated>
    
    <content type="html"><![CDATA[<h2 id="发布／订阅"><a href="#发布／订阅" class="headerlink" title="发布／订阅"></a>发布／订阅</h2><p>在上篇教程中，我们搭建了一个工作队列，每个任务只分发给一个工作者（worker）。在本篇教程中，我们要做的跟之前完全不一样 —— 分发一个消息给多个消费者（consumers）。这种模式被称为“发布／订阅”。</p><p>为了描述这种模式，我们将会构建一个简单的日志系统。它包括两个程序——第一个程序负责发送日志消息，第二个程序负责获取消息并输出内容。</p><p>在我们的这个日志系统中，所有正在运行的接收方程序都会接受消息。我们用其中一个接收者（receiver）把日志写入硬盘中，另外一个接受者（receiver）把日志输出到屏幕上。</p><p>最终，日志消息被广播给所有的接受者（receivers）。</p><h2 id="交换机（Exchanges）"><a href="#交换机（Exchanges）" class="headerlink" title="交换机（Exchanges）"></a>交换机（Exchanges）</h2><p>前面的教程中，我们发送消息到队列并从中取出消息。现在是时候介绍RabbitMQ中完整的消息模型了。</p><p>让我们简单的概括一下之前的教程：</p><ul><li>发布者（producer）是发布消息的应用程序。</li><li>队列（queue）用于消息存储的缓冲。</li><li>消费者（consumer）是接收消息的应用程序。</li></ul><p>RabbitMQ消息模型的核心理念是：发布者（producer）不会直接发送任何消息给队列。事实上，发布者（producer）甚至不知道消息是否已经被投递到队列。</p><p>发布者（producer）只需要把消息发送给一个交换机（exchange）。交换机非常简单，它一边从发布者方接收消息，一边把消息推送到队列。交换机必须知道如何处理它接收到的消息，是应该推送到指定的队列还是是多个队列，或者是直接忽略消息。这些规则是通过交换机类型（exchange type）来定义的。</p><p><img src="http://www.rabbitmq.com/img/tutorials/exchanges.png" alt="img"></p><p>有几个可供选择的交换机类型：直连交换机（direct）, 主题交换机（topic）, （头交换机）headers和 扇型交换机（fanout）。我们在这里主要说明最后一个 —— 扇型交换机（fanout）。先创建一个fanout类型的交换机，命名为logs：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.exchange_declare(exchange=&apos;logs&apos;, type=&apos;fanout&apos;)</span><br></pre></td></tr></table></figure><p>扇型交换机（fanout）很简单，你可能从名字上就能猜测出来，它把消息发送给它所知道的所有队列。这正是我们的日志系统所需要的。</p><blockquote><h4 id="交换器列表"><a href="#交换器列表" class="headerlink" title="交换器列表"></a>交换器列表</h4><p>rabbitmqctl能够列出服务器上所有的交换器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt; $ sudo rabbitmqctl list_exchanges</span><br><span class="line">&gt; Listing exchanges ...</span><br><span class="line">&gt; logs      fanout</span><br><span class="line">&gt; amq.direct      direct</span><br><span class="line">&gt; amq.topic       topic</span><br><span class="line">&gt; amq.fanout      fanout</span><br><span class="line">&gt; amq.headers     headers</span><br><span class="line">&gt; ...done.</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p>这个列表中有一些叫做amq.*的交换器。这些都是默认创建的，不过这时候你还不需要使用他们。</p><h4 id="匿名的交换器"><a href="#匿名的交换器" class="headerlink" title="匿名的交换器"></a>匿名的交换器</h4><p>前面的教程中我们对交换机一无所知，但仍然能够发送消息到队列中。因为我们使用了命名为空字符串(“”)默认的交换机。</p><p>回想我们之前是如何发布一则消息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; channel.basic_publish(exchange=&apos;&apos;, routing_key=&apos;hello&apos;, body=message)</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p>exchange参数就是交换机的名称。空字符串代表默认或者匿名交换机：消息将会根据指定的routing_key分发到指定的队列。</p></blockquote><p>现在，我们就可以发送消息到一个具名交换机了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.basic_publish(exchange=&apos;logs&apos;, routing_key=&apos;&apos;, body=message)</span><br></pre></td></tr></table></figure><h2 id="临时队列"><a href="#临时队列" class="headerlink" title="临时队列"></a>临时队列</h2><p>你还记得之前我们使用的队列名吗（ hello和task_queue）？给一个队列命名是很重要的——我们需要把工作者（workers）指向正确的队列。如果你打算在发布者（producers）和消费者（consumers）之间共享同队列的话，给队列命名是十分重要的。</p><p>但是这并不适用于我们的日志系统。我们打算接收所有的日志消息，而不仅仅是一小部分。我们关心的是最新的消息而不是旧的。为了解决这个问题，我们需要做两件事情。</p><p>首先，当我们连接上RabbitMQ的时候，我们需要一个全新的、空的队列。我们可以手动创建一个随机的队列名，或者让服务器为我们选择一个随机的队列名（推荐）。我们只需要在调用queue_declare方法的时候，不提供queue参数就可以了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result = channel.queue_declare()</span><br></pre></td></tr></table></figure><p>这时候我们可以通过result.method.queue获得已经生成的随机队列名。它可能是这样子的：amq.gen-U0srCoW8TsaXjNh73pnVAw==。</p><p>第二步，当与消费者（consumer）断开连接的时候，这个队列应当被立即删除。exclusive标识符即可达到此目的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result = channel.queue_declare(exclusive=True)</span><br></pre></td></tr></table></figure><h2 id="绑定（Bindings）"><a href="#绑定（Bindings）" class="headerlink" title="绑定（Bindings）"></a>绑定（Bindings）</h2><p><img src="http://www.rabbitmq.com/img/tutorials/bindings.png" alt="img"></p><p>我们已经创建了一个扇型交换机（fanout）和一个队列。现在我们需要告诉交换机如何发送消息给我们的队列。交换器和队列之间的联系我们称之为绑定（binding）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.queue_bind(exchange=&apos;logs&apos;, queue=result.method.queue)</span><br></pre></td></tr></table></figure><p>现在，logs交换机将会把消息添加到我们的队列中。</p><blockquote><h4 id="绑定（binding）列表"><a href="#绑定（binding）列表" class="headerlink" title="绑定（binding）列表"></a>绑定（binding）列表</h4><p>你可以使用<code>rabbitmqctl list_bindings</code> 列出所有现存的绑定。</p></blockquote><h2 id="代码整合"><a href="#代码整合" class="headerlink" title="代码整合"></a>代码整合</h2><p><img src="http://www.rabbitmq.com/img/tutorials/python-three-overall.png" alt="img"></p><p>发布日志消息的程序看起来和之前的没有太大区别。最重要的改变就是我们把消息发送给logs交换机而不是匿名交换机。在发送的时候我们需要提供routing_key参数，但是它的值会被扇型交换机（fanout exchange）忽略。以下是emit_log.py脚本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line">import pika</span><br><span class="line">import sys</span><br><span class="line"></span><br><span class="line">connection = pika.BlockingConnection(pika.ConnectionParameters(</span><br><span class="line">        host=&apos;localhost&apos;))</span><br><span class="line">channel = connection.channel()</span><br><span class="line"></span><br><span class="line">channel.exchange_declare(exchange=&apos;logs&apos;,</span><br><span class="line">                         type=&apos;fanout&apos;)</span><br><span class="line"></span><br><span class="line">message = &apos; &apos;.join(sys.argv[1:]) or &quot;info: Hello World!&quot;</span><br><span class="line">channel.basic_publish(exchange=&apos;logs&apos;,</span><br><span class="line">                      routing_key=&apos;&apos;,</span><br><span class="line">                      body=message)</span><br><span class="line">print(&quot; [x] Sent %r&quot; % (message,))</span><br><span class="line">connection.close()</span><br></pre></td></tr></table></figure><p>(<a href="http://github.com/rabbitmq/rabbitmq-tutorials/blob/master/python/emit_log.py" target="_blank" rel="noopener">emit_log.py</a> 源文件)</p><p>正如你看到的那样，在连接成功之后，我们声明了一个交换器，这一个是很重要的，因为不允许发布消息到不存在的交换器。</p><p>如果没有绑定队列到交换器，消息将会丢失。但这个没有所谓，如果没有消费者监听，那么消息就会被忽略。</p><p>receive_logs.py的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line">import pika</span><br><span class="line"></span><br><span class="line">connection = pika.BlockingConnection(pika.ConnectionParameters(</span><br><span class="line">        host=&apos;localhost&apos;))</span><br><span class="line">channel = connection.channel()</span><br><span class="line"></span><br><span class="line">channel.exchange_declare(exchange=&apos;logs&apos;,</span><br><span class="line">                         type=&apos;fanout&apos;)</span><br><span class="line"></span><br><span class="line">result = channel.queue_declare(exclusive=True)</span><br><span class="line">queue_name = result.method.queue</span><br><span class="line"></span><br><span class="line">channel.queue_bind(exchange=&apos;logs&apos;,</span><br><span class="line">                   queue=queue_name)</span><br><span class="line"></span><br><span class="line">print(&apos; [*] Waiting for logs. To exit press CTRL+C&apos;)</span><br><span class="line"></span><br><span class="line">def callback(ch, method, properties, body):</span><br><span class="line">    print(&quot; [x] %r&quot; % (body,))</span><br><span class="line"></span><br><span class="line">channel.basic_consume(callback,</span><br><span class="line">                      queue=queue_name,</span><br><span class="line">                      no_ack=True)</span><br><span class="line"></span><br><span class="line">channel.start_consuming()</span><br></pre></td></tr></table></figure><p>(<a href="http://github.com/rabbitmq/rabbitmq-tutorials/blob/master/python/receive_logs.py" target="_blank" rel="noopener">receive_logs.py</a> source)</p><p>这样我们就完成了。如果你想把日志保存到文件中，只需要打开控制台输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ python receive_logs.py &gt; logs_from_rabbit.log</span><br></pre></td></tr></table></figure><p>如果你想在屏幕中查看日志，那么打开一个新的终端然后运行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ python receive_logs.py</span><br></pre></td></tr></table></figure><p>当然还要发送日志：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ python emit_log.py</span><br></pre></td></tr></table></figure><p>使用<code>rabbitmqctl list_bindings</code>你可确认已经创建的队列绑定。你可以看到运行中的两个receive_logs.py程序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ sudo rabbitmqctl list_bindings</span><br><span class="line">Listing bindings ...</span><br><span class="line"> ...</span><br><span class="line">logs    amq.gen-TJWkez28YpImbWdRKMa8sg==                []</span><br><span class="line">logs    amq.gen-x0kymA4yPzAT6BoC/YP+zw==                []</span><br><span class="line">...done.</span><br></pre></td></tr></table></figure><p>显示结果很直观：logs交换器把数据发送给两个系统命名的队列。这就是我们所期望的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;发布／订阅&quot;&gt;&lt;a href=&quot;#发布／订阅&quot; class=&quot;headerlink&quot; title=&quot;发布／订阅&quot;&gt;&lt;/a&gt;发布／订阅&lt;/h2&gt;&lt;p&gt;在上篇教程中，我们搭建了一个工作队列，每个任务只分发给一个工作者（worker）。在本篇教程中，我们要做的跟之前完全
      
    
    </summary>
    
      <category term="RabbitMQ" scheme="http://gavinliu4011.github.io/categories/RabbitMQ/"/>
    
    
      <category term="Python" scheme="http://gavinliu4011.github.io/tags/Python/"/>
    
      <category term="RabbitMQ" scheme="http://gavinliu4011.github.io/tags/RabbitMQ/"/>
    
      <category term="消息队列" scheme="http://gavinliu4011.github.io/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>Python版RabbitMQ消息队列之工作队列（二）</title>
    <link href="http://gavinliu4011.github.io/post/2efe5f21.html"/>
    <id>http://gavinliu4011.github.io/post/2efe5f21.html</id>
    <published>2018-03-18T21:53:17.000Z</published>
    <updated>2018-03-22T15:26:38.648Z</updated>
    
    <content type="html"><![CDATA[<h2 id="工作队列"><a href="#工作队列" class="headerlink" title="工作队列"></a>工作队列</h2><p><img src="http://www.rabbitmq.com/img/tutorials/python-two.png" alt="img"></p><p>在第一篇教程中，我们已经写了一个从已知队列中发送和获取消息的程序。在这篇教程中，我们将创建一个工作队列（Work Queue），它会发送一些耗时的任务给多个工作者（Worker）。</p><p>工作队列（又称：任务队列——Task Queues）是为了避免等待一些占用大量资源、时间的操作。当我们把任务（Task）当作消息发送到队列中，一个运行在后台的工作者（worker）进程就会取出任务然后处理。当你运行多个工作者（workers），任务就会在它们之间共享。</p><p>这个概念在网络应用中是非常有用的，它可以在短暂的HTTP请求中处理一些复杂的任务。</p><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>之前的教程中，我们发送了一个包含“Hello World!”的字符串消息。现在，我们将发送一些字符串，把这些字符串当作复杂的任务。我们没有真实的例子，例如图片缩放、pdf文件转换。所以使用time.sleep()函数来模拟这种情况。我们在字符串中加上点号（.）来表示任务的复杂程度，一个点（.）将会耗时1秒钟。比如”Hello…”就会耗时3秒钟。</p><p>我们对之前教程的send.py做些简单的调整，以便可以发送随意的消息。这个程序会按照计划发送任务到我们的工作队列中。我们把它命名为new_task.py：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import sys</span><br><span class="line"></span><br><span class="line">message = &apos; &apos;.join(sys.argv[1:]) or &quot;Hello World!&quot;</span><br><span class="line">channel.basic_publish(exchange=&apos;&apos;,</span><br><span class="line">                      routing_key=&apos;hello&apos;,</span><br><span class="line">                      body=message)</span><br><span class="line">print(&quot; [x] Sent %r&quot; % (message,))</span><br></pre></td></tr></table></figure><p>我们的旧脚本（receive.py）同样需要做一些改动：它需要为消息体中每一个点号（.）模拟1秒钟的操作。它会从队列中获取消息并执行，我们把它命名为worker.py：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import time</span><br><span class="line"></span><br><span class="line">def callback(ch, method, properties, body):</span><br><span class="line">    print(&quot; [x] Received %r&quot; % (body,))</span><br><span class="line">    time.sleep( body.count(&apos;.&apos;) )</span><br><span class="line">    print(&quot; [x] Done&quot;)</span><br></pre></td></tr></table></figure><h2 id="循环调度"><a href="#循环调度" class="headerlink" title="循环调度:"></a>循环调度:</h2><p>使用工作队列的一个好处就是它能够并行的处理队列。如果堆积了很多任务，我们只需要添加更多的工作者（workers）就可以了，扩展很简单。</p><p>首先，我们先同时运行两个worker.py脚本，它们都会从队列中获取消息，到底是不是这样呢？我们看看。</p><p>你需要打开三个终端，两个用来运行worker.py脚本，这两个终端就是我们的两个消费者（consumers）—— C1 和 C2。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">shell1$ python worker.py</span><br><span class="line"> [*] Waiting for messages. To exit press CTRL+C</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">shell2$ python worker.py</span><br><span class="line"> [*] Waiting for messages. To exit press CTRL+C</span><br></pre></td></tr></table></figure><p>第三个终端，我们用来发布新任务。你可以发送一些消息给消费者（consumers）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">shell3$ python new_task.py First message.</span><br><span class="line">shell3$ python new_task.py Second message..</span><br><span class="line">shell3$ python new_task.py Third message...</span><br><span class="line">shell3$ python new_task.py Fourth message....</span><br><span class="line">shell3$ python new_task.py Fifth message.....</span><br></pre></td></tr></table></figure><p>看看到底发送了什么给我们的工作者（workers）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">shell1$ python worker.py</span><br><span class="line"> [*] Waiting for messages. To exit press CTRL+C</span><br><span class="line"> [x] Received &apos;First message.&apos;</span><br><span class="line"> [x] Received &apos;Third message...&apos;</span><br><span class="line"> [x] Received &apos;Fifth message.....&apos;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">shell2$ python worker.py</span><br><span class="line"> [*] Waiting for messages. To exit press CTRL+C</span><br><span class="line"> [x] Received &apos;Second message..&apos;</span><br><span class="line"> [x] Received &apos;Fourth message....&apos;</span><br></pre></td></tr></table></figure><p>默认来说，RabbitMQ会按顺序得把消息发送给每个消费者（consumer）。平均每个消费者都会收到同等数量得消息。这种发送消息得方式叫做——轮询（round-robin）。试着添加三个或更多得工作者（workers）。</p><h2 id="消息确认"><a href="#消息确认" class="headerlink" title="消息确认"></a>消息确认</h2><p>当处理一个比较耗时得任务的时候，你也许想知道消费者（consumers）是否运行到一半就挂掉。当前的代码中，当消息被RabbitMQ发送给消费者（consumers）之后，马上就会在内存中移除。这种情况，你只要把一个工作者（worker）停止，正在处理的消息就会丢失。同时，所有发送到这个工作者的还没有处理的消息都会丢失。</p><p>我们不想丢失任何任务消息。如果一个工作者（worker）挂掉了，我们希望任务会重新发送给其他的工作者（worker）。</p><p>为了防止消息丢失，RabbitMQ提供了消息响应（acknowledgments）。消费者会通过一个ack（响应），告诉RabbitMQ已经收到并处理了某条消息，然后RabbitMQ就会释放并删除这条消息。</p><p>如果消费者（consumer）挂掉了，没有发送响应，RabbitMQ就会认为消息没有被完全处理，然后重新发送给其他消费者（consumer）。这样，及时工作者（workers）偶尔的挂掉，也不会丢失消息。</p><p>消息是没有超时这个概念的；当工作者与它断开连的时候，RabbitMQ会重新发送消息。这样在处理一个耗时非常长的消息任务的时候就不会出问题了。</p><p>消息响应默认是开启的。之前的例子中我们可以使用no_ack=True标识把它关闭。是时候移除这个标识了，当工作者（worker）完成了任务，就发送一个响应。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def callback(ch, method, properties, body):</span><br><span class="line">    print(&quot; [x] Received %r&quot; % (body,))</span><br><span class="line">    time.sleep( body.count(&apos;.&apos;) )</span><br><span class="line">    print(&quot; [x] Done&quot;)</span><br><span class="line">    ch.basic_ack(delivery_tag = method.delivery_tag)</span><br><span class="line"></span><br><span class="line">channel.basic_consume(callback, queue=&apos;hello&apos;)</span><br></pre></td></tr></table></figure><p>运行上面的代码，我们发现即使使用CTRL+C杀掉了一个工作者（worker）进程，消息也不会丢失。当工作者（worker）挂掉这后，所有没有响应的消息都会重新发送。</p><blockquote><h4 id="忘记确认"><a href="#忘记确认" class="headerlink" title="忘记确认"></a>忘记确认</h4><p>一个很容易犯的错误就是忘了basic_ack，后果很严重。消息在你的程序退出之后就会重新发送，如果它不能够释放没响应的消息，RabbitMQ就会占用越来越多的内存。</p><p>为了排除这种错误，你可以使用rabbitmqctl命令，输出messages_unacknowledged字段：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; $ sudo rabbitmqctl list_queues name messages_ready messages_unacknowledged</span><br><span class="line">&gt; Listing queues ...</span><br><span class="line">&gt; hello    0       0</span><br><span class="line">&gt; ...done.</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h2 id="消息持久化"><a href="#消息持久化" class="headerlink" title="消息持久化"></a>消息持久化</h2><p>如果你没有特意告诉RabbitMQ，那么在它退出或者崩溃的时候，将会丢失所有队列和消息。为了确保信息不会丢失，有两个事情是需要注意的：我们必须把“队列”和“消息”设为持久化。</p><p>首先，为了不让队列消失，需要把队列声明为持久化（durable）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.queue_declare(queue=&apos;hello&apos;, durable=True)</span><br></pre></td></tr></table></figure><p>尽管这行代码本身是正确的，但是仍然不会正确运行。因为我们已经定义过一个叫hello的非持久化队列。RabbitMq不允许你使用不同的参数重新定义一个队列，它会返回一个错误。但我们现在使用一个快捷的解决方法——用不同的名字，例如task_queue。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.queue_declare(queue=&apos;task_queue&apos;, durable=True)</span><br></pre></td></tr></table></figure><p>这个queue_declare必须在生产者（producer）和消费者（consumer）对应的代码中修改。</p><p>这时候，我们就可以确保在RabbitMq重启之后queue_declare队列不会丢失。另外，我们需要把我们的消息也要设为持久化——将delivery_mode的属性设为2。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">channel.basic_publish(exchange=&apos;&apos;,</span><br><span class="line">                      routing_key=&quot;task_queue&quot;,</span><br><span class="line">                      body=message,</span><br><span class="line">                      properties=pika.BasicProperties(</span><br><span class="line">                         delivery_mode = 2, # make message persistent</span><br><span class="line">                      ))</span><br></pre></td></tr></table></figure><blockquote><h4 id="注意：消息持久化"><a href="#注意：消息持久化" class="headerlink" title="注意：消息持久化"></a>注意：消息持久化</h4><p>将消息设为持久化并不能完全保证不会丢失。以上代码只是告诉了RabbitMq要把消息存到硬盘，但从RabbitMq收到消息到保存之间还是有一个很小的间隔时间。因为RabbitMq并不是所有的消息都使用fsync(2)——它有可能只是保存到缓存中，并不一定会写到硬盘中。并不能保证真正的持久化，但已经足够应付我们的简单工作队列。如果你一定要保证持久化，你需要改写你的代码来支持事务（transaction）。</p></blockquote><h2 id="公平调度"><a href="#公平调度" class="headerlink" title="公平调度"></a>公平调度</h2><p>你应该已经发现，它仍旧没有按照我们期望的那样进行分发。比如有两个工作者（workers），处理奇数消息的比较繁忙，处理偶数消息的比较轻松。然而RabbitMQ并不知道这些，它仍然一如既往的派发消息。</p><p>这时因为RabbitMQ只管分发进入队列的消息，不会关心有多少消费者（consumer）没有作出响应。它盲目的把第n-th条消息发给第n-th个消费者。</p><p><img src="http://www.rabbitmq.com/img/tutorials/prefetch-count.png" alt="img"></p><p>我们可以使用basic.qos方法，并设置prefetch_count=1。这样是告诉RabbitMQ，再同一时刻，不要发送超过1条消息给一个工作者（worker），直到它已经处理了上一条消息并且作出了响应。这样，RabbitMQ就会把消息分发给下一个空闲的工作者（worker）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.basic_qos(prefetch_count=1)</span><br></pre></td></tr></table></figure><blockquote><h4 id="关于队列大小"><a href="#关于队列大小" class="headerlink" title="关于队列大小"></a>关于队列大小</h4><p>如果所有的工作者都处理繁忙状态，你的队列就会被填满。你需要留意这个问题，要么添加更多的工作者（workers），要么使用其他策略。</p></blockquote><h2 id="整合代码"><a href="#整合代码" class="headerlink" title="整合代码"></a>整合代码</h2><p>new_task.py的完整代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line">import pika</span><br><span class="line">import sys</span><br><span class="line"></span><br><span class="line">connection = pika.BlockingConnection(pika.ConnectionParameters(</span><br><span class="line">        host=&apos;localhost&apos;))</span><br><span class="line">channel = connection.channel()</span><br><span class="line"></span><br><span class="line">channel.queue_declare(queue=&apos;task_queue&apos;, durable=True)</span><br><span class="line"></span><br><span class="line">message = &apos; &apos;.join(sys.argv[1:]) or &quot;Hello World!&quot;</span><br><span class="line">channel.basic_publish(exchange=&apos;&apos;,</span><br><span class="line">                      routing_key=&apos;task_queue&apos;,</span><br><span class="line">                      body=message,</span><br><span class="line">                      properties=pika.BasicProperties(</span><br><span class="line">                         delivery_mode = 2, # make message persistent</span><br><span class="line">                      ))</span><br><span class="line">print(&quot; [x] Sent %r&quot; % (message,))</span><br><span class="line">connection.close()</span><br></pre></td></tr></table></figure><p>(<a href="https://github.com/rabbitmq/rabbitmq-tutorials/blob/master/python/new_task.py" target="_blank" rel="noopener">new_task.py</a>源码)</p><p>我们的worker：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line">import pika</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line">connection = pika.BlockingConnection(pika.ConnectionParameters(</span><br><span class="line">        host=&apos;localhost&apos;))</span><br><span class="line">channel = connection.channel()</span><br><span class="line"></span><br><span class="line">channel.queue_declare(queue=&apos;task_queue&apos;, durable=True)</span><br><span class="line">print(&apos; [*] Waiting for messages. To exit press CTRL+C&apos;)</span><br><span class="line"></span><br><span class="line">def callback(ch, method, properties, body):</span><br><span class="line">    print(&quot; [x] Received %r&quot; % (body,))</span><br><span class="line">    time.sleep( body.count(&apos;.&apos;) )</span><br><span class="line">    print(&quot; [x] Done&quot;)</span><br><span class="line">    ch.basic_ack(delivery_tag = method.delivery_tag)</span><br><span class="line"></span><br><span class="line">channel.basic_qos(prefetch_count=1)</span><br><span class="line">channel.basic_consume(callback,</span><br><span class="line">                      queue=&apos;task_queue&apos;)</span><br><span class="line"></span><br><span class="line">channel.start_consuming()</span><br></pre></td></tr></table></figure><p>(<a href="http://github.com/rabbitmq/rabbitmq-tutorials/blob/master/python/worker.py" target="_blank" rel="noopener">worker.py</a> source)</p><p>使用消息响应和prefetch_count你就可以搭建起一个工作队列了。这些持久化的选项使得在RabbitMQ重启之后仍然能够恢复。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;工作队列&quot;&gt;&lt;a href=&quot;#工作队列&quot; class=&quot;headerlink&quot; title=&quot;工作队列&quot;&gt;&lt;/a&gt;工作队列&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://www.rabbitmq.com/img/tutorials/python-two.png
      
    
    </summary>
    
      <category term="RabbitMQ" scheme="http://gavinliu4011.github.io/categories/RabbitMQ/"/>
    
    
      <category term="Python" scheme="http://gavinliu4011.github.io/tags/Python/"/>
    
      <category term="RabbitMQ" scheme="http://gavinliu4011.github.io/tags/RabbitMQ/"/>
    
      <category term="消息队列" scheme="http://gavinliu4011.github.io/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>Python版RabbitMQ消息队列之Hello World（一）</title>
    <link href="http://gavinliu4011.github.io/post/79b12668.html"/>
    <id>http://gavinliu4011.github.io/post/79b12668.html</id>
    <published>2018-03-17T23:43:52.000Z</published>
    <updated>2018-03-17T15:47:11.651Z</updated>
    
    <content type="html"><![CDATA[<h2 id="RabbitMQ安装"><a href="#RabbitMQ安装" class="headerlink" title="RabbitMQ安装"></a>RabbitMQ安装</h2><p>请移步<a href="http://www.cnblogs.com/nulige/p/6351318.html" target="_blank" rel="noopener">努力哥</a>博客！！！</p><h2 id="RabbitMQ队列"><a href="#RabbitMQ队列" class="headerlink" title="RabbitMQ队列"></a>RabbitMQ队列</h2><p>RabbitMQ是一个消息代理。它的工作就是接收和转发消息。你可以把它想像成一个邮局：你把信件放入邮箱，邮递员就会把信件投递到你的收件人处。在这个比喻中，RabbitMQ就扮演着邮箱、邮局以及邮递员的角色。</p><p>RabbitMQ和邮局的主要区别在于，它处理纸张，而是接收、存储和发送消息（message）这种二进制数据。</p><p>下面是RabbitMQ和消息所涉及到的一些术语。</p><ul><li>生产(Producing)的意思就是发送。发送消息的程序就是一个生产者(producer)。我们一般用”P”来表示:<br><img src="http://www.rabbitmq.com/img/tutorials/producer.png" alt="img"></li><li>队列(queue)就是存在于RabbitMQ中邮箱的名称。虽然消息的传输经过了RabbitMQ和你的应用程序，但是它只能被存储于队列当中。实质上队列就是个巨大的消息缓冲区，它的大小只受主机内存和硬盘限制。多个生产者（producers）可以把消息发送给同一个队列，同样，多个消费者（consumers）也能够从同一个队列（queue）中获取数据。队列可以绘制成这样（图上是队列的名称）：<br><img src="http://www.rabbitmq.com/img/tutorials/queue.png" alt="img"></li><li>在这里，消费（Consuming）和接收(receiving)是同一个意思。一个消费者（consumer）就是一个等待获取消息的程序。我们把它绘制为”C”：<br><img src="http://www.rabbitmq.com/img/tutorials/consumer.png" alt="img"></li></ul><p>需要指出的是生产者、消费者、代理需不要待在同一个设备上；事实上大多数应用也确实不在会将他们放在一台机器上。</p><h2 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h2><p>接下来我们用Python写两个小程序。一个发送单条消息的生产者（producer）和一个接收消息并将其输出的消费者（consumer）。传递的消息是”Hello World”。</p><p>下图中，“P”代表生产者，“C”代表消费者，中间的盒子代表为消费者保留的消息缓冲区，也就是我们的队列。</p><p><img src="http://www.rabbitmq.com/img/tutorials/python-one-overall.png" alt="img"></p><p>生产者（producer）把消息发送到一个名为“hello”的队列中。消费者（consumer）从这个队列中获取消息。</p><blockquote><h4 id="RabbitMQ库"><a href="#RabbitMQ库" class="headerlink" title="RabbitMQ库"></a>RabbitMQ库</h4><p>RabbitMQ使用的是AMQP 0.9.1协议。这是一个用于消息传递的开放、通用的协议。针对<a href="https://www.rabbitmq.com/devtools.html" target="_blank" rel="noopener">不同编程语言</a>有大量的RabbitMQ客户端可用。在这个系列教程中，RabbitMQ团队推荐使用<a href="https://pika.readthedocs.org/en/0.10.0/#" target="_blank" rel="noopener">Pika</a>这个Python客户端。大家可以通过<a href="https://pip.pypa.io/en/stable/quickstart/" target="_blank" rel="noopener">pip</a>这个包管理工具进行安装：</p></blockquote><h3 id="发送"><a href="#发送" class="headerlink" title="发送"></a>发送</h3><p><img src="http://www.rabbitmq.com/img/tutorials/sending.png" alt="img"></p><p>我们第一个程序<code>send.py</code>会发送一个消息到队列中。首先要做的事情就是建立一个到RabbitMQ服务器的连接。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import pika</span><br><span class="line"></span><br><span class="line">connection = pika.BlockingConnection(pika.ConnectionParameters(&apos;localhost&apos;))</span><br><span class="line">channel = connection.channel()</span><br></pre></td></tr></table></figure><p>现在我们已经跟本地机器的代理建立了连接。如果你想连接到其他机器的代理上，需要把代表本地的<code>localhost</code>改为指定的名字或IP地址。</p><p>接下来，在发送消息之前，我们需要确认服务于消费者的队列已经存在。如果将消息发送给一个不存在的队列，RabbitMQ会将消息丢弃掉。下面我们创建一个名为”hello”的队列用来将消息投递进去。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.queue_declare(queue=&apos;hello&apos;)</span><br></pre></td></tr></table></figure><p>这时候我们就可以发送消息了，我们第一条消息只包含了Hello World!字符串，我们打算把它发送到hello队列。</p><p>在RabbitMQ中，消息是不能直接发送到队列中的，这个过程需要通过交换机（exchange）来进行。但是为了不让细节拖累我们的进度，这里我们只需要知道如何使用由空字符串表示的默认交换机即可。如果你想要详细了解交换机，可以查看我们<a href="https://www.rabbitmq.com/tutorials/tutorial-three-python.html" target="_blank" rel="noopener">教程的第三部分</a>来获取更多细节。默认交换机比较特别，它允许我们指定消息究竟需要投递到哪个具体的队列中，队列名字需要在<code>routing_key</code>参数中指定。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">channel.basic_publish(exchange=&apos;&apos;, routing_key=&apos;hello&apos;, body=&apos;Hello World!&apos;)</span><br><span class="line">print(&quot; [x] Sent &apos;Hello World!&apos;&quot;)</span><br></pre></td></tr></table></figure><p>在退出程序之前，我们需要确认网络缓冲已经被刷写、消息已经投递到RabbitMQ。通过安全关闭连接可以做到这一点。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">connection.close()</span><br></pre></td></tr></table></figure><blockquote><p>发送不成功！</p><p>如果这是你第一次使用RabbitMQ，并且没有看到“Sent”消息出现在屏幕上，你可能会抓耳挠腮不知所以。这也许是因为没有足够的磁盘空间给代理使用所造成的（代理默认需要200MB的空闲空间），所以它才会拒绝接收消息。查看一下代理的日志文件进行确认，如果需要的话也可以减少限制。<a href="http://www.rabbitmq.com/configure.html#config-items" target="_blank" rel="noopener">配置文件文档</a>会告诉你如何更改磁盘空间限制（disk_free_limit）。</p></blockquote><h3 id="接收"><a href="#接收" class="headerlink" title="接收"></a>接收</h3><p><img src="https://www.rabbitmq.com/img/tutorials/receiving.png" alt="img"></p><p>我们的第二个程序<code>receive.py</code>，将会从队列中获取消息并将其打印到屏幕上。</p><p>这次我们还是需要要先连接到RabbitMQ服务器。连接服务器的代码和之前是一样的。</p><p>下一步也和之前一样，我们需要确认队列是存在的。我们可以多次使用<code>queue_declare</code>命令来创建同一个队列，但是只有一个队列会被真正的创建。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.queue_declare(queue=&apos;hello&apos;)</span><br></pre></td></tr></table></figure><p>你也许要问: 为什么要重复声明队列呢 —— 我们已经在前面的代码中声明过它了。如果我们确定了队列是已经存在的，那么我们可以不这么做，比如此前预先运行了send.py程序。可是我们并不确定哪个程序会首先运行。这种情况下，在程序中重复将队列重复声明一下是种值得推荐的做法。</p><blockquote><h4 id="列出所有队列"><a href="#列出所有队列" class="headerlink" title="列出所有队列"></a>列出所有队列</h4><p>你也许希望查看RabbitMQ中有哪些队列、有多少消息在队列中。此时你可以使用rabbitmqctl工具（使用有权限的用户）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; sudo rabbitmqctl list_queues</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><p>（在Windows中不需要sudo命令）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; rabbitmqctl list_queues</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>从队列中获取消息相对来说稍显复杂。需要为队列定义一个回调（callback）函数。当我们获取到消息的时候，Pika库就会调用此回调函数。这个回调函数会将接收到的消息内容输出到屏幕上。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def callback(ch, method, properties, body):</span><br><span class="line">    print(&quot; [x] Received %r&quot; % body)</span><br></pre></td></tr></table></figure><p>下一步，我们需要告诉RabbitMQ这个回调函数将会从名为”hello”的队列中接收消息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.basic_consume(callback, queue=&apos;hello&apos;, no_ack=True)</span><br></pre></td></tr></table></figure><p>要成功运行这些命令，我们必须保证队列是存在的，我们的确可以确保它的存在——因为我们之前已经使用<code>queue_declare</code>将其声明过了。</p><p><code>no_ack</code>参数<a href="https://www.rabbitmq.com/tutorials/tutorial-two-python.html" target="_blank" rel="noopener">稍后</a>会进行介绍。</p><p>最后，我们运行一个用来等待消息数据并且在需要的时候运行回调函数的无限循环。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(&apos; [*] Waiting for messages. To exit press CTRL+C&apos;)</span><br><span class="line">channel.start_consuming()</span><br></pre></td></tr></table></figure><h3 id="将代码整合到一起"><a href="#将代码整合到一起" class="headerlink" title="将代码整合到一起"></a>将代码整合到一起</h3><p><strong>send.py的完整代码：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import pika</span><br><span class="line"></span><br><span class="line">connection =</span><br><span class="line">pika.BlockingConnection(pika.ConnectionParameters(host=&apos;localhost&apos;))</span><br><span class="line">channel = connection.channel()</span><br><span class="line"></span><br><span class="line">channel.queue_declare(queue=&apos;hello&apos;)</span><br><span class="line"></span><br><span class="line">channel.basic_publish(exchange=&apos;&apos;,</span><br><span class="line">                      routing_key=&apos;hello&apos;,</span><br><span class="line">                      body=&apos;Hello World!&apos;)</span><br><span class="line">print(&quot; [x] Sent &apos;Hello World!&apos;&quot;)</span><br><span class="line">connection.close()</span><br></pre></td></tr></table></figure><p>(<a href="http://github.com/rabbitmq/rabbitmq-tutorials/blob/master/python/send.py" target="_blank" rel="noopener">send.py源码</a>)</p><p><strong>receive.py的完整代码：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import pika</span><br><span class="line"></span><br><span class="line">connection =</span><br><span class="line">pika.BlockingConnection(pika.ConnectionParameters(host=&apos;localhost&apos;))</span><br><span class="line">channel = connection.channel()</span><br><span class="line"></span><br><span class="line">channel.queue_declare(queue=&apos;hello&apos;)</span><br><span class="line"></span><br><span class="line">def callback(ch, method, properties, body):</span><br><span class="line">    print(&quot; [x] Received %r&quot; % body)</span><br><span class="line"></span><br><span class="line">channel.basic_consume(callback,</span><br><span class="line">                      queue=&apos;hello&apos;,</span><br><span class="line">                      no_ack=True)</span><br><span class="line"></span><br><span class="line">print(&apos; [*] Waiting for messages. To exit press CTRL+C&apos;)</span><br><span class="line">channel.start_consuming()</span><br></pre></td></tr></table></figure><p>(<a href="http://github.com/rabbitmq/rabbitmq-tutorials/blob/master/python/receive.py" target="_blank" rel="noopener">receive.py源码</a>)</p><p>现在我们可以在终端中尝试一下我们的程序了。<br>首先我们启动一个消费者，它会持续的运行来等待投递到达。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">python receive.py</span><br><span class="line"># =&gt; [*] Waiting for messages. To exit press CTRL+C</span><br><span class="line"># =&gt; [x] Received &apos;Hello World!&apos;</span><br></pre></td></tr></table></figure><p>然后启动生产者，生产者程序每次执行后都会停止运行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python send.py</span><br><span class="line"># =&gt; [x] Sent &apos;Hello World!&apos;</span><br></pre></td></tr></table></figure><p><strong>成功了！</strong>我们已经通过RabbitMQ发送第一条消息。你也许已经注意到了，receive.py程序并没有退出。它一直在准备获取消息，你可以通过Ctrl-C来中止它。</p><p>试下在新的终端中再次运行<code>send.py</code>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;RabbitMQ安装&quot;&gt;&lt;a href=&quot;#RabbitMQ安装&quot; class=&quot;headerlink&quot; title=&quot;RabbitMQ安装&quot;&gt;&lt;/a&gt;RabbitMQ安装&lt;/h2&gt;&lt;p&gt;请移步&lt;a href=&quot;http://www.cnblogs.com/nul
      
    
    </summary>
    
      <category term="RabbitMQ" scheme="http://gavinliu4011.github.io/categories/RabbitMQ/"/>
    
    
      <category term="Python" scheme="http://gavinliu4011.github.io/tags/Python/"/>
    
      <category term="RabbitMQ" scheme="http://gavinliu4011.github.io/tags/RabbitMQ/"/>
    
      <category term="消息队列" scheme="http://gavinliu4011.github.io/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>Python之concurrent.futures</title>
    <link href="http://gavinliu4011.github.io/post/b1bc006d.html"/>
    <id>http://gavinliu4011.github.io/post/b1bc006d.html</id>
    <published>2018-03-08T23:19:00.000Z</published>
    <updated>2018-03-08T15:19:50.863Z</updated>
    
    <content type="html"><![CDATA[<h3 id="concurrent-futures"><a href="#concurrent-futures" class="headerlink" title="concurrent.futures"></a>concurrent.futures</h3><h4 id="ProcessPoolExecutor"><a href="#ProcessPoolExecutor" class="headerlink" title="ProcessPoolExecutor"></a>ProcessPoolExecutor</h4><p>进程池，提供异步调用</p><h5 id="基本方法"><a href="#基本方法" class="headerlink" title="基本方法"></a>基本方法</h5><ul><li><p>submit(fn, <em>args, *</em>kwargs) 异步提交任务</p></li><li><p>map(func, *iterables, timeout=None, chunksize=1) 取代for循环submit的操作</p></li><li><p>shutdown(wait=True) 相当于进程池的pool.close()+pool.join()操作</p><p>wait=True，等待池内所有任务执行完毕回收完资源后才继续<br>wait=False，立即返回，并不会等待池内的任务执行完毕<br>但不管wait参数为何值，整个程序都会等到所有任务执行完毕<br>submit和map必须在shutdown之前</p></li><li><p>result(timeout=None)取得结果</p></li><li><p>add_done_callback(fn)回调函数</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ThreadPoolExecutor, ProcessPoolExecutor</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> os, time, random</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task</span><span class="params">(n)</span>:</span></span><br><span class="line">    print(<span class="string">'%s is runing'</span> % os.getpid())</span><br><span class="line">    time.sleep(random.randint(<span class="number">1</span>, <span class="number">3</span>))</span><br><span class="line">    <span class="keyword">return</span> n ** <span class="number">2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line"></span><br><span class="line">    executor = ProcessPoolExecutor(max_workers=<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">    futures = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">11</span>):</span><br><span class="line">        future = executor.submit(task, i)</span><br><span class="line">        futures.append(future)</span><br><span class="line">    executor.shutdown(<span class="keyword">True</span>)</span><br><span class="line">    print(<span class="string">'+++&gt;'</span>)</span><br><span class="line">    <span class="keyword">for</span> future <span class="keyword">in</span> futures:</span><br><span class="line">        print(future.result())</span><br></pre></td></tr></table></figure><h4 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h4><p>线程池，提供异步调用，用法与ProcessPoolExecutor相同，只需要将ProcessPoolExecutor换成ThreadPoolExecutor</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ThreadPoolExecutor</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(n)</span>:</span></span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    print(n)</span><br><span class="line">    <span class="keyword">return</span> n * n</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">call_back</span><span class="params">(m)</span>:</span></span><br><span class="line">    print(<span class="string">'结果是 %s'</span> % m.result())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    tpool = ThreadPoolExecutor(max_workers=<span class="number">5</span>)  <span class="comment"># 默认 不要超过cpu个数*5</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">20</span>):</span><br><span class="line">        tpool.submit(func, i).add_done_callback(call_back)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;concurrent-futures&quot;&gt;&lt;a href=&quot;#concurrent-futures&quot; class=&quot;headerlink&quot; title=&quot;concurrent.futures&quot;&gt;&lt;/a&gt;concurrent.futures&lt;/h3&gt;&lt;h4 id=&quot;P
      
    
    </summary>
    
      <category term="Python线程" scheme="http://gavinliu4011.github.io/categories/Python%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="Python" scheme="http://gavinliu4011.github.io/tags/Python/"/>
    
      <category term="进程池" scheme="http://gavinliu4011.github.io/tags/%E8%BF%9B%E7%A8%8B%E6%B1%A0/"/>
    
      <category term="线程池" scheme="http://gavinliu4011.github.io/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    
  </entry>
  
  <entry>
    <title>Python线程——信号量（Semaphore）、队列（Queue）</title>
    <link href="http://gavinliu4011.github.io/post/d068a68c.html"/>
    <id>http://gavinliu4011.github.io/post/d068a68c.html</id>
    <published>2018-03-07T23:32:30.000Z</published>
    <updated>2018-03-08T15:19:50.873Z</updated>
    
    <content type="html"><![CDATA[<h3 id="信号量（Semaphore）"><a href="#信号量（Semaphore）" class="headerlink" title="信号量（Semaphore）"></a>信号量（Semaphore）</h3><p>之前讲的线程锁（互斥锁）同时只允许一个线程更改数据，而Semaphore是同时允许一定数量的线程更改数据 ，比如厕所有4个坑，那最多只允许4个人上厕所，后面的人只能等里面有人出来了才能再进去。 说白了就是在同一时间，可以只允许设定的数量的线程去执行 。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Semaphore, Thread</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(sem, a, b)</span>:</span></span><br><span class="line">    sem.acquire()</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    print(a + b)</span><br><span class="line">    sem.release()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sem = Semaphore(<span class="number">4</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">    t = Thread(target=func, args=(sem, i, i + <span class="number">5</span>))</span><br><span class="line">    t.start()</span><br></pre></td></tr></table></figure><h3 id="队列（Queue）"><a href="#队列（Queue）" class="headerlink" title="队列（Queue）"></a>队列（Queue）</h3><p>queue队列 ：使用import queue，用法与<a href="https://gavinliu4011.github.io/post/58b02bea.html#more">进程Queue</a>一样 </p><p>####class queue.Queue(maxsize=0) 先进先出</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> queue</span><br><span class="line"></span><br><span class="line">q=queue.Queue()</span><br><span class="line">q.put(<span class="string">'first'</span>)</span><br><span class="line">q.put(<span class="string">'second'</span>)</span><br><span class="line">q.put(<span class="string">'third'</span>)</span><br><span class="line"></span><br><span class="line">print(q.get())</span><br><span class="line">print(q.get())</span><br><span class="line">print(q.get())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行结果</span></span><br><span class="line">结果(先进先出):</span><br><span class="line">first</span><br><span class="line">second</span><br><span class="line">third</span><br></pre></td></tr></table></figure><h4 id="class-queue-LifoQueue-maxsize-0-后进先出"><a href="#class-queue-LifoQueue-maxsize-0-后进先出" class="headerlink" title="class queue.LifoQueue(maxsize=0) 后进先出"></a>class queue.LifoQueue(maxsize=0) 后进先出</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> queue</span><br><span class="line"></span><br><span class="line">q=queue.LifoQueue()</span><br><span class="line">q.put(<span class="string">'first'</span>)</span><br><span class="line">q.put(<span class="string">'second'</span>)</span><br><span class="line">q.put(<span class="string">'third'</span>)</span><br><span class="line"></span><br><span class="line">print(q.get())</span><br><span class="line">print(q.get())</span><br><span class="line">print(q.get())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行结果</span></span><br><span class="line">结果(后进先出):</span><br><span class="line">third</span><br><span class="line">second</span><br><span class="line">first</span><br></pre></td></tr></table></figure><h4 id="class-queue-PriorityQueue-maxsize-0"><a href="#class-queue-PriorityQueue-maxsize-0" class="headerlink" title="class queue.PriorityQueue(maxsize=0)"></a>class queue.PriorityQueue(maxsize=0)</h4><p>根据优先级来取数据。存放数据的格式  : Queue.put((priority_number,data))，priority_number越小，优先级越高，data代表存入的值 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> queue</span><br><span class="line">q = queue.PriorityQueue()</span><br><span class="line">q.put((<span class="number">1</span>, <span class="string">"d1"</span>))</span><br><span class="line">q.put((<span class="number">-1</span>, <span class="string">"d2"</span>))</span><br><span class="line">q.put((<span class="number">6</span>, <span class="string">"d3"</span>))</span><br><span class="line">print(q.get())</span><br><span class="line">print(q.get())</span><br><span class="line">print(q.get())</span><br><span class="line"> </span><br><span class="line"><span class="comment">#执行结果</span></span><br><span class="line">(<span class="number">-1</span>, <span class="string">'d2'</span>)</span><br><span class="line">(<span class="number">1</span>, <span class="string">'d1'</span>)</span><br><span class="line">(<span class="number">6</span>, <span class="string">'d3'</span>)</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意：</strong>maxsize代表这个队列最大能够put的长度 </p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;信号量（Semaphore）&quot;&gt;&lt;a href=&quot;#信号量（Semaphore）&quot; class=&quot;headerlink&quot; title=&quot;信号量（Semaphore）&quot;&gt;&lt;/a&gt;信号量（Semaphore）&lt;/h3&gt;&lt;p&gt;之前讲的线程锁（互斥锁）同时只允许一个线程更
      
    
    </summary>
    
      <category term="Python线程" scheme="http://gavinliu4011.github.io/categories/Python%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="Python" scheme="http://gavinliu4011.github.io/tags/Python/"/>
    
      <category term="线程" scheme="http://gavinliu4011.github.io/tags/%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="信号量" scheme="http://gavinliu4011.github.io/tags/%E4%BF%A1%E5%8F%B7%E9%87%8F/"/>
    
      <category term="队列" scheme="http://gavinliu4011.github.io/tags/%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>Python线程——GIL锁、线程锁（互斥锁）、递归锁（RLock）</title>
    <link href="http://gavinliu4011.github.io/post/5b18ac8.html"/>
    <id>http://gavinliu4011.github.io/post/5b18ac8.html</id>
    <published>2018-03-06T23:53:57.000Z</published>
    <updated>2018-03-06T15:54:10.257Z</updated>
    
    <content type="html"><![CDATA[<h3 id="GIL锁"><a href="#GIL锁" class="headerlink" title="GIL锁"></a>GIL锁</h3><p>​    计算机有4核，代表着同一时间，可以干4个任务。如果单核cpu的话，我启动10个线程，我看上去也是并发的，因为是执行了上下文的切换，让看上去是并发的。但是单核永远肯定时串行的，它肯定是串行的，cpu真正执行的时候，因为一会执行1，一会执行2.。。。。正常的线程就是这个样子的。但是，在python中，无论有多少核，永远都是假象。无论是4核，8核，还是16核…….不好意思，同一时间执行的线程只有一个(线程)，它就是这个样子的。</p><h4 id="全局解释器锁-GIL"><a href="#全局解释器锁-GIL" class="headerlink" title="全局解释器锁(GIL)"></a>全局解释器锁(GIL)</h4><p>​    Python代码的执行由Python虚拟机(也叫解释器主循环)来控制。Python在设计之初就考虑到要在主循环中，同时只有一个线程在执行。虽然 Python 解释器中可以“运行”多个线程，但在任意时刻只有一个线程在解释器中运行。<br>　　对Python虚拟机的访问由全局解释器锁(GIL)来控制，正是这个锁能保证同一时刻只有一个线程在运行。</p><p>　　在多线程环境中，Python 虚拟机按以下方式执行：</p><p>　　1、设置 GIL；</p><p>　　2、切换到一个线程去运行；</p><p>　　3、运行指定数量的字节码指令或者线程主动让出控制(可以调用 time.sleep(0))；</p><p>　　4、把线程设置为睡眠状态；</p><p>　　5、解锁 GIL；</p><p>　　6、再次重复以上所有步骤。<br>　　在调用外部代码(如 C/C++扩展函数)的时候，GIL将会被锁定，直到这个函数结束为止(由于在这期间没有Python的字节码被运行，所以不会做线程切换)编写扩展的程序员可以主动解锁GIL。</p><h4 id="GIL锁关系图"><a href="#GIL锁关系图" class="headerlink" title="GIL锁关系图"></a>GIL锁关系图</h4><p>GIL(全局解释器锁)是加在python解释器里面的，效果如图 :</p><p><img src="..\img\thread\1449713172.png" alt=""></p><h5 id="为什么GIL锁要加在python解释器这一层，而却不加在其他地方？"><a href="#为什么GIL锁要加在python解释器这一层，而却不加在其他地方？" class="headerlink" title="为什么GIL锁要加在python解释器这一层，而却不加在其他地方？"></a>为什么GIL锁要加在python解释器这一层，而却不加在其他地方？</h5><p>​    很多资料说是因为python调用的所有线程都是原生线程。原生线程是通过C语言提供原生接口，相当于C语言的一个函数。你一调它，你就控制不了了它了，就必须等它给你返回结果。只要已通过python虚拟机，再往下就不受python控制了，就是C语言自己控制了。你加在python虚拟机以下，你是加不上去的。同一时间，只有一个线程穿过这个锁去真正执行。其他的线程，只能在python虚拟机这边等待。 </p><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>​    需要明确的一点是<code>GIL</code>并不是Python的特性，它是在实现Python解析器(CPython)时所引入的一个概念。就好比C++是一套语言（语法）标准，但是可以用不同的编译器来编译成可执行代码。有名的编译器例如GCC，INTEL C++，Visual C++等。Python也一样，同样一段代码可以通过CPython，JPython，PyPy，Psyco等不同的Python执行环境来执行。而JPython就没有GIL。然而因为CPython是大部分环境下默认的Python执行环境。所以在很多人的概念里CPython就是Python，也就想当然的把<code>GIL</code>归结为Python语言的缺陷。所以这里要先明确一点：<strong>GIL并不是Python的特性，Python完全可以不依赖于GIL</strong>。 </p><h3 id="线程锁（互斥锁）"><a href="#线程锁（互斥锁）" class="headerlink" title="线程锁（互斥锁）"></a>线程锁（互斥锁）</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">work</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 在这里模拟一个底层做运算的过程，具体为什么这个我不知道，看某资料写的，</span></span><br><span class="line">    <span class="comment"># 如果这里直接对num进行运算很难出现数据不安全的结果</span></span><br><span class="line">    <span class="keyword">global</span> num  <span class="comment"># 把num变成全局变量</span></span><br><span class="line">    temp = num</span><br><span class="line">    time.sleep(<span class="number">1</span>)  <span class="comment"># 注意了sleep的时候是不占有cpu的，这个时候cpu直接把这个线程挂起了，此时cpu去干别的事情去了</span></span><br><span class="line">    num = temp + <span class="number">1</span>  <span class="comment"># 所有的线程都做+1操作</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line"></span><br><span class="line">    num = <span class="number">0</span>  <span class="comment"># 初始化num为0</span></span><br><span class="line">    t_obj = list()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">100</span>):</span><br><span class="line">        t = Thread(target=work)</span><br><span class="line">        t.start()</span><br><span class="line">        t_obj.append(t)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> t <span class="keyword">in</span> t_obj:</span><br><span class="line">        t.join()</span><br><span class="line">    print(<span class="string">"num:"</span>, num)  <span class="comment"># 输出最后的num值，可能是1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 执行结果</span></span><br><span class="line">    num: <span class="number">1</span></span><br></pre></td></tr></table></figure><p>下面我们就用一张图来解释一下这个原因 ：</p><p><img src="..\img\thread\80064182.png" alt=""></p><p>上面的例子中出现数据不安全问题，那么我们应该怎么解决呢？在这里我们引用线程锁来解决这个问题</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Lock,Thread</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">work</span><span class="params">(lock)</span>:</span></span><br><span class="line">    <span class="comment"># 在这里模拟一个底层做运算的过程，具体为什么这个我不知道，看某资料写的，</span></span><br><span class="line">    <span class="comment"># 如果这里直接对num进行运算很难出现数据不安全的结果</span></span><br><span class="line">    <span class="keyword">global</span> num  <span class="comment"># 把num变成全局变量</span></span><br><span class="line">    lock.acquire()</span><br><span class="line">    temp = num</span><br><span class="line">    time.sleep(<span class="number">0.1</span>)  <span class="comment"># 注意了sleep的时候是不占有cpu的，这个时候cpu直接把这个线程挂起了，此时cpu去干别的事情去了</span></span><br><span class="line">    num = temp + <span class="number">1</span>  <span class="comment"># 所有的线程都做+1操作</span></span><br><span class="line">    lock.release()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line"></span><br><span class="line">    num = <span class="number">0</span>  <span class="comment"># 初始化num为0</span></span><br><span class="line">    t_obj = list()</span><br><span class="line">    lock = Lock()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">100</span>):</span><br><span class="line">        t = Thread(target=work, args=(lock,))</span><br><span class="line">        t.start()</span><br><span class="line">        t_obj.append(t)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> t <span class="keyword">in</span> t_obj:</span><br><span class="line">        t.join()</span><br><span class="line">    print(<span class="string">"num:"</span>, num)  <span class="comment"># 输出最后的num值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 执行结果</span></span><br><span class="line">    num: <span class="number">100</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>注意：</strong>这里的Lock创建的锁和GIL没有关系 ，</p></blockquote><h3 id="递归锁（RLock）"><a href="#递归锁（RLock）" class="headerlink" title="递归锁（RLock）"></a>递归锁（RLock）</h3><h4 id="线程死锁"><a href="#线程死锁" class="headerlink" title="线程死锁"></a>线程死锁</h4><p>​    所谓死锁： 是指两个或两个以上的进程或线程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程，比如下面例子中“科学家吃面”：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Lock, Thread</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">noodle_lock = Lock()</span><br><span class="line">fork_lock = Lock()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">eat1</span><span class="params">(name)</span>:</span></span><br><span class="line">    noodle_lock.acquire()</span><br><span class="line">    print(<span class="string">'%s拿到面条啦'</span> % name)</span><br><span class="line">    fork_lock.acquire()</span><br><span class="line">    print(<span class="string">'%s拿到叉子了'</span> % name)</span><br><span class="line">    print(<span class="string">'%s吃面'</span> % name)</span><br><span class="line">    fork_lock.release()</span><br><span class="line">    noodle_lock.release()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">eat2</span><span class="params">(name)</span>:</span></span><br><span class="line">    fork_lock.acquire()</span><br><span class="line">    print(<span class="string">'%s拿到叉子了'</span> % name)</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    noodle_lock.acquire()</span><br><span class="line">    print(<span class="string">'%s拿到面条啦'</span> % name)</span><br><span class="line">    print(<span class="string">'%s吃面'</span> % name)</span><br><span class="line">    noodle_lock.release()</span><br><span class="line">    fork_lock.release()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    Thread(target=eat1, args=(<span class="string">'张三'</span>,)).start()</span><br><span class="line">    Thread(target=eat2, args=(<span class="string">'李四'</span>,)).start()</span><br><span class="line">    Thread(target=eat1, args=(<span class="string">'王五'</span>,)).start()</span><br><span class="line">    Thread(target=eat2, args=(<span class="string">'赵六'</span>,)).start()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行结果</span></span><br><span class="line">张三拿到面条啦</span><br><span class="line">张三拿到叉子了</span><br><span class="line">张三吃面</span><br><span class="line">李四拿到叉子了</span><br><span class="line">王五拿到面条啦</span><br></pre></td></tr></table></figure><p>上面例子中情况是在线程间共享多个资源的时候，如果两个线程分别占有一部分资源并且同时等待对方的资源，就会造成死锁，因为系统判断这部分资源都正在使用，所有这两个线程在无外力作用下将一直等待下去。执行结果，是无限的进入死循环，所以不能这么加，这个时候就需要用到递归锁。 </p><h4 id="递归锁-RLock"><a href="#递归锁-RLock" class="headerlink" title="递归锁(RLock)"></a>递归锁(RLock)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread, RLock  <span class="comment"># 递归锁</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">fork_lock = noodle_lock = RLock()  <span class="comment"># 一个钥匙串上的两把钥匙</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">eat1</span><span class="params">(name)</span>:</span></span><br><span class="line">    noodle_lock.acquire()  <span class="comment"># 一把钥匙</span></span><br><span class="line">    print(<span class="string">'%s拿到面条啦'</span> % name)</span><br><span class="line">    fork_lock.acquire()</span><br><span class="line">    print(<span class="string">'%s拿到叉子了'</span> % name)</span><br><span class="line">    print(<span class="string">'%s吃面'</span> % name)</span><br><span class="line">    fork_lock.release()</span><br><span class="line">    noodle_lock.release()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">eat2</span><span class="params">(name)</span>:</span></span><br><span class="line">    fork_lock.acquire()</span><br><span class="line">    print(<span class="string">'%s拿到叉子了'</span> % name)</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    noodle_lock.acquire()</span><br><span class="line">    print(<span class="string">'%s拿到面条啦'</span> % name)</span><br><span class="line">    print(<span class="string">'%s吃面'</span> % name)</span><br><span class="line">    noodle_lock.release()</span><br><span class="line">    fork_lock.release()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    Thread(target=eat1, args=(<span class="string">'张三'</span>,)).start()</span><br><span class="line">    Thread(target=eat2, args=(<span class="string">'李四'</span>,)).start()</span><br><span class="line">    Thread(target=eat1, args=(<span class="string">'王五'</span>,)).start()</span><br><span class="line">    Thread(target=eat2, args=(<span class="string">'赵六'</span>,)).start()</span><br></pre></td></tr></table></figure><p>自我理解递归锁原理其实很简单：就是每开一把门，在字典里面存一份数据，退出的时候去到door1或者door2里面找到这个钥匙退出 </p><p><img src="..\img\thread\1032923525.png" alt=""></p><blockquote><p><strong>注意：</strong>递归锁用于多重锁的情况，如果只是一层锁，就用不上递归锁</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;GIL锁&quot;&gt;&lt;a href=&quot;#GIL锁&quot; class=&quot;headerlink&quot; title=&quot;GIL锁&quot;&gt;&lt;/a&gt;GIL锁&lt;/h3&gt;&lt;p&gt;​    计算机有4核，代表着同一时间，可以干4个任务。如果单核cpu的话，我启动10个线程，我看上去也是并发的，因为是执行
      
    
    </summary>
    
      <category term="Python线程" scheme="http://gavinliu4011.github.io/categories/Python%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="Python" scheme="http://gavinliu4011.github.io/tags/Python/"/>
    
      <category term="线程" scheme="http://gavinliu4011.github.io/tags/%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="锁" scheme="http://gavinliu4011.github.io/tags/%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>Python进程——守护线程</title>
    <link href="http://gavinliu4011.github.io/post/5965383b.html"/>
    <id>http://gavinliu4011.github.io/post/5965383b.html</id>
    <published>2018-03-05T22:44:26.000Z</published>
    <updated>2018-03-08T15:19:50.849Z</updated>
    
    <content type="html"><![CDATA[<h3 id="守护进程"><a href="#守护进程" class="headerlink" title="守护进程"></a>守护进程</h3><p>在上一遍文章中我们已经介绍了创建线程，对线程也有一些了解，现在一起来看看守护进程。</p><blockquote><p><strong>无论是进程还是线程，都遵循：守护xx会等待主xx运行完毕后被销毁。需要强调的是：运行完毕并非终止运行</strong> </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- 主进程在其代码结束后就已经算运行完毕了（守护进程在此时就被回收）,然后主进程会一直等非守护的子进程都运行完毕后回收子进程的资源(否则会产生僵尸进程)，才会结束。</span><br><span class="line">- 主线程在其他非守护线程运行完毕后才算运行完毕（守护线程在此时就被回收）。因为主线程的结束意味着进程的结束，进程整体的资源都将被回收，而进程必须保证非守护线程都运行完毕后才能结束。</span><br></pre></td></tr></table></figure><p>举个例，设置一个主人，在设置几个仆人，这几个仆人都是为主人服务的。可以帮主人做很多事情，一个主人（主线程）可以有多个仆人（守护线程），服务的前提是，主线程必须存在，如果主线程不存在，则守护进程也没了。那守护进程是干嘛的呢？可以管理一些资源，打开一些文件，监听一些端口，监听一些资源，把一些垃圾资源回收，可以干很多事情，可以随便定义。 </p><h4 id="守护线程设置"><a href="#守护线程设置" class="headerlink" title="守护线程设置"></a>守护线程设置</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(n)</span>:</span></span><br><span class="line">    print(<span class="string">'task:'</span>, n)</span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    print(<span class="string">'task done'</span>, n)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">start_time = time.time()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">    t = threading.Thread(target=run, args=(<span class="string">'t-&#123;0&#125;'</span>.format(i),))</span><br><span class="line">    t.setDaemon(<span class="keyword">True</span>)  <span class="comment"># Daemon意思是守护进程，这边是把当前线程设置为守护线程</span></span><br><span class="line">    t.start()</span><br><span class="line"></span><br><span class="line">print(<span class="string">"所有线程已经完成"</span>)</span><br><span class="line">print(<span class="string">'cost:'</span>, time.time() - start_time)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行结果</span></span><br><span class="line">task: t<span class="number">-0</span></span><br><span class="line">task: t<span class="number">-1</span></span><br><span class="line">task: t<span class="number">-2</span></span><br><span class="line">task: t<span class="number">-3</span></span><br><span class="line">task: t<span class="number">-4</span></span><br><span class="line">所有线程已经完成</span><br><span class="line">cost: <span class="number">0.0019915103912353516</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>注意：</strong>守护进程一定要在start之前设置，start之后就不能设置了，之后设置会报错，所以必须在start之前设置</p></blockquote><h4 id="统计线程数-补充点"><a href="#统计线程数-补充点" class="headerlink" title="统计线程数(补充点)"></a>统计线程数(补充点)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading, time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(n)</span>:</span></span><br><span class="line">    print(<span class="string">'task:'</span>, n)</span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    print(<span class="string">'task done'</span>, n, threading.current_thread())  <span class="comment"># 查看每个子线程</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">start_time = time.time()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">    t = threading.Thread(target=run, args=(<span class="string">'t-&#123;0&#125;'</span>.format(i),))</span><br><span class="line">    t.start()</span><br><span class="line"></span><br><span class="line">print(<span class="string">'--------'</span>, threading.current_thread(), threading.active_count())  <span class="comment"># 查看主线程和当前活动的所有线程数</span></span><br><span class="line">print(<span class="string">'cost:'</span>, time.time() - start_time)</span><br></pre></td></tr></table></figure><p>上面例子是查看当前线程和统计活动线程个数，用<strong>theading.current_thead()</strong> <em>查看当前线程</em>；用<strong>theading.active_count()</strong>来统计<em>当前活动的线程数</em>，<strong>线程个数=子线程数+主线程数</strong> </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;守护进程&quot;&gt;&lt;a href=&quot;#守护进程&quot; class=&quot;headerlink&quot; title=&quot;守护进程&quot;&gt;&lt;/a&gt;守护进程&lt;/h3&gt;&lt;p&gt;在上一遍文章中我们已经介绍了创建线程，对线程也有一些了解，现在一起来看看守护进程。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;
      
    
    </summary>
    
      <category term="Python线程" scheme="http://gavinliu4011.github.io/categories/Python%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="Python" scheme="http://gavinliu4011.github.io/tags/Python/"/>
    
      <category term="守护线程" scheme="http://gavinliu4011.github.io/tags/%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Python之线程</title>
    <link href="http://gavinliu4011.github.io/post/c52e9d45.html"/>
    <id>http://gavinliu4011.github.io/post/c52e9d45.html</id>
    <published>2018-03-04T23:16:54.000Z</published>
    <updated>2018-03-04T15:17:30.533Z</updated>
    
    <content type="html"><![CDATA[<h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><ul><li>CPU上的执行单位，线程也是程序运行过程中的一个抽象。</li><li>一个进程下可以有多个线程。</li><li>主线程：操作系统中的每一个进程都会对应一个地址空间。每一个进程中都会默认有一个控制线程，主线程随着进程的创建而出现。所以一个进程中主线程存在就代表了这个进程的存在，当进程中的主线程结束的时候，操作系统就会将该进程回收</li></ul><h4 id="有了进程为什么还要线程"><a href="#有了进程为什么还要线程" class="headerlink" title="有了进程为什么还要线程?"></a>有了进程为什么还要线程?</h4><p>进程有很多优点，它提供了多道编程，让我们感觉我们每个人都拥有自己的CPU和其他资源，可以提高计算机的利用率。很多人就不理解了，既然进程这么优秀，为什么还要线程呢？其实，仔细观察就会发现进程还是有很多缺陷的，主要体现在两点上：</p><ul><li>进程只能在一个时间干一件事，如果想同时干两件事或多件事，进程就无能为力了。</li><li>进程在执行的过程中如果阻塞，例如等待输入，整个进程就会挂起，即使进程中有些工作不依赖于输入的数据，也将无法执行。</li></ul><p>例如，我们在使用qq聊天， qq做为一个独立进程如果同一时间只能干一件事，那他如何实现在同一时刻 即能监听键盘输入、又能监听其它人给你发的消息、同时还能把别人发的消息显示在屏幕上呢？你会说，操作系统不是有分时么？但是分时是指在不同进程间的分时， 即操作系统处理一会你的qq任务，又切换到word文档任务上了，每个cpu时间片分给你的qq程序时，事实上，你的qq还是同一时间只能干一件事情。</p><p>再直白一点， 一个操作系统就像是一个工厂，工厂里面有很多个生产车间，不同的车间生产不同的产品，每个车间就相当于一个进程，且你的工厂又穷，供电不足，同一时间只能给一个车间供电，为了能让所有车间都能同时生产，你的工厂的电工只能给不同的车间分时供电，但是轮到你的qq车间时，发现只有一个干活的工人，结果生产效率极低，为了解决这个问题，就需要多加几个工人，让几个人工人并行工作，这每个工人，就是线程！</p><h4 id="线程的特点"><a href="#线程的特点" class="headerlink" title="线程的特点"></a>线程的特点</h4><p>在多线程的操作系统中，通常是在一个进程中包括多个线程，每个线程都是作为利用CPU的基本单位，是花费最小开销的实体。线程具有以下属性。</p><p>　　1）轻型实体</p><p>　　线程中的实体基本上不拥有系统资源，只是有一点必不可少的、能保证独立运行的资源。</p><p>　　线程的实体包括程序、数据和TCB。线程是动态概念，它的动态特性由线程控制块TCB（Thread Control Block）描述。</p><p>​    2）独立调度和分派的基本单位</p><p>　　在多线程OS中，线程是能独立运行的基本单位，因而也是独立调度和分派的基本单位。由于线程很“轻”，故线程的切换非常迅速且开销小（在同一进程中的）。</p><p>​    3）共享进程资源</p><p>　　线程在同一进程中的各个线程，都可以共享该进程所拥有的资源，这首先表现在：所有线程都具有相同的进程id，这意味着，线程可以访问该进程的每一个内存资源；此外，还可以访问进程所拥有的已打开文件、定时器、信号量机构等。由于同一个进程内的线程共享内存和文件，所以线程之间互相通信不必调用内核。</p><p>　　4）可并发执行</p><p>　　<em>在一个进程中的多个线程之间，可以并发执行，甚至允许在一个进程中所有线程都能并发执行；同样，不同进程中的线程也能并发执行，充分利用和发挥了处理机与外围设备并行工作的能力。</em></p><blockquote><p>TCB包括以下信息：<br>（1）线程状态。<br>（2）当线程不运行时，被保存的现场资源。<br>（3）一组执行堆栈。<br>（4）存放每个线程的局部变量主存区。<br>（5）访问同一个进程中的主存和其它资源。<br>用于指示被执行指令序列的程序计数器、保留局部变量、少数状态参数和返回地址等的一组寄存器和堆栈。</p></blockquote><h4 id="进程和线程的区别"><a href="#进程和线程的区别" class="headerlink" title="进程和线程的区别"></a>进程和线程的区别</h4><ol><li>线程是共享内存空间的；进程的内存是独立的。</li><li>线程可以直接访问此进程中的数据部分；进程有他们独立拷贝自己父进程的数据部分，每个进程是独立的</li><li>同一进程的线程之间直接交流(直接交流涉及到数据共享，信息传递)；两个进程想通信，必须通过一个中间代理来实现。</li><li>创建一个新的线程很容易；创建新的进程需要对其父进程进行一次克隆。</li><li>一个线程可以控制和操作同一进程里的其他线程；但是进程只能操作子进程。</li><li>对主线程的修改，可能会影响到进程中其他线程的修改；对于一个父进程的修改不会影响其他子进程(只要不删除父进程即可)</li></ol><h5 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a><strong>疑问</strong></h5><p>进程和线程那个运行快？</p><p>它俩是没有可比性的，线程是寄生在进程中的，你问它俩谁快。说白了，就是问在问两个线程谁快。因为进程只是资源的集合，进程也是要起一个线程的，它俩没有可比性。</p><p>进程和线程那个启动快？</p><p>答案是：线程快。因为进程相当于在修一个屋子。线程只是一下把一个来过来就行了。进程是一堆资源的集合。它要去内存里面申请空间，它要各种各样的东西去跟OS去申请。但是启动起来一运行，它俩是一样的，因为进程也是通过线程来运行的。</p><h4 id="自己理解"><a href="#自己理解" class="headerlink" title="自己理解"></a>自己理解</h4><ol><li>线程是操作系统最小的调度单位，是一串指令的集合。</li><li>进程要操作CPU，必须先创建一个线程。</li><li>进程本身是不可以执行的，操作cpu是通过线程实现的，因为它是一堆执行，而进程是不具备执行概念的。就像一个屋子，屋子就是进程，但是屋子里面的每一个人就是线程，屋子就是内存空间。</li><li>单核CPU只能同时干一件事，但是为什么给我们的感觉是在干了很多件事？因为上线的切换，刚才也说了跟读书那个例子一样。因为CPU太快了，可以有N多次切换，其实它都是在排着队呐。</li><li>寄存器是存上下文关系的。</li><li>进程是通过PID来区分的，并不是通过进程名来区分的。进程里面的第一个线程就是主线程，父线程和子线程是相互独立的，只是父线程创建了子线程，父线程down了，子线程不会受到影响的。</li><li>主线程修改影响其他线程的行文，因为它们是共享数据的。</li></ol><h4 id="线程的创建Threading-Thread类"><a href="#线程的创建Threading-Thread类" class="headerlink" title="线程的创建Threading.Thread类"></a>线程的创建Threading.Thread类</h4><h5 id="线程的创建"><a href="#线程的创建" class="headerlink" title="线程的创建"></a>线程的创建</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sayhi</span><span class="params">(name)</span>:</span></span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    print(<span class="string">'%s say hello'</span> %name)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    t=Thread(target=sayhi,args=(<span class="string">'egon'</span>,))</span><br><span class="line">    t.start()</span><br><span class="line">    print(<span class="string">'主线程'</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sayhi</span><span class="params">(Thread)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,name)</span>:</span></span><br><span class="line">        super().__init__()</span><br><span class="line">        self.name=name</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        time.sleep(<span class="number">2</span>)</span><br><span class="line">        print(<span class="string">'%s say hello'</span> % self.name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    t = Sayhi(<span class="string">'egon'</span>)</span><br><span class="line">    t.start()</span><br><span class="line">    print(<span class="string">'主线程'</span>)</span><br></pre></td></tr></table></figure><h5 id="多线程与多进程"><a href="#多线程与多进程" class="headerlink" title="多线程与多进程"></a>多线程与多进程</h5><h6 id="pid的比较"><a href="#pid的比较" class="headerlink" title="pid的比较"></a>pid的比较</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">work</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'hello'</span>,os.getpid())</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment">#part1:在主进程下开启多个线程,每个线程都跟主进程的pid一样</span></span><br><span class="line">    t1=Thread(target=work)</span><br><span class="line">    t2=Thread(target=work)</span><br><span class="line">    t1.start()</span><br><span class="line">    t2.start()</span><br><span class="line">    print(<span class="string">'主线程/主进程pid'</span>,os.getpid())</span><br><span class="line"></span><br><span class="line">    <span class="comment">#part2:开多个进程,每个进程都有不同的pid</span></span><br><span class="line">    p1=Process(target=work)</span><br><span class="line">    p2=Process(target=work)</span><br><span class="line">    p1.start()</span><br><span class="line">    p2.start()</span><br><span class="line">    print(<span class="string">'主线程/主进程pid'</span>,os.getpid())</span><br></pre></td></tr></table></figure><h6 id="开启效率的较量"><a href="#开启效率的较量" class="headerlink" title="开启效率的较量"></a>开启效率的较量</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">work</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'hello'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment">#在主进程下开启线程</span></span><br><span class="line">    t=Thread(target=work)</span><br><span class="line">    t.start()</span><br><span class="line">    print(<span class="string">'主线程/主进程'</span>)</span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    打印结果:</span></span><br><span class="line"><span class="string">    hello</span></span><br><span class="line"><span class="string">    主线程/主进程</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#在主进程下开启子进程</span></span><br><span class="line">    t=Process(target=work)</span><br><span class="line">    t.start()</span><br><span class="line">    print(<span class="string">'主线程/主进程'</span>)</span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    打印结果:</span></span><br><span class="line"><span class="string">    主线程/主进程</span></span><br><span class="line"><span class="string">    hello</span></span><br><span class="line"><span class="string">    '''</span></span><br></pre></td></tr></table></figure><h6 id="内存数据的共享问题"><a href="#内存数据的共享问题" class="headerlink" title="内存数据的共享问题"></a>内存数据的共享问题</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span>  threading <span class="keyword">import</span> Thread</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">work</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> n</span><br><span class="line">    n=<span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment"># n=100</span></span><br><span class="line">    <span class="comment"># p=Process(target=work)</span></span><br><span class="line">    <span class="comment"># p.start()</span></span><br><span class="line">    <span class="comment"># p.join()</span></span><br><span class="line">    <span class="comment"># print('主',n) #毫无疑问子进程p已经将自己的全局的n改成了0,但改的仅仅是它自己的,查看父进程的n仍然为100</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    n=<span class="number">1</span></span><br><span class="line">    t=Thread(target=work)</span><br><span class="line">    t.start()</span><br><span class="line">    t.join()</span><br><span class="line">    print(<span class="string">'主'</span>,n) <span class="comment">#查看结果为0,因为同一进程内的线程之间共享进程内的数据</span></span><br></pre></td></tr></table></figure><p>上面的例子中最多只启动了一个2个线程，还是用那种古老的方式t1,t2。要是一下子起10个或者100个线程，这种方式就不适用了，其实可以在启动线程的时候，把它加到循环里面去，并且来计算一下它的时间 ：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading,time</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(n)</span>:</span>   <span class="comment">#这边的run方法的名字是自行定义的，跟继承式多线程不一样，那个是强制的</span></span><br><span class="line">    print(<span class="string">"task:"</span>,n)</span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    print(<span class="string">"task done"</span>,n)</span><br><span class="line">  </span><br><span class="line">start_time = time.time()  <span class="comment">#开始时间</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):   <span class="comment">#一次性启动5个线程</span></span><br><span class="line">    t = threading.Thread(target=run,args=(<span class="string">"t-&#123;0&#125;"</span>.format(i),))</span><br><span class="line">    t.start()</span><br><span class="line">  </span><br><span class="line">print(<span class="string">"--------all thead has finished"</span>)</span><br><span class="line">print(<span class="string">"cost:"</span>,time.time()-start_time)  <span class="comment">#计算总耗时</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">#执行结果</span></span><br><span class="line">task: t<span class="number">-0</span></span><br><span class="line">task: t<span class="number">-1</span></span><br><span class="line">task: t<span class="number">-2</span></span><br><span class="line">task: t<span class="number">-3</span></span><br><span class="line">task: t<span class="number">-4</span></span><br><span class="line">--------all thead has finished</span><br><span class="line">cost: <span class="number">0.00096893310546875</span></span><br><span class="line">task done t<span class="number">-1</span></span><br><span class="line">task done t<span class="number">-2</span></span><br><span class="line">task done t<span class="number">-0</span></span><br><span class="line">task done t<span class="number">-4</span></span><br><span class="line">task done t<span class="number">-3</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>这里设置成启动5个线程，并且计算一下时间。这里有个疑问，为什么不启动1000个线程或者更多一点的线程？这是因为：计算机是4核的，它能干的事情，就是4个任务。启动的线程越多，就代表着要在这个很多线程之间进行上下文切换。相当于教室里有一本书，某个人只看了半页，因为cpu要确保每个人都能执行，也就是这本是要确保教室每个同学都能看到，那就相当于每个人看书的时间非常少。也就是说某个同学刚刚把这本书拿过来，一下子又被第二个人，第三个人拿走了。所以就导致所有的人都慢了，所以说如果线程启动1000就没有意义了，导致机器越来越慢，所以要适当设置</strong> </p></blockquote><p>从上面的程序发现，就是我主线程没有等其他的子线程执行完毕，就直接往下执行了，这是为什么呢？而且这个计算的时间根本不是我们想要的时间，中间的sleep 2秒哪里去了?</p><p>其实一个程序至少有一个线程，那先往下走的，没有等的就是主线程，主线程启动了子线程之后，子线程就是独立的，跟主线程就没有关系了。主线程和它启动的子线程是并行关系，这就解释了为什么我的主线程启动子线程之后，没有等子线程，而继续往下走了。所以计算不出来线程总共耗时时间，因为程序已经不是串行的了。程序本身就是一个线程，就是主线程。如果要想测试这五个线程总共花了多长时间，就需要用到线程的join()方法</p><h5 id="join"><a href="#join" class="headerlink" title="join"></a>join</h5><p><img src="..\img\thread\2062170187.png" alt=""></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span><span class="params">(threading.Thread)</span>:</span>  <span class="comment"># 继承threading.Thread</span></span><br><span class="line">    <span class="string">"""继承式多线程"""</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, n, sleep_time)</span>:</span>  <span class="comment"># 增加时间属性</span></span><br><span class="line">        threading.Thread.__init__(self)  <span class="comment"># 也可以写成这样super(MyThread,self).__init__()</span></span><br><span class="line">        self.n = n</span><br><span class="line">        self.sleep_time = sleep_time</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span>  <span class="comment"># 重写run方法</span></span><br><span class="line">        print(<span class="string">'run task'</span>, self.n)</span><br><span class="line">        time.sleep(self.sleep_time)  <span class="comment"># 每个线程可以传入不不同的时间</span></span><br><span class="line">        print(<span class="string">'task done,'</span>, self.n)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">t1 = MyThread(<span class="string">'t1'</span>, <span class="number">2</span>)  <span class="comment"># 实例化</span></span><br><span class="line">t2 = MyThread(<span class="string">'t2'</span>, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">t1.start()  <span class="comment"># 启动一个多线程</span></span><br><span class="line">t2.start()</span><br><span class="line"></span><br><span class="line">t1.join()  <span class="comment"># 把t1.join()放在线程启动之后</span></span><br><span class="line">print(<span class="string">"main thread....."</span>)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">#执行结果</span></span><br><span class="line">run task t1</span><br><span class="line">run task t2</span><br><span class="line">task done, t1</span><br><span class="line">main thread.....</span><br><span class="line">task done, t2</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意：</strong>t1.join() 只等t1的结果，然后主线程继续往下走，因为t2需要等4秒，所以，最后打出来的是t2的执行结果。t1的结果到了，就立刻算结果。这边只计算了t1的结果，没有t2的结果 </p></blockquote><p>那我们怎么计算多个线程的执行时间呢？来我们一起看一下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(n)</span>:</span>  <span class="comment"># 这边的run方法的名字是自行定义的，跟继承式多线程不一样，那个是强制的</span></span><br><span class="line">    print(<span class="string">'task:'</span>, n)</span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    print(<span class="string">'task done'</span>, n)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">start_time = time.time()  <span class="comment"># 开始时间</span></span><br><span class="line">t_obj = []  <span class="comment"># 存放子线程实例</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):  <span class="comment"># 一次性启动10个线程</span></span><br><span class="line">    t = threading.Thread(target=run, args=(<span class="string">'t-&#123;0&#125;'</span>.format(i),))</span><br><span class="line">    t.start()</span><br><span class="line">    t_obj.append(t)  <span class="comment"># 为了不阻塞后面线程的启动，不在这里join，先放到一个列表中</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> t <span class="keyword">in</span> t_obj:  <span class="comment"># 循环线程实例列表，等待所有线程执行完毕</span></span><br><span class="line">    t.join()</span><br><span class="line"></span><br><span class="line">print(<span class="string">'所有线程已经完成'</span>)</span><br><span class="line">print(<span class="string">'cost:'</span>, time.time() - start_time)  <span class="comment"># 计算总耗时</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 执行结果</span></span><br><span class="line">task: t<span class="number">-0</span></span><br><span class="line">task: t<span class="number">-1</span></span><br><span class="line">task: t<span class="number">-2</span></span><br><span class="line">task: t<span class="number">-3</span></span><br><span class="line">task: t<span class="number">-4</span></span><br><span class="line">task: t<span class="number">-5</span></span><br><span class="line">task: t<span class="number">-6</span></span><br><span class="line">task: t<span class="number">-7</span></span><br><span class="line">task: t<span class="number">-8</span></span><br><span class="line">task: t<span class="number">-9</span></span><br><span class="line">task done t<span class="number">-0</span></span><br><span class="line">task done t<span class="number">-1</span></span><br><span class="line">task done t<span class="number">-2</span></span><br><span class="line">task done t<span class="number">-4</span></span><br><span class="line">task done t<span class="number">-3</span></span><br><span class="line">task done t<span class="number">-5</span></span><br><span class="line">task done t<span class="number">-6</span></span><br><span class="line">task done t<span class="number">-9</span></span><br><span class="line">task done t<span class="number">-7</span></span><br><span class="line">task done t<span class="number">-8</span></span><br><span class="line">所有线程已经完成</span><br><span class="line">cost: <span class="number">2.007737159729004</span></span><br></pre></td></tr></table></figure><p>上面的例子在不加join的时候，主线程和子线程完全是并行的，没有了依赖关系，主线程执行了，子线程也执行了。但是加了join之后，主线程依赖子线程执行完毕才往下走。 下面将介绍守护线程</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;线程&quot;&gt;&lt;a href=&quot;#线程&quot; class=&quot;headerlink&quot; title=&quot;线程&quot;&gt;&lt;/a&gt;线程&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;CPU上的执行单位，线程也是程序运行过程中的一个抽象。&lt;/li&gt;
&lt;li&gt;一个进程下可以有多个线程。&lt;/li&gt;
&lt;li&gt;主线程：
      
    
    </summary>
    
      <category term="Python线程" scheme="http://gavinliu4011.github.io/categories/Python%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="Python" scheme="http://gavinliu4011.github.io/tags/Python/"/>
    
      <category term="线程" scheme="http://gavinliu4011.github.io/tags/%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>用Python操作Redis</title>
    <link href="http://gavinliu4011.github.io/post/9f312a12.html"/>
    <id>http://gavinliu4011.github.io/post/9f312a12.html</id>
    <published>2018-02-11T18:02:32.000Z</published>
    <updated>2018-02-11T10:02:43.090Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Redis安装和使用"><a href="#Redis安装和使用" class="headerlink" title="Redis安装和使用"></a>Redis安装和使用</h3><h4 id="Window-下安装"><a href="#Window-下安装" class="headerlink" title="Window 下安装"></a>Window 下安装</h4><p><strong>下载地址：</strong><a href="https://github.com/MSOpenTech/redis/releases" target="_blank" rel="noopener">https://github.com/MSOpenTech/redis/releases</a>。</p><p>Redis 支持 32 位和 64 位。这个需要根据你系统平台的实际情况选择，这里我们下载 <strong>Redis-x64-xxx.zip</strong>压缩包到 C 盘，解压后，将文件夹重新命名为 <strong>redis</strong>。</p><p><img src="http://www.runoob.com/wp-content/uploads/2014/11/3B8D633F-14CE-42E3-B174-FCCD48B11FF3.jpg" alt="img"></p><p>打开一个 <strong>cmd</strong> 窗口 使用cd命令切换目录到 <strong>C:\redis</strong> 运行 <strong>redis-server.exe redis.windows.conf</strong> 。</p><p>如果想方便的话，可以把 redis 的路径加到系统的环境变量里，这样就省得再输路径了，后面的那个 redis.windows.conf 可以省略，如果省略，会启用默认的。输入之后，会显示如下界面：</p><p>这时候另启一个cmd窗口，原来的不要关闭，不然就无法访问服务端了。</p><p>切换到redis目录下运行 <strong>redis-cli.exe -h 127.0.0.1 -p 6379</strong> 。</p><p>设置键值对 <strong>set myKey abc</strong></p><p>取出键值对 <strong>get myKey</strong></p><p><img src="http://www.runoob.com/wp-content/uploads/2014/11/redis-install2.jpg" alt="Redis 安装"></p><hr><h4 id="Linux-下安装"><a href="#Linux-下安装" class="headerlink" title="Linux 下安装"></a>Linux 下安装</h4><p><strong>下载地址：</strong><a href="http://redis.io/download" target="_blank" rel="noopener">http://redis.io/download</a>，下载最新稳定版本。</p><p>本文档使用3.2.11,下载并安装:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ wget http://download.redis.io/releases/redis-3.2.11.tar.gz</span><br><span class="line">$ tar -xvf redis-3.2.11.tar.gz</span><br><span class="line">$ <span class="built_in">cd</span> redis-3.2.11</span><br><span class="line">$ make &amp;&amp; make install</span><br></pre></td></tr></table></figure><p>安装完成后,我们先改一下redis.conf的配置:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ cp redis.conf ../myredis.conf <span class="comment"># 将文件redis.conf复制到上以及文件夹下并命名为myredis.conf</span></span><br><span class="line">$ <span class="built_in">cd</span> ..</span><br><span class="line">$ vim myredis.conf</span><br><span class="line"><span class="comment"># redis.conf是一个默认的配置文件。我们可以根据需要使用自己的配置文件。</span></span><br><span class="line"><span class="comment"># 建议修改以下地方:</span></span><br><span class="line"><span class="comment"># 找到bind这个地方并修改成[bind 本机内网地址]</span></span><br><span class="line"><span class="comment"># 再找到requirepass这个地方,这里是修改redis的密码</span></span><br><span class="line"><span class="comment"># 完成上述操作后保存退出</span></span><br><span class="line">$ redis-server myredis.conf</span><br></pre></td></tr></table></figure><p>启动redis服务进程后，就可以使用测试客户端程序redis-cli和redis服务交互了,如:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ redis-cli -h host -p port</span><br><span class="line">$ auth [password] <span class="comment"># 这里输入的密码就是你上面设置的密码,如果没有则跳过此步骤</span></span><br><span class="line">redis 127.0.0.1:6379&gt; ping</span><br><span class="line">PONG</span><br><span class="line">$ redis-cli -h host -p port -a password <span class="comment"># 这个命令也能登录</span></span><br></pre></td></tr></table></figure><h4 id="用Python连接Redis"><a href="#用Python连接Redis" class="headerlink" title="用Python连接Redis"></a>用Python连接Redis</h4><p>当前在本地我已经安装了 Redis 并运行在 9736 端口，密码设置为 123456</p><p>用下面例子连接Redis进行测试:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> redis</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    config = &#123;</span><br><span class="line">        <span class="string">'host'</span>: <span class="string">'localhost'</span>,</span><br><span class="line">        <span class="string">'port'</span>: <span class="number">9736</span>,</span><br><span class="line">        <span class="string">'db'</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="string">'password'</span>: <span class="string">'123456'</span></span><br><span class="line">    &#125;</span><br><span class="line">    client = redis.Redis(**config)</span><br><span class="line">    <span class="keyword">if</span> client.ping():</span><br><span class="line">        client.set(<span class="string">'name'</span>, <span class="string">'gavinliu'</span>)</span><br><span class="line">        print(client.get(<span class="string">'name'</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>在这里我们使用redis.Redis传入参数连接本地Redis服务,传入的四个参数分别为<code>Redis的地址</code>、<code>运行端口</code>、<code>使用的数据库</code>、<code>密码</code>，我们这里使用的Redis其实是继承了StrictRedis，所以在默认情况下不传这四个参数时，参数值会有默认值分别为localhost、6379、0、None。</p><p>上面运行的结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">b'gavinliu'</span></span><br></pre></td></tr></table></figure><p>在Python中使用Redis其实很方便，Redis的命令(命令详细情况可以参照<a href="http://redisdoc.com/" target="_blank" rel="noopener">Redis命令参考</a>)在Python中都能找到相应的方法，这里引用<a href="https://cuiqingcai.com/" target="_blank" rel="noopener">崔庆才老师</a>对Redis总结介绍一下Key(键)、String(字符串)、Hash(哈希表)、List(列表)、Set(集合)、SortedSet(有序集合)</p><blockquote><p><strong>Key(键)</strong></p></blockquote><table><thead><tr><th>方法</th><th>作用</th><th>参数说明</th><th>示例</th><th>示例说明</th><th>示例结果</th></tr></thead><tbody><tr><td>exists(name)</td><td>判断一个key是否存在</td><td>name: key名</td><td>redis.exists(‘name’)</td><td>是否存在name这个key</td><td>True</td></tr><tr><td>delete(name)</td><td>删除一个key</td><td>name: key名</td><td>redis.delete(‘name’)</td><td>删除name这个key</td><td>1</td></tr><tr><td>type(name)</td><td>判断key类型</td><td>name: key名</td><td>redis.type(‘name’)</td><td>判断name这个key类型</td><td>b’string’</td></tr><tr><td>keys(pattern)</td><td>获取所有符合规则的key</td><td>pattern: 匹配规则</td><td>redis.keys(‘n*’)</td><td>获取所有以n开头的key</td><td>[b’name’]</td></tr><tr><td>randomkey()</td><td>获取随机的一个key</td><td></td><td>randomkey()</td><td>获取随机的一个key</td><td>b’name’</td></tr><tr><td>rename(src, dst)</td><td>将key重命名</td><td>src: 原key名 dst: 新key名</td><td>redis.rename(‘name’, ‘nickname’)</td><td>将name重命名为nickname</td><td>True</td></tr><tr><td>dbsize()</td><td>获取当前数据库中key的数目</td><td></td><td>dbsize()</td><td>获取当前数据库中key的数目</td><td>100</td></tr><tr><td>expire(name, time)</td><td>设定key的过期时间，单位秒</td><td>name: key名 time: 秒数</td><td>redis.expire(‘name’, 2)</td><td>将name这key的过期时间设置2秒</td><td>True</td></tr><tr><td>ttl(name)</td><td>获取key的过期时间，单位秒，-1为永久不过期</td><td>name: key名</td><td>redis.ttl(‘name’)</td><td>获取name这key的过期时间</td><td>-1</td></tr><tr><td>move(name, db)</td><td>将key移动到其他数据库</td><td>name: key名 db: 数据库代号</td><td>move(‘name’, 2)</td><td>将name移动到2号数据库</td><td>True</td></tr><tr><td>flushdb()</td><td>删除当前选择数据库中的所有key</td><td></td><td>flushdb()</td><td>删除当前选择数据库中的所有key</td><td>True</td></tr><tr><td>flushall()</td><td>删除所有数据库中的所有key</td><td></td><td>flushall()</td><td>删除所有数据库中的所有key</td><td>True</td></tr></tbody></table><blockquote><p><strong>String(字符串)</strong></p></blockquote><table><thead><tr><th>方法</th><th>作用</th><th>参数说明</th><th>示例</th><th>示例说明</th><th>示例结果</th></tr></thead><tbody><tr><td>set(name, value)</td><td>给数据库中key为name的string赋予值value</td><td>name: key名 value: 值</td><td>redis.set(‘name’, ‘Bob’)</td><td>给name这个key的value赋值为Bob</td><td>True</td></tr><tr><td>get(name)</td><td>返回数据库中key为name的string的value</td><td>name: key名</td><td>redis.get(‘name’)</td><td>返回name这个key的value</td><td>b’Bob’</td></tr><tr><td>getset(name, value)</td><td>给数据库中key为name的string赋予值value并返回上次的value</td><td>name: key名 value: 新值</td><td>redis.getset(‘name’, ‘Mike’)</td><td>赋值name为Mike并得到上次的value</td><td>b’Bob’</td></tr><tr><td>mget(keys, *args)</td><td>返回多个key对应的value</td><td>keys: key的列表</td><td>redis.mget([‘name’, ‘nickname’])</td><td>返回name和nickname的value</td><td>[b’Mike’, b’Miker’]</td></tr><tr><td>setnx(name, value)</td><td>如果key不存在才设置value</td><td>name: key名</td><td>redis.setnx(‘newname’, ‘James’)</td><td>如果newname这key不存在则设置值为James</td><td>第一次运行True，第二次False</td></tr><tr><td>setex(name, time, value)</td><td>设置可以对应的值为string类型的value，并指定此键值对应的有效期</td><td>name: key名 time: 有效期 value: 值</td><td>redis.setex(‘name’, 1, ‘James’)</td><td>将name这key的值设为James，有效期1秒</td><td>True</td></tr><tr><td>setrange(name, offset, value)</td><td>设置指定key的value值的子字符串</td><td>name: key名 offset: 偏移量 value: 值</td><td>redis.set(‘name’, ‘Hello’) redis.setrange(‘name’, 6, ‘World’)</td><td>设置name为Hello字符串，并在index为6的位置补World</td><td>11，修改后的字符串长度</td></tr><tr><td>mset(mapping)</td><td>批量赋值</td><td>mapping: 字典</td><td>redis.mset({‘name1’: ‘Durant’, ‘name2’: ‘James’})</td><td>将name1设为Durant，name2设为James</td><td>True</td></tr><tr><td>msetnx(mapping)</td><td>key均不存在时才批量赋值</td><td>mapping: 字典</td><td>redis.msetnx({‘name3’: ‘Smith’, ‘name4’: ‘Curry’})</td><td>在name3和name4均不存在的情况下才设置二者值</td><td>True</td></tr><tr><td>incr(name, amount=1)</td><td>key为name的value增值操作，默认1，key不存在则被创建并设为amount</td><td>name: key名 amount:增长的值</td><td>redis.incr(‘age’, 1)</td><td>age对应的值增1，若不存在则会创建并设置为1</td><td>1，即修改后的值</td></tr><tr><td>decr(name, amount=1)</td><td>key为name的value减值操作，默认1，key不存在则被创建并设置为-amount</td><td>name: key名 amount:减少的值</td><td>redis.decr(‘age’, 1)</td><td>age对应的值减1，若不存在则会创建并设置为-1</td><td>-1，即修改后的值</td></tr><tr><td>append(key, value)</td><td>key为name的string的值附加value</td><td>key: key名</td><td>redis.append(‘nickname’, ‘OK’)</td><td>向key为nickname的值后追加OK</td><td>13，即修改后的字符串长度</td></tr><tr><td>substr(name, start, end=-1)</td><td>返回key为name的string的value的子串</td><td>name: key名 start: 起始索引 end: 终止索引，默认-1截取到末尾</td><td>redis.substr(‘name’, 1, 4)</td><td>返回key为name的值的字符串，截取索引为1-4的字符</td><td>b’ello’</td></tr><tr><td>getrange(key, start, end)</td><td>获取key的value值从start到end的子字符串</td><td>key: key名 start: 起始索引 end: 终止索引</td><td>redis.getrange(‘name’, 1, 4)</td><td>返回key为name的值的字符串，截取索引为1-4的字符</td><td>b’ello’</td></tr></tbody></table><blockquote><p><strong>Hash(哈希表)</strong></p></blockquote><p>Hash，即哈希。Redis 还提供了哈希表的数据结构，我们可以用name指定一个哈希表的名称，然后表内存储了各个键值对，用法总结如下：</p><table><thead><tr><th>方法</th><th>作用</th><th>参数说明</th><th>示例</th><th>示例说明</th><th>示例结果</th></tr></thead><tbody><tr><td>hset(name, key, value)</td><td>向key为name的hash中添加映射</td><td>name: key名 key: 映射键名 value: 映射键值</td><td>hset(‘price’, ‘cake’, 5)</td><td>向key为price的hash中添加映射关系，cake的值为5</td><td>1，即添加的映射个数</td></tr><tr><td>hsetnx(name, key, value)</td><td>向key为name的hash中添加映射，如果映射键名不存在</td><td>name: key名 key: 映射键名 value: 映射键值</td><td>hsetnx(‘price’, ‘book’, 6)</td><td>向key为price的hash中添加映射关系，book的值为6</td><td>1，即添加的映射个数</td></tr><tr><td>hget(name, key)</td><td>返回key为name的hash中field对应的value</td><td>name: key名 key: 映射键名</td><td>redis.hget(‘price’, ‘cake’)</td><td>获取key为price的hash中键名为cake的value</td><td>5</td></tr><tr><td>hmget(name, keys, *args)</td><td>返回key为name的hash中各个键对应的value</td><td>name: key名 keys: 映射键名列表</td><td>redis.hmget(‘price’, [‘apple’, ‘orange’])</td><td>获取key为price的hash中apple和orange的值</td><td>[b’3’, b’7’]</td></tr><tr><td>hmset(name, mapping)</td><td>向key为name的hash中批量添加映射</td><td>name: key名 mapping: 映射字典</td><td>redis.hmset(‘price’, {‘banana’: 2, ‘pear’: 6})</td><td>向key为price的hash中批量添加映射</td><td>True</td></tr><tr><td>hincrby(name, key, amount=1)</td><td>将key为name的hash中映射的value增加amount</td><td>name: key名 key: 映射键名 amount: 增长量</td><td>redis.hincrby(‘price’, ‘apple’, 3)</td><td>key为price的hash中apple的值增加3</td><td>6，修改后的值</td></tr><tr><td>hexists(name, key)</td><td>key为namehash中是否存在键名为key的映射</td><td>name: key名 key: 映射键名</td><td>redis.hexists(‘price’, ‘banana’)</td><td>key为price的hash中banana的值是否存在</td><td>True</td></tr><tr><td>hdel(name, *keys)</td><td>key为namehash中删除键名为key的映射</td><td>name: key名 key: 映射键名</td><td>redis.hdel(‘price’, ‘banana’)</td><td>从key为price的hash中删除键名为banana的映射</td><td>True</td></tr><tr><td>hlen(name)</td><td>从key为name的hash中获取映射个数</td><td>name: key名</td><td>redis.hlen(‘price’)</td><td>从key为price的hash中获取映射个数</td><td>6</td></tr><tr><td>hkeys(name)</td><td>从key为name的hash中获取所有映射键名</td><td>name: key名</td><td>redis.hkeys(‘price’)</td><td>从key为price的hash中获取所有映射键名</td><td>[b’cake’, b’book’, b’banana’, b’pear’]</td></tr><tr><td>hvals(name)</td><td>从key为name的hash中获取所有映射键值</td><td>name: key名</td><td>redis.hvals(‘price’)</td><td>从key为price的hash中获取所有映射键值</td><td>[b’5’, b’6’, b’2’, b’6’]</td></tr><tr><td>hgetall(name)</td><td>从key为name的hash中获取所有映射键值对</td><td>name: key名</td><td>redis.hgetall(‘price’)</td><td>从key为price的hash中获取所有映射键值对</td><td>{b’cake’: b’5’, b’book’: b’6’, b’orange’: b’7’, b’pear’: b’6’}</td></tr></tbody></table><blockquote><p><strong>List(列表)</strong></p></blockquote><p>Redis 还提供了列表存储，列表内的元素可以重复，而且可以从两端存储</p><table><thead><tr><th>方法</th><th>作用</th><th>参数说明</th><th>示例</th><th>示例说明</th><th>示例结果</th></tr></thead><tbody><tr><td>rpush(name, *values)</td><td>在key为name的list尾添加值为value的元素，可以传多个</td><td>name: key名 values: 值</td><td>redis.rpush(‘list’, 1, 2, 3)</td><td>给list这个key的list尾添加1、2、3</td><td>3，list大小</td></tr><tr><td>lpush(name, *values)</td><td>在key为name的list头添加值为value的元素，可以传多个</td><td>name: key名 values: 值</td><td>redis.lpush(‘list’, 0)</td><td>给list这个key的list头添加0</td><td>4，list大小</td></tr><tr><td>llen(name)</td><td>返回key为name的list的长度</td><td>name: key名</td><td>redis.llen(‘list’)</td><td>返回key为list的列表的长度</td><td>4</td></tr><tr><td>lrange(name, start, end)</td><td>返回key为name的list中start至end之间的元素</td><td>name: key名 start: 起始索引 end: 终止索引</td><td>redis.lrange(‘list’, 1, 3)</td><td>返回起始为1终止为3的索引范围对应的list</td><td><code>[b&#39;3&#39;, b&#39;2&#39;, b&#39;1&#39;]</code></td></tr><tr><td>ltrim(name, start, end)</td><td>截取key为name的list，保留索引为start到end的内容</td><td>name:key名 start: 起始索引 end: 终止索引</td><td>ltrim(‘list’, 1, 3)</td><td>保留key为list的索引为1到3的元素</td><td>True</td></tr><tr><td>lindex(name, index)</td><td>返回key为name的list中index位置的元素</td><td>name: key名 index: 索引</td><td>redis.lindex(‘list’, 1)</td><td>返回key为list的列表index为1的元素</td><td>b’2’</td></tr><tr><td>lset(name, index, value)</td><td>给key为name的list中index位置的元素赋值，越界则报错</td><td>name: key名 index: 索引位置 value: 值</td><td>redis.lset(‘list’, 1, 5)</td><td>将key为list的list索引1位置赋值为5</td><td>True</td></tr><tr><td>lrem(name, count, value)</td><td>删除count个key的list中值为value的元素</td><td>name: key名 count: 删除个数 value: 值</td><td>redis.lrem(‘list’, 2, 3)</td><td>将key为list的列表删除2个3</td><td>1，即删除的个数</td></tr><tr><td>lpop(name)</td><td>返回并删除key为name的list中的首元素</td><td>name: key名</td><td>redis.lpop(‘list’)</td><td>返回并删除名为list的list第一个元素</td><td>b’5’</td></tr><tr><td>rpop(name)</td><td>返回并删除key为name的list中的尾元素</td><td>name: key名</td><td>redis.rpop(‘list’)</td><td>返回并删除名为list的list最后一个元素</td><td>b’2’</td></tr><tr><td>blpop(keys, timeout=0)</td><td>返回并删除名称为在keys中的list中的首元素，如果list为空，则会一直阻塞等待</td><td>keys: key列表 timeout: 超时等待时间，0为一直等待</td><td>redis.blpop(‘list’)</td><td>返回并删除名为list的list的第一个元素</td><td>[b’5’]</td></tr><tr><td>brpop(keys, timeout=0)</td><td>返回并删除key为name的list中的尾元素，如果list为空，则会一直阻塞等待</td><td>keys: key列表 timeout: 超时等待时间，0为一直等待</td><td>redis.brpop(‘list’)</td><td>返回并删除名为list的list的最后一个元素</td><td>[b’2’]</td></tr><tr><td>rpoplpush(src, dst)</td><td>返回并删除名称为src的list的尾元素，并将该元素添加到名称为dst的list的头部</td><td>src: 源list的key dst: 目标list的key</td><td>redis.rpoplpush(‘list’, ‘list2’)</td><td>将key为list的list尾元素删除并返回并将其添加到key为list2的list头部</td><td>b’2’</td></tr></tbody></table><blockquote><p><strong>Set(集合)</strong></p></blockquote><p>Redis 还提供了集合存储，集合中的元素都是不重复的</p><table><thead><tr><th>方法</th><th>作用</th><th>参数说明</th><th>示例</th><th>示例说明</th><th>示例结果</th></tr></thead><tbody><tr><td>sadd(name, *values)</td><td>向key为name的set中添加元素</td><td>name: key名 values: 值，可为多个</td><td>redis.sadd(‘tags’, ‘Book’, ‘Tea’, ‘Coffee’)</td><td>向key为tags的set中添加Book、Tea、Coffee三个内容</td><td>3，即插入的数据个数</td></tr><tr><td>srem(name, *values)</td><td>从key为name的set中删除元素</td><td>name: key名 values: 值，可为多个</td><td>redis.srem(‘tags’, ‘Book’)</td><td>从key为tags的set中删除Book</td><td>1，即删除的数据个数</td></tr><tr><td>spop(name)</td><td>随机返回并删除key为name的set中一个元素</td><td>name: key名</td><td>redis.spop(‘tags’)</td><td>从key为tags的set中随机删除并返回该元素</td><td>b’Tea’</td></tr><tr><td>smove(src, dst, value)</td><td>从src对应的set中移除元素并添加到dst对应的set中</td><td>src: 源set dst: 目标set value: 元素值</td><td>redis.smove(‘tags’, ‘tags2’, ‘Coffee’)</td><td>从key为tags的set中删除元素Coffee并添加到key为tags2的set</td><td>True</td></tr><tr><td>scard(name)</td><td>返回key为name的set的元素个数</td><td>name: key名</td><td>redis.scard(‘tags’)</td><td>获取key为tags的set中元素个数</td><td>3</td></tr><tr><td>sismember(name, value)</td><td>测试member是否是key为name的set的元素</td><td>name:key值</td><td>redis.sismember(‘tags’, ‘Book’)</td><td>判断Book是否为key为tags的set元素</td><td>True</td></tr><tr><td>sinter(keys, *args)</td><td>返回所有给定key的set的交集</td><td>keys: key列表</td><td>redis.sinter([‘tags’, ‘tags2’])</td><td>返回key为tags的set和key为tags2的set的交集</td><td>{b’Coffee’}</td></tr><tr><td>sinterstore(dest, keys, *args)</td><td>求交集并将交集保存到dest的集合</td><td>dest:结果集合 keys:key列表</td><td>redis.sinterstore(‘inttag’, [‘tags’, ‘tags2’])</td><td>求key为tags的set和key为tags2的set的交集并保存为inttag</td><td>1</td></tr><tr><td>sunion(keys, *args)</td><td>返回所有给定key的set的并集</td><td>keys: key列表</td><td>redis.sunion([‘tags’, ‘tags2’])</td><td>返回key为tags的set和key为tags2的set的并集</td><td>{b’Coffee’, b’Book’, b’Pen’}</td></tr><tr><td>sunionstore(dest, keys, *args)</td><td>求并集并将并集保存到dest的集合</td><td>dest:结果集合 keys:key列表</td><td>redis.sunionstore(‘inttag’, [‘tags’, ‘tags2’])</td><td>求key为tags的set和key为tags2的set的并集并保存为inttag</td><td>3</td></tr><tr><td>sdiff(keys, *args)</td><td>返回所有给定key的set的差集</td><td>keys: key列表</td><td>redis.sdiff([‘tags’, ‘tags2’])</td><td>返回key为tags的set和key为tags2的set的差集</td><td>{b’Book’, b’Pen’}</td></tr><tr><td>sdiffstore(dest, keys, *args)</td><td>求差集并将差集保存到dest的集合</td><td>dest:结果集合 keys:key列表</td><td>redis.sdiffstore(‘inttag’, [‘tags’, ‘tags2’])</td><td>求key为tags的set和key为tags2的set的差集并保存为inttag</td><td>3</td></tr><tr><td>smembers(name)</td><td>返回key为name的set的所有元素</td><td>name: key名</td><td>redis.smembers(‘tags’)</td><td>返回key为tags的set的所有元素</td><td>{b’Pen’, b’Book’, b’Coffee’}</td></tr><tr><td>srandmember(name)</td><td>随机返回key为name的set的一个元素，但不删除元素</td><td>name: key值</td><td>redis.srandmember(‘tags’)</td><td>随机返回key为tags的set的一个元素</td></tr></tbody></table><blockquote><p><strong>SortedSet(有序集合)</strong></p></blockquote><p>有序集合，它相比集合多了一个分数字段，利用它我们可以对集合中的数据进行排序</p><table><thead><tr><th>方法</th><th>作用</th><th>参数说明</th><th>示例</th><th>示例说明</th><th>示例结果</th></tr></thead><tbody><tr><td>zadd(name, <em>args, *</em>kwargs)</td><td>向key为name的zset中添加元素member，score用于排序。如果该元素存在，则更新其顺序</td><td>name: key名 args: 可变参数</td><td>redis.zadd(‘grade’, 100, ‘Bob’, 98, ‘Mike’)</td><td>向key为grade的zset中添加Bob，score为100，添加Mike，score为98</td><td>2，即添加的元素个数</td></tr><tr><td>zrem(name, *values)</td><td>删除key为name的zset中的元素</td><td>name: key名 values: 元素</td><td>redis.zrem(‘grade’, ‘Mike’)</td><td>从key为grade的zset中删除Mike</td><td>1，即删除的元素个数</td></tr><tr><td>zincrby(name, value, amount=1)</td><td>如果在key为name的zset中已经存在元素value，则该元素的score增加amount，否则向该集合中添加该元素，其score的值为amount</td><td>name: key名 value: 元素 amount: 增长的score值</td><td>redis.zincrby(‘grade’, ‘Bob’, -2)</td><td>key为grade的zset中Bob的score减2</td><td>98.0，即修改后的值</td></tr><tr><td>zrank(name, value)</td><td>返回key为name的zset中元素的排名（按score从小到大排序）即下标</td><td>name: key名 value: 元素值</td><td>redis.zrank(‘grade’, ‘Amy’)</td><td>得到key为grade的zset中Amy的排名</td><td>1</td></tr><tr><td>zrevrank(name, value)</td><td>返回key为name的zset中元素的倒数排名（按score从大到小排序）即下标</td><td>name: key名 value: 元素值</td><td>redis.zrevrank(‘grade’, ‘Amy’)</td><td>得到key为grade的zset中Amy的倒数排名</td><td>2</td></tr><tr><td>zrevrange(name, start, end, withscores=False)</td><td>返回key为name的zset（按score从大到小排序）中的index从start到end的所有元素</td><td>name: key值 start: 开始索引 end: 结束索引 withscores: 是否带score</td><td>redis.zrevrange(‘grade’, 0, 3)</td><td>返回key为grade的zset前四名元素</td><td>[b’Bob’, b’Mike’, b’Amy’, b’James’]</td></tr><tr><td>zrangebyscore(name, min, max, start=None, num=None, withscores=False)</td><td>返回key为name的zset中score在给定区间的元素</td><td>name:key名 min: 最低score max:最高score start: 起始索引 num: 个数 withscores: 是否带score</td><td>redis.zrangeby score(‘grade’, 80, 95)</td><td>返回key为grade的zset中score在80和95之间的元素</td><td>[b’Amy’, b’James’]</td></tr><tr><td>zcount(name, min, max)</td><td>返回key为name的zset中score在给定区间的数量</td><td>name:key名 min: 最低score max: 最高score</td><td>redis.zcount(‘grade’, 80, 95)</td><td>返回key为grade的zset中score在80到95的元素个数</td><td>2</td></tr><tr><td>zcard(name)</td><td>返回key为name的zset的元素个数</td><td>name: key名</td><td>redis.zcard(‘grade’)</td><td>获取key为grade的zset中元素个数</td><td>3</td></tr><tr><td>zremrangebyrank(name, min, max)</td><td>删除key为name的zset中排名在给定区间的元素</td><td>name:key名 min: 最低位次 max: 最高位次</td><td>redis.zremran gebyrank(‘grade’, 0, 0)</td><td>删除key为grade的zset中排名第一的元素</td><td>1，即删除的元素个数</td></tr><tr><td>zremrangebyscore(name, min, max)</td><td>删除key为name的zset中score在给定区间的元素</td><td>name:key名 min: 最低score max:最高score</td><td>redis.zremran gebyscore (‘grade’, 80, 90)</td><td>删除score在80到90之间的元素</td><td>1，即删除的元素个数</td></tr></tbody></table><blockquote><p>注意：上面代码中由于展示显示不完全，本人做了相应的处理，原本是一个方法名的可能方法名中间会出现空格</p></blockquote><p>以上便是用Python操作Redis的总结了，在后面的项目中会常用到Redis操作，所以我们还是需要掌握一些常用操作。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Redis安装和使用&quot;&gt;&lt;a href=&quot;#Redis安装和使用&quot; class=&quot;headerlink&quot; title=&quot;Redis安装和使用&quot;&gt;&lt;/a&gt;Redis安装和使用&lt;/h3&gt;&lt;h4 id=&quot;Window-下安装&quot;&gt;&lt;a href=&quot;#Window-下安装&quot;
      
    
    </summary>
    
      <category term="Redis" scheme="http://gavinliu4011.github.io/categories/Redis/"/>
    
    
      <category term="Redis" scheme="http://gavinliu4011.github.io/tags/Redis/"/>
    
  </entry>
  
</feed>
