<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>gavinliu&#39;s blog</title>
  
  <subtitle>刘泰丞的个人博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://gavinliu4011.github.io/"/>
  <updated>2018-03-22T15:26:23.780Z</updated>
  <id>http://gavinliu4011.github.io/</id>
  
  <author>
    <name>GavinLiu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Python版RabbitMQ消息队列之RPC（六）</title>
    <link href="http://gavinliu4011.github.io/post/8d587096.html"/>
    <id>http://gavinliu4011.github.io/post/8d587096.html</id>
    <published>2018-03-22T23:26:15.000Z</published>
    <updated>2018-03-22T15:26:23.780Z</updated>
    
    <content type="html"><![CDATA[<h2 id="远程过程调用（RPC）"><a href="#远程过程调用（RPC）" class="headerlink" title="远程过程调用（RPC）"></a>远程过程调用（RPC）</h2><p>在第二篇教程中我们介绍了如何使用工作队列（work queue）在多个工作者（woker）中间分发耗时的任务。</p><p>可是如果我们需要将一个函数运行在远程计算机上并且等待从那儿获取结果时，该怎么办呢？这就是另外的故事了。这种模式通常被称为远程过程调用（Remote Procedure Call）或者RPC。</p><p>这篇教程中，我们会使用RabbitMQ来构建一个RPC系统：包含一个客户端和一个RPC服务器。现在的情况是，我们没有一个值得被分发的足够耗时的任务，所以接下来，我们会创建一个模拟RPC服务来返回斐波那契数列。</p><h3 id="客户端接口"><a href="#客户端接口" class="headerlink" title="客户端接口"></a>客户端接口</h3><p>为了展示RPC服务如何使用，我们创建了一个简单的客户端类。它会暴露出一个名为“call”的方法用来发送一个RPC请求，并且在收到回应前保持阻塞。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fibonacci_rpc = FibonacciRpcClient()</span><br><span class="line">result = fibonacci_rpc.call(4)</span><br><span class="line">print(&quot;fib(4) is %r&quot; % (result,))</span><br></pre></td></tr></table></figure><blockquote><h4 id="关于RPC的注意事项："><a href="#关于RPC的注意事项：" class="headerlink" title="关于RPC的注意事项："></a>关于RPC的注意事项：</h4><p>尽管RPC在计算领域是一个常用模式，但它也经常被诟病。当一个问题被抛出的时候，程序员往往意识不到这到底是由本地调用还是由较慢的RPC调用引起的。同样的困惑还来自于系统的不可预测性和给调试工作带来的不必要的复杂性。跟软件精简不同的是，滥用RPC会导致不可维护的<a href="http://zh.wikipedia.org/wiki/%E9%9D%A2%E6%9D%A1%E5%BC%8F%E4%BB%A3%E7%A0%81" target="_blank" rel="noopener">面条代码</a>.</p><p>考虑到这一点，牢记以下建议：</p><p>确保能够明确的搞清楚哪个函数是本地调用的，哪个函数是远程调用的。给你的系统编写文档。保持各个组件间的依赖明确。处理错误案例。明了客户端改如何处理RPC服务器的宕机和长时间无响应情况。</p><p>当对避免使用RPC有疑问的时候。如果可以的话，你应该尽量使用异步管道来代替RPC类的阻塞。结果被异步地推送到下一个计算场景。</p></blockquote><h3 id="回调队列"><a href="#回调队列" class="headerlink" title="回调队列"></a>回调队列</h3><p>一般来说通过RabbitMQ来实现RPC是很容易的。一个客户端发送请求信息，服务器端将其应用到一个回复信息中。为了接收到回复信息，客户端需要在发送请求的时候同时发送一个回调队列（callback queue）的地址。我们试试看：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">result = channel.queue_declare(exclusive=True)</span><br><span class="line">callback_queue = result.method.queue</span><br><span class="line"></span><br><span class="line">channel.basic_publish(exchange=&apos;&apos;,</span><br><span class="line">                      routing_key=&apos;rpc_queue&apos;,</span><br><span class="line">                      properties=pika.BasicProperties(</span><br><span class="line">                            reply_to = callback_queue,</span><br><span class="line">                            ),</span><br><span class="line">                      body=request)</span><br><span class="line"></span><br><span class="line"># ... and some code to read a response message from the callback_queue ...</span><br></pre></td></tr></table></figure><blockquote><h4 id="消息属性"><a href="#消息属性" class="headerlink" title="消息属性"></a>消息属性</h4><p>AMQP协议给消息预定义了一系列的14个属性。大多数属性很少会用到，除了以下几个：</p><ul><li>delivery_mode（投递模式）：将消息标记为持久的（值为2）或暂存的（除了2之外的其他任何值）。第二篇教程里接触过这个属性，记得吧？</li><li>content_type（内容类型）:用来描述编码的mime-type。例如在实际使用中常常使用application/json来描述JOSN编码类型。</li><li>reply_to（回复目标）：通常用来命名回调队列。</li><li>correlation_id（关联标识）：用来将RPC的响应和请求关联起来。</li></ul></blockquote><h3 id="关联标识"><a href="#关联标识" class="headerlink" title="关联标识"></a>关联标识</h3><p>上边介绍的方法中，我们建议给每一个RPC请求新建一个回调队列。这不是一个高效的做法，幸好这儿有一个更好的办法 —— 我们可以为每个客户端只建立一个独立的回调队列。</p><p>这就带来一个新问题，当此队列接收到一个响应的时候它无法辨别出这个响应是属于哪个请求的。<strong>correlation_id</strong> 就是为了解决这个问题而来的。我们给每个请求设置一个独一无二的值。稍后，当我们从回调队列中接收到一个消息的时候，我们就可以查看这条属性从而将响应和请求匹配起来。如果我们接手到的消息的correlation_id是未知的，那就直接销毁掉它，因为它不属于我们的任何一条请求。</p><p>你也许会问，为什么我们接收到未知消息的时候不抛出一个错误，而是要将它忽略掉？这是为了解决服务器端有可能发生的竞争情况。尽管可能性不大，但RPC服务器还是有可能在已将应答发送给我们但还未将确认消息发送给请求的情况下死掉。如果这种情况发生，RPC在重启后会重新处理请求。这就是为什么我们必须在客户端优雅的处理重复响应，同时RPC也需要尽可能保持幂等性。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><img src="http://www.rabbitmq.com/img/tutorials/python-six.png" alt="img"></p><p>我们的RPC如此工作:</p><ul><li>当客户端启动的时候，它创建一个匿名独享的回调队列。</li><li>在RPC请求中，客户端发送带有两个属性的消息：一个是设置回调队列的 <em>reply_to</em> 属性，另一个是设置唯一值的 <em>correlation_id</em> 属性。</li><li>将请求发送到一个 <em>rpc_queue</em> 队列中。</li><li>RPC工作者（又名：服务器）等待请求发送到这个队列中来。当请求出现的时候，它执行他的工作并且将带有执行结果的消息发送给reply_to字段指定的队列。</li><li>客户端等待回调队列里的数据。当有消息出现的时候，它会检查correlation_id属性。如果此属性的值与请求匹配，将它返回给应用。</li></ul><h2 id="整合到一起"><a href="#整合到一起" class="headerlink" title="整合到一起"></a>整合到一起</h2><p>rpc_server.py代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line">import pika</span><br><span class="line"></span><br><span class="line">connection = pika.BlockingConnection(pika.ConnectionParameters(</span><br><span class="line">        host=&apos;localhost&apos;))</span><br><span class="line"></span><br><span class="line">channel = connection.channel()</span><br><span class="line"></span><br><span class="line">channel.queue_declare(queue=&apos;rpc_queue&apos;)</span><br><span class="line"></span><br><span class="line">def fib(n):</span><br><span class="line">    if n == 0:</span><br><span class="line">        return 0</span><br><span class="line">    elif n == 1:</span><br><span class="line">        return 1</span><br><span class="line">    else:</span><br><span class="line">        return fib(n-1) + fib(n-2)</span><br><span class="line"></span><br><span class="line">def on_request(ch, method, props, body):</span><br><span class="line">    n = int(body)</span><br><span class="line"></span><br><span class="line">    print(&quot; [.] fib(%s)&quot;  % (n,))</span><br><span class="line">    response = fib(n)</span><br><span class="line"></span><br><span class="line">    ch.basic_publish(exchange=&apos;&apos;,</span><br><span class="line">                     routing_key=props.reply_to,</span><br><span class="line">                     properties=pika.BasicProperties(correlation_id = \</span><br><span class="line">                                                     props.correlation_id),</span><br><span class="line">                     body=str(response))</span><br><span class="line">    ch.basic_ack(delivery_tag = method.delivery_tag)</span><br><span class="line"></span><br><span class="line">channel.basic_qos(prefetch_count=1)</span><br><span class="line">channel.basic_consume(on_request, queue=&apos;rpc_queue&apos;)</span><br><span class="line"></span><br><span class="line">print(&quot; [x] Awaiting RPC requests&quot;)</span><br><span class="line">channel.start_consuming()</span><br></pre></td></tr></table></figure><p>服务器端代码相当简单：</p><ul><li>（4）像往常一样，我们建立连接，声明队列</li><li>（11）我们声明我们的fibonacci函数，它假设只有合法的正整数当作输入。（别指望这个函数能处理很大的数值，函数递归你们都懂得…）</li><li>（19）我们为 basic_consume 声明了一个回调函数，这是RPC服务器端的核心。它执行实际的操作并且作出响应。</li><li>（32）或许我们希望能在服务器上多开几个线程。为了能将负载平均地分摊到多个服务器，我们需要将 prefetch_count 设置好。</li></ul><p>rpc_client.py 代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line">import pika</span><br><span class="line">import uuid</span><br><span class="line"></span><br><span class="line">class FibonacciRpcClient(object):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.connection = pika.BlockingConnection(pika.ConnectionParameters(</span><br><span class="line">                host=&apos;localhost&apos;))</span><br><span class="line"></span><br><span class="line">        self.channel = self.connection.channel()</span><br><span class="line"></span><br><span class="line">        result = self.channel.queue_declare(exclusive=True)</span><br><span class="line">        self.callback_queue = result.method.queue</span><br><span class="line"></span><br><span class="line">        self.channel.basic_consume(self.on_response, no_ack=True,</span><br><span class="line">                                   queue=self.callback_queue)</span><br><span class="line"></span><br><span class="line">    def on_response(self, ch, method, props, body):</span><br><span class="line">        if self.corr_id == props.correlation_id:</span><br><span class="line">            self.response = body</span><br><span class="line"></span><br><span class="line">    def call(self, n):</span><br><span class="line">        self.response = None</span><br><span class="line">        self.corr_id = str(uuid.uuid4())</span><br><span class="line">        self.channel.basic_publish(exchange=&apos;&apos;,</span><br><span class="line">                                   routing_key=&apos;rpc_queue&apos;,</span><br><span class="line">                                   properties=pika.BasicProperties(</span><br><span class="line">                                         reply_to = self.callback_queue,</span><br><span class="line">                                         correlation_id = self.corr_id,</span><br><span class="line">                                         ),</span><br><span class="line">                                   body=str(n))</span><br><span class="line">        while self.response is None:</span><br><span class="line">            self.connection.process_data_events()</span><br><span class="line">        return int(self.response)</span><br><span class="line"></span><br><span class="line">fibonacci_rpc = FibonacciRpcClient()</span><br><span class="line"></span><br><span class="line">print(&quot; [x] Requesting fib(30)&quot;)</span><br><span class="line">response = fibonacci_rpc.call(30)</span><br><span class="line">print(&quot; [.] Got %r&quot; % (response,))</span><br></pre></td></tr></table></figure><p>客户端代码稍微有点难懂：</p><ul><li>（7）建立连接、通道并且为回复（replies）声明独享的回调队列。</li><li>（16）我们订阅这个回调队列，以便接收RPC的响应。</li><li>（18）“on_response”回调函数对每一个响应执行一个非常简单的操作，检查每一个响应消息的correlation_id属性是否与我们期待的一致，如果一致，将响应结果赋给self.response，然后跳出consuming循环。</li><li>（23）接下来，我们定义我们的主要方法 call 方法。它执行真正的RPC请求。</li><li>（24）在这个方法中，首先我们生成一个唯一的 correlation_id 值并且保存起来，’on_response’回调函数会用它来获取符合要求的响应。</li><li>（25）接下来，我们将带有 reply_to 和 correlation_id 属性的消息发布出去。</li><li>（32）现在我们可以坐下来，等待正确的响应到来。</li><li>（33）最后，我们将响应返回给用户。</li></ul><p>我们的RPC服务已经准备就绪了，现在启动服务器端：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ python rpc_server.py</span><br><span class="line"> [x] Awaiting RPC requests</span><br></pre></td></tr></table></figure><p>运行客户端，请求一个fibonacci队列。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ python rpc_client.py</span><br><span class="line"> [x] Requesting fib(30)</span><br></pre></td></tr></table></figure><p>此处呈现的设计并不是实现RPC服务的唯一方式，但是他有一些重要的优势：</p><ul><li>如果RPC服务器运行的过慢的时候，你可以通过运行另外一个服务器端轻松扩展它。试试在控制台中运行第二个 rpc_server.py 。</li><li>在客户端，RPC请求只发送或接收一条消息。不需要像 queue_declare 这样的异步调用。所以RPC客户端的单个请求只需要一个网络往返。</li></ul><p>我们的代码依旧非常简单，而且没有试图去解决一些复杂（但是重要）的问题，如：</p><ul><li>当没有服务器运行时，客户端如何作出反映。</li><li>客户端是否需要实现类似RPC超时的东西。</li><li>如果服务器发生故障，并且抛出异常，应该被转发到客户端吗？</li><li>在处理前，防止混入无效的信息（例如检查边界）</li></ul><blockquote><p>如果你想做一些实验，你会发现<a href="http://www.rabbitmq.com/plugins.html" target="_blank" rel="noopener">rabbitmq-management plugin</a>在观测队列方面是很有用处的。</p></blockquote><p>（完整的<a href="https://github.com/rabbitmq/rabbitmq-tutorials/blob/master/python/rpc_client.py" target="_blank" rel="noopener">rpc_client.py</a> 和 <a href="https://github.com/rabbitmq/rabbitmq-tutorials/blob/master/python/rpc_server.py" target="_blank" rel="noopener">rpc_server.py</a>代码)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;远程过程调用（RPC）&quot;&gt;&lt;a href=&quot;#远程过程调用（RPC）&quot; class=&quot;headerlink&quot; title=&quot;远程过程调用（RPC）&quot;&gt;&lt;/a&gt;远程过程调用（RPC）&lt;/h2&gt;&lt;p&gt;在第二篇教程中我们介绍了如何使用工作队列（work queue）在多
      
    
    </summary>
    
      <category term="RabbitMQ" scheme="http://gavinliu4011.github.io/categories/RabbitMQ/"/>
    
    
      <category term="Python" scheme="http://gavinliu4011.github.io/tags/Python/"/>
    
      <category term="RabbitMQ" scheme="http://gavinliu4011.github.io/tags/RabbitMQ/"/>
    
      <category term="消息队列" scheme="http://gavinliu4011.github.io/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>Python版RabbitMQ消息队列之主题交换机（五）</title>
    <link href="http://gavinliu4011.github.io/post/3a0f7196.html"/>
    <id>http://gavinliu4011.github.io/post/3a0f7196.html</id>
    <published>2018-03-21T13:47:52.000Z</published>
    <updated>2018-03-21T05:48:01.399Z</updated>
    
    <content type="html"><![CDATA[<h2 id="为什么需要主题交换机？"><a href="#为什么需要主题交换机？" class="headerlink" title="为什么需要主题交换机？"></a>为什么需要主题交换机？</h2><p>上一篇教程里，我们改进了我们的日志系统。我们使用直连交换机替代了扇型交换机，从只能盲目的广播消息改进为有可能选择性的接收日志。</p><p>尽管直连交换机能够改善我们的系统，但是它也有它的限制 —— 没办法基于多个标准执行路由操作。</p><p>在我们的日志系统中，我们不只希望订阅基于严重程度的日志，同时还希望订阅基于发送来源的日志。Unix工具<a href="http://en.wikipedia.org/wiki/Syslog" target="_blank" rel="noopener">syslog</a>就是同时基于严重程度-severity (info/warn/crit…) 和 设备-facility (auth/cron/kern…)来路由日志的。</p><p>如果这样的话，将会给予我们非常大的灵活性，我们既可以监听来源于“cron”的严重程度为“critical errors”的日志，也可以监听来源于“kern”的所有日志。</p><p>为了实现这个目的，接下来我们学习如何使用另一种更复杂的交换机 —— 主题交换机。</p><h2 id="主题交换机"><a href="#主题交换机" class="headerlink" title="主题交换机"></a>主题交换机</h2><p>发送到主题交换机（topic exchange）的消息不可以携带随意什么样子的路由键（routing_key），它的路由键必须是一个由<code>.</code>分隔开的词语列表。这些单词随便是什么都可以，但是最好是跟携带它们的消息有关系的词汇。以下是几个推荐的例子：”stock.usd.nyse”, “nyse.vmw”, “quick.orange.rabbit”。词语的个数可以随意，但是不要超过255字节。</p><p>绑定键也必须拥有同样的格式。主题交换机背后的逻辑跟直连交换机很相似 —— 一个携带着特定路由键的消息会被主题交换机投递给绑定键与之想匹配的队列。但是它的绑定键和路由键有两个特殊应用方式：</p><ul><li><code>*</code> (星号) 用来表示一个单词.</li><li><code>#</code> (井号) 用来表示任意数量（零个或多个）单词。</li></ul><p>下边用图说明：<br><img src="http://www.rabbitmq.com/img/tutorials/python-five.png" alt="None"></p><p>这个例子里，我们发送的所有消息都是用来描述小动物的。发送的消息所携带的路由键是由三个单词所组成的，这三个单词被两个<code>.</code>分割开。路由键里的第一个单词描述的是动物的手脚的利索程度，第二个单词是动物的颜色，第三个是动物的种类。所以它看起来是这样的： <code>&lt;celerity&gt;.&lt;colour&gt;.&lt;species&gt;</code>。</p><p>我们创建了三个绑定：Q1的绑定键为 <code>*.orange.*</code>，Q2的绑定键为 <code>*.*.rabbit</code> 和 <code>lazy.#</code> 。</p><p>这三个绑定键被可以总结为：</p><ul><li>Q1 对<em>所有的桔黄色动物</em>都感兴趣。</li><li>Q2 则是对<em>所有的兔子</em>和<em>所有懒惰的动物</em>感兴趣。</li></ul><p>一个携带有 <code>quick.orange.rabbit</code> 的消息将会被分别投递给这两个队列。携带着 <code>lazy.orange.elephant</code> 的消息同样也会给两个队列都投递过去。另一方面携带有 <code>quick.orange.fox</code> 的消息会投递给第一个队列，携带有 <code>lazy.brown.fox</code> 的消息会投递给第二个队列。携带有 <code>lazy.pink.rabbit</code> 的消息只会被投递给第二个队列一次，即使它同时匹配第二个队列的两个绑定。携带着 <code>quick.brown.fox</code> 的消息不会投递给任何一个队列。</p><p>如果我们违反约定，发送了一个携带有一个单词或者四个单词（<code>&quot;orange&quot;</code> or <code>&quot;quick.orange.male.rabbit&quot;</code>）的消息时，发送的消息不会投递给任何一个队列，而且会丢失掉。</p><p>但是另一方面，即使 <code>&quot;lazy.orange.male.rabbit&quot;</code> 有四个单词，他还是会匹配最后一个绑定，并且被投递到第二个队列中。</p><blockquote><h4 id="主题交换机-1"><a href="#主题交换机-1" class="headerlink" title="主题交换机"></a>主题交换机</h4><p>主题交换机是很强大的，它可以表现出跟其他交换机类似的行为</p><p>当一个队列的绑定键为 “#”（井号） 的时候，这个队列将会无视消息的路由键，接收所有的消息。</p><p>当 <code>*</code> (星号) 和 <code>#</code> (井号) 这两个特殊字符都未在绑定键中出现的时候，此时主题交换机就拥有的直连交换机的行为。</p></blockquote><h2 id="组合在一起"><a href="#组合在一起" class="headerlink" title="组合在一起"></a>组合在一起</h2><p>接下来我们会将主题交换机应用到我们的日志系统中。在开始工作前，我们假设日志的路由键由两个单词组成，路由键看起来是这样的：<code>&lt;facility&gt;.&lt;severity&gt;</code></p><p>代码跟上一篇教程差不多。</p><p>emit_log_topic.py的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line">import pika</span><br><span class="line">import sys</span><br><span class="line"></span><br><span class="line">connection = pika.BlockingConnection(pika.ConnectionParameters(</span><br><span class="line">        host=&apos;localhost&apos;))</span><br><span class="line">channel = connection.channel()</span><br><span class="line"></span><br><span class="line">channel.exchange_declare(exchange=&apos;topic_logs&apos;,</span><br><span class="line">                         type=&apos;topic&apos;)</span><br><span class="line"></span><br><span class="line">routing_key = sys.argv[1] if len(sys.argv) &gt; 1 else &apos;anonymous.info&apos;</span><br><span class="line">message = &apos; &apos;.join(sys.argv[2:]) or &apos;Hello World!&apos;</span><br><span class="line">channel.basic_publish(exchange=&apos;topic_logs&apos;,</span><br><span class="line">                      routing_key=routing_key,</span><br><span class="line">                      body=message)</span><br><span class="line">print(&quot; [x] Sent %r:%r&quot; % (routing_key, message))</span><br><span class="line">connection.close()</span><br></pre></td></tr></table></figure><p>receive_logs_topic.py的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line">import pika</span><br><span class="line">import sys</span><br><span class="line"></span><br><span class="line">connection = pika.BlockingConnection(pika.ConnectionParameters(</span><br><span class="line">        host=&apos;localhost&apos;))</span><br><span class="line">channel = connection.channel()</span><br><span class="line"></span><br><span class="line">channel.exchange_declare(exchange=&apos;topic_logs&apos;,</span><br><span class="line">                         type=&apos;topic&apos;)</span><br><span class="line"></span><br><span class="line">result = channel.queue_declare(exclusive=True)</span><br><span class="line">queue_name = result.method.queue</span><br><span class="line"></span><br><span class="line">binding_keys = sys.argv[1:]</span><br><span class="line">if not binding_keys:</span><br><span class="line">    sys.stderr.write(&quot;Usage: %s [info] [warning] [error]\n&quot; % sys.argv[0]) #定义了三种接收消息方式info,warning,error</span><br><span class="line">    sys.exit(1)</span><br><span class="line"></span><br><span class="line">for binding_key in binding_keys:</span><br><span class="line">    channel.queue_bind(exchange=&apos;topic_logs&apos;,</span><br><span class="line">                       queue=queue_name,</span><br><span class="line">                       routing_key=binding_key)</span><br><span class="line"></span><br><span class="line">print(&apos; [*] Waiting for logs. To exit press CTRL+C&apos;)</span><br><span class="line"></span><br><span class="line">def callback(ch, method, properties, body):</span><br><span class="line">    print(&quot; [x] %r:%r&quot; % (method.routing_key, body,))</span><br><span class="line"></span><br><span class="line">channel.basic_consume(callback,</span><br><span class="line">                      queue=queue_name,</span><br><span class="line">                      no_ack=True)</span><br><span class="line"></span><br><span class="line">channel.start_consuming()</span><br></pre></td></tr></table></figure><p>执行下边命令 接收所有日志：<br><code>python receive_logs_topic.py &quot;#&quot;</code></p><p>执行下边命令 接收来自”kern“设备的日志：<br><code>python receive_logs_topic.py &quot;kern.*&quot;</code></p><p>执行下边命令 只接收严重程度为”critical“的日志：<br><code>python receive_logs_topic.py &quot;*.critical&quot;</code></p><p>执行下边命令 建立多个绑定：<br><code>python receive_logs_topic.py &quot;kern.*&quot; &quot;*.critical&quot;</code></p><p>执行下边命令 发送路由键为 “kern.critical” 的日志：<br><code>python emit_log_topic.py &quot;kern.critical&quot; &quot;A critical kernel error&quot;</code></p><p>执行上边命令试试看效果吧。另外，上边代码不会对路由键和绑定键做任何假设，所以你可以在命令中使用超过两个路由键参数。</p><h3 id="如果你现在还没被搞晕，想想下边问题"><a href="#如果你现在还没被搞晕，想想下边问题" class="headerlink" title="如果你现在还没被搞晕，想想下边问题:"></a>如果你现在还没被搞晕，想想下边问题:</h3><ul><li>绑定键为 <code>*</code> 的队列会取到一个路由键为空的消息吗？</li><li>绑定键为 <code>#.*</code> 的队列会获取到一个名为<code>..</code>的路由键的消息吗？它会取到一个路由键为单个单词的消息吗？</li><li><code>a.*.#</code> 和 <code>a.#</code>的区别在哪儿？</li></ul><p>（完整代码参见<a href="https://github.com/rabbitmq/rabbitmq-tutorials/blob/master/python/emit_log_topic.py" target="_blank" rel="noopener">emit_logs_topic.py</a> and <a href="https://github.com/rabbitmq/rabbitmq-tutorials/blob/master/python/receive_logs_topic.py" target="_blank" rel="noopener">receive_logs_topic.py</a>)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;为什么需要主题交换机？&quot;&gt;&lt;a href=&quot;#为什么需要主题交换机？&quot; class=&quot;headerlink&quot; title=&quot;为什么需要主题交换机？&quot;&gt;&lt;/a&gt;为什么需要主题交换机？&lt;/h2&gt;&lt;p&gt;上一篇教程里，我们改进了我们的日志系统。我们使用直连交换机替代了扇型
      
    
    </summary>
    
      <category term="RabbitMQ" scheme="http://gavinliu4011.github.io/categories/RabbitMQ/"/>
    
    
      <category term="Python" scheme="http://gavinliu4011.github.io/tags/Python/"/>
    
      <category term="RabbitMQ" scheme="http://gavinliu4011.github.io/tags/RabbitMQ/"/>
    
      <category term="消息队列" scheme="http://gavinliu4011.github.io/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>Python版RabbitMQ消息队列之路由（四）</title>
    <link href="http://gavinliu4011.github.io/post/9d637a8e.html"/>
    <id>http://gavinliu4011.github.io/post/9d637a8e.html</id>
    <published>2018-03-20T22:50:24.000Z</published>
    <updated>2018-03-20T14:50:34.339Z</updated>
    
    <content type="html"><![CDATA[<h2 id="路由-Routing"><a href="#路由-Routing" class="headerlink" title="路由(Routing)"></a>路由(Routing)</h2><p>在前面的教程中，我们实现了一个简单的日志系统。可以把日志消息广播给多个接收者。</p><p>本篇教程中我们打算新增一个功能 —— 使得它能够只订阅消息的一个字集。例如，我们只需要把严重的错误日志信息写入日志文件（存储到磁盘），但同时仍然把所有的日志信息输出到控制台中</p><h2 id="绑定（Bindings）"><a href="#绑定（Bindings）" class="headerlink" title="绑定（Bindings）"></a>绑定（Bindings）</h2><p>前面的例子，我们已经创建过绑定（bindings），代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.queue_bind(exchange=exchange_name, queue=queue_name)</span><br></pre></td></tr></table></figure><p>绑定（binding）是指交换机（exchange）和队列（queue）的关系。可以简单理解为：这个队列（queue）对这个交换机（exchange）的消息感兴趣。</p><p>绑定的时候可以带上一个额外的routing_key参数。为了避免与basic_publish的参数混淆，我们把它叫做绑定键（binding key）。以下是如何创建一个带绑定键的绑定。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.queue_bind(exchange=exchange_name, queue=queue_name, routing_key=&apos;black&apos;)</span><br></pre></td></tr></table></figure><p>绑定键的意义取决于交换机（exchange）的类型。我们之前使用过的扇型交换机（fanout exchanges）会忽略这个值。</p><h2 id="直连交换机（Direct-exchange）"><a href="#直连交换机（Direct-exchange）" class="headerlink" title="直连交换机（Direct exchange）"></a>直连交换机（Direct exchange）</h2><p>我们的日志系统广播所有的消息给所有的消费者（consumers）。我们打算扩展它，使其基于日志的严重程度进行消息过滤。例如我们也许只是希望将比较严重的错误（error）日志写入磁盘，以免在警告（warning）或者信息（info）日志上浪费磁盘空间。</p><p>我们使用的扇型交换机（fanout exchange）没有足够的灵活性 —— 它能做的仅仅是广播。</p><p>我们将会使用直连交换机（direct exchange）来代替。路由的算法很简单 —— 交换机将会对绑定键（binding key）和路由键（routing key）进行精确匹配，从而确定消息该分发到哪个队列。</p><p>下图能够很好的描述这个场景：</p><p><img src="http://www.rabbitmq.com/img/tutorials/direct-exchange.png" alt="img"></p><p>在这个场景中，我们可以看到直连交换机 X和两个队列进行了绑定。第一个队列使用orange作为绑定键，第二个队列有两个绑定，一个使用black作为绑定键，另外一个使用green。</p><p>这样以来，当路由键为orange的消息发布到交换机，就会被路由到队列Q1。路由键为black或者green的消息就会路由到Q2。其他的所有消息都将会被丢弃。</p><h2 id="多个绑定（Multiple-bindings）"><a href="#多个绑定（Multiple-bindings）" class="headerlink" title="多个绑定（Multiple bindings）"></a>多个绑定（Multiple bindings）</h2><p><img src="http://www.rabbitmq.com/img/tutorials/direct-exchange-multiple.png" alt="img"></p><p>多个队列使用相同的绑定键是合法的。这个例子中，我们可以添加一个X和Q1之间的绑定，使用black绑定键。这样一来，直连交换机就和扇型交换机的行为一样，会将消息广播到所有匹配的队列。带有black路由键的消息会同时发送到Q1和Q2。</p><h2 id="发送日志"><a href="#发送日志" class="headerlink" title="发送日志"></a>发送日志</h2><p>我们将会发送消息到一个直连交换机，把日志级别作为路由键。这样接收日志的脚本就可以根据严重级别来选择它想要处理的日志。我们先看看发送日志。</p><p>我们需要创建一个交换机（exchange）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.exchange_declare(exchange=&apos;direct_logs&apos;, type=&apos;direct&apos;)</span><br></pre></td></tr></table></figure><p>然后我们发送一则消息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.basic_publish(exchange=&apos;direct_logs&apos;, routing_key=severity, body=message)</span><br></pre></td></tr></table></figure><p>我们先假设“severity”的值是info、warning、error中的一个。</p><h2 id="订阅"><a href="#订阅" class="headerlink" title="订阅"></a>订阅</h2><p>处理接收消息的方式和之前差不多，只有一个例外，我们将会为我们感兴趣的每个严重级别分别创建一个新的绑定。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">result = channel.queue_declare(exclusive=True)</span><br><span class="line">queue_name = result.method.queue</span><br><span class="line"></span><br><span class="line">for severity in severities:</span><br><span class="line">    channel.queue_bind(exchange=&apos;direct_logs&apos;, queue=queue_name, routing_key=severity)</span><br></pre></td></tr></table></figure><h2 id="代码整合"><a href="#代码整合" class="headerlink" title="代码整合"></a>代码整合</h2><p><img src="http://www.rabbitmq.com/img/tutorials/python-four.png" alt="img"></p><p>emit_log_direct.py的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line">import pika</span><br><span class="line">import sys</span><br><span class="line"></span><br><span class="line">connection = pika.BlockingConnection(pika.ConnectionParameters(host=&apos;localhost&apos;))</span><br><span class="line">channel = connection.channel()</span><br><span class="line"></span><br><span class="line">channel.exchange_declare(exchange=&apos;direct_logs&apos;, type=&apos;direct&apos;)</span><br><span class="line"></span><br><span class="line">severity = sys.argv[1] if len(sys.argv) &gt; 1 else &apos;info&apos;</span><br><span class="line">message = &apos; &apos;.join(sys.argv[2:]) or &apos;Hello World!&apos;</span><br><span class="line">channel.basic_publish(exchange=&apos;direct_logs&apos;, routing_key=severity, body=message)</span><br><span class="line">print(&quot; [x] Sent %r:%r&quot; % (severity, message))</span><br><span class="line">connection.close()</span><br></pre></td></tr></table></figure><p>receive_logs_direct.py的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line">import pika</span><br><span class="line">import sys</span><br><span class="line"></span><br><span class="line">connection = pika.BlockingConnection(pika.ConnectionParameters(host=&apos;localhost&apos;))</span><br><span class="line">channel = connection.channel()</span><br><span class="line"></span><br><span class="line">channel.exchange_declare(exchange=&apos;direct_logs&apos;, type=&apos;direct&apos;)</span><br><span class="line"></span><br><span class="line">result = channel.queue_declare(exclusive=True)</span><br><span class="line">queue_name = result.method.queue</span><br><span class="line"></span><br><span class="line">severities = sys.argv[1:]</span><br><span class="line">if not severities:</span><br><span class="line">    sys.stderr.write(&quot;Usage: %s [info] [warning] [error]\n&quot; % sys.argv[0]) #定义了三种接收消息方式info,warning,error</span><br><span class="line">    sys.exit(1)</span><br><span class="line"></span><br><span class="line">for severity in severities:</span><br><span class="line">    channel.queue_bind(exchange=&apos;direct_logs&apos;,</span><br><span class="line">                       queue=queue_name,</span><br><span class="line">                       routing_key=severity)</span><br><span class="line"></span><br><span class="line">print(&apos; [*] Waiting for logs. To exit press CTRL+C&apos;)</span><br><span class="line"></span><br><span class="line">def callback(ch, method, properties, body):</span><br><span class="line">    print(&quot; [x] %r:%r&quot; % (method.routing_key, body))</span><br><span class="line"></span><br><span class="line">channel.basic_consume(callback,</span><br><span class="line">                      queue=queue_name,</span><br><span class="line">                      no_ack=True)</span><br><span class="line"></span><br><span class="line">channel.start_consuming()</span><br></pre></td></tr></table></figure><p>如果你希望只是保存warning和error级别的日志到磁盘，只需要打开控制台并输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ python receive_logs_direct.py warning error &gt; logs_from_rabbit.log</span><br></pre></td></tr></table></figure><p>如果你希望所有的日志信息都输出到屏幕中，打开一个新的终端，然后输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ python receive_logs_direct.py info warning error</span><br><span class="line"> [*] Waiting for logs. To exit press CTRL+C</span><br></pre></td></tr></table></figure><p>如果要触发一个error级别的日志，只需要输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ python emit_log_direct.py error &quot;Run. Run. Or it will explode.&quot;</span><br><span class="line"> [x] Sent &apos;error&apos;:&apos;Run. Run. Or it will explode.&apos;</span><br></pre></td></tr></table></figure><p>这里是完整的代码：(<a href="https://github.com/rabbitmq/rabbitmq-tutorials/blob/master/python/emit_log_direct.py" target="_blank" rel="noopener">emit_log_direct.py</a>和<a href="https://github.com/rabbitmq/rabbitmq-tutorials/blob/master/python/receive_logs_direct.py" target="_blank" rel="noopener">receive_logs_direct.py</a>)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;路由-Routing&quot;&gt;&lt;a href=&quot;#路由-Routing&quot; class=&quot;headerlink&quot; title=&quot;路由(Routing)&quot;&gt;&lt;/a&gt;路由(Routing)&lt;/h2&gt;&lt;p&gt;在前面的教程中，我们实现了一个简单的日志系统。可以把日志消息广播给多个接
      
    
    </summary>
    
      <category term="RabbitMQ" scheme="http://gavinliu4011.github.io/categories/RabbitMQ/"/>
    
    
      <category term="Python" scheme="http://gavinliu4011.github.io/tags/Python/"/>
    
      <category term="RabbitMQ" scheme="http://gavinliu4011.github.io/tags/RabbitMQ/"/>
    
      <category term="消息队列" scheme="http://gavinliu4011.github.io/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>Python版RabbitMQ消息队列之发布／订阅（三）</title>
    <link href="http://gavinliu4011.github.io/post/2092e5cc.html"/>
    <id>http://gavinliu4011.github.io/post/2092e5cc.html</id>
    <published>2018-03-19T22:34:51.000Z</published>
    <updated>2018-03-19T14:35:00.696Z</updated>
    
    <content type="html"><![CDATA[<h2 id="发布／订阅"><a href="#发布／订阅" class="headerlink" title="发布／订阅"></a>发布／订阅</h2><p>在上篇教程中，我们搭建了一个工作队列，每个任务只分发给一个工作者（worker）。在本篇教程中，我们要做的跟之前完全不一样 —— 分发一个消息给多个消费者（consumers）。这种模式被称为“发布／订阅”。</p><p>为了描述这种模式，我们将会构建一个简单的日志系统。它包括两个程序——第一个程序负责发送日志消息，第二个程序负责获取消息并输出内容。</p><p>在我们的这个日志系统中，所有正在运行的接收方程序都会接受消息。我们用其中一个接收者（receiver）把日志写入硬盘中，另外一个接受者（receiver）把日志输出到屏幕上。</p><p>最终，日志消息被广播给所有的接受者（receivers）。</p><h2 id="交换机（Exchanges）"><a href="#交换机（Exchanges）" class="headerlink" title="交换机（Exchanges）"></a>交换机（Exchanges）</h2><p>前面的教程中，我们发送消息到队列并从中取出消息。现在是时候介绍RabbitMQ中完整的消息模型了。</p><p>让我们简单的概括一下之前的教程：</p><ul><li>发布者（producer）是发布消息的应用程序。</li><li>队列（queue）用于消息存储的缓冲。</li><li>消费者（consumer）是接收消息的应用程序。</li></ul><p>RabbitMQ消息模型的核心理念是：发布者（producer）不会直接发送任何消息给队列。事实上，发布者（producer）甚至不知道消息是否已经被投递到队列。</p><p>发布者（producer）只需要把消息发送给一个交换机（exchange）。交换机非常简单，它一边从发布者方接收消息，一边把消息推送到队列。交换机必须知道如何处理它接收到的消息，是应该推送到指定的队列还是是多个队列，或者是直接忽略消息。这些规则是通过交换机类型（exchange type）来定义的。</p><p><img src="http://www.rabbitmq.com/img/tutorials/exchanges.png" alt="img"></p><p>有几个可供选择的交换机类型：直连交换机（direct）, 主题交换机（topic）, （头交换机）headers和 扇型交换机（fanout）。我们在这里主要说明最后一个 —— 扇型交换机（fanout）。先创建一个fanout类型的交换机，命名为logs：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.exchange_declare(exchange=&apos;logs&apos;, type=&apos;fanout&apos;)</span><br></pre></td></tr></table></figure><p>扇型交换机（fanout）很简单，你可能从名字上就能猜测出来，它把消息发送给它所知道的所有队列。这正是我们的日志系统所需要的。</p><blockquote><h4 id="交换器列表"><a href="#交换器列表" class="headerlink" title="交换器列表"></a>交换器列表</h4><p>rabbitmqctl能够列出服务器上所有的交换器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt; $ sudo rabbitmqctl list_exchanges</span><br><span class="line">&gt; Listing exchanges ...</span><br><span class="line">&gt; logs      fanout</span><br><span class="line">&gt; amq.direct      direct</span><br><span class="line">&gt; amq.topic       topic</span><br><span class="line">&gt; amq.fanout      fanout</span><br><span class="line">&gt; amq.headers     headers</span><br><span class="line">&gt; ...done.</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p>这个列表中有一些叫做amq.*的交换器。这些都是默认创建的，不过这时候你还不需要使用他们。</p><h4 id="匿名的交换器"><a href="#匿名的交换器" class="headerlink" title="匿名的交换器"></a>匿名的交换器</h4><p>前面的教程中我们对交换机一无所知，但仍然能够发送消息到队列中。因为我们使用了命名为空字符串(“”)默认的交换机。</p><p>回想我们之前是如何发布一则消息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; channel.basic_publish(exchange=&apos;&apos;, routing_key=&apos;hello&apos;, body=message)</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p>exchange参数就是交换机的名称。空字符串代表默认或者匿名交换机：消息将会根据指定的routing_key分发到指定的队列。</p></blockquote><p>现在，我们就可以发送消息到一个具名交换机了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.basic_publish(exchange=&apos;logs&apos;, routing_key=&apos;&apos;, body=message)</span><br></pre></td></tr></table></figure><h2 id="临时队列"><a href="#临时队列" class="headerlink" title="临时队列"></a>临时队列</h2><p>你还记得之前我们使用的队列名吗（ hello和task_queue）？给一个队列命名是很重要的——我们需要把工作者（workers）指向正确的队列。如果你打算在发布者（producers）和消费者（consumers）之间共享同队列的话，给队列命名是十分重要的。</p><p>但是这并不适用于我们的日志系统。我们打算接收所有的日志消息，而不仅仅是一小部分。我们关心的是最新的消息而不是旧的。为了解决这个问题，我们需要做两件事情。</p><p>首先，当我们连接上RabbitMQ的时候，我们需要一个全新的、空的队列。我们可以手动创建一个随机的队列名，或者让服务器为我们选择一个随机的队列名（推荐）。我们只需要在调用queue_declare方法的时候，不提供queue参数就可以了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result = channel.queue_declare()</span><br></pre></td></tr></table></figure><p>这时候我们可以通过result.method.queue获得已经生成的随机队列名。它可能是这样子的：amq.gen-U0srCoW8TsaXjNh73pnVAw==。</p><p>第二步，当与消费者（consumer）断开连接的时候，这个队列应当被立即删除。exclusive标识符即可达到此目的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result = channel.queue_declare(exclusive=True)</span><br></pre></td></tr></table></figure><h2 id="绑定（Bindings）"><a href="#绑定（Bindings）" class="headerlink" title="绑定（Bindings）"></a>绑定（Bindings）</h2><p><img src="http://www.rabbitmq.com/img/tutorials/bindings.png" alt="img"></p><p>我们已经创建了一个扇型交换机（fanout）和一个队列。现在我们需要告诉交换机如何发送消息给我们的队列。交换器和队列之间的联系我们称之为绑定（binding）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.queue_bind(exchange=&apos;logs&apos;, queue=result.method.queue)</span><br></pre></td></tr></table></figure><p>现在，logs交换机将会把消息添加到我们的队列中。</p><blockquote><h4 id="绑定（binding）列表"><a href="#绑定（binding）列表" class="headerlink" title="绑定（binding）列表"></a>绑定（binding）列表</h4><p>你可以使用<code>rabbitmqctl list_bindings</code> 列出所有现存的绑定。</p></blockquote><h2 id="代码整合"><a href="#代码整合" class="headerlink" title="代码整合"></a>代码整合</h2><p><img src="http://www.rabbitmq.com/img/tutorials/python-three-overall.png" alt="img"></p><p>发布日志消息的程序看起来和之前的没有太大区别。最重要的改变就是我们把消息发送给logs交换机而不是匿名交换机。在发送的时候我们需要提供routing_key参数，但是它的值会被扇型交换机（fanout exchange）忽略。以下是emit_log.py脚本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line">import pika</span><br><span class="line">import sys</span><br><span class="line"></span><br><span class="line">connection = pika.BlockingConnection(pika.ConnectionParameters(</span><br><span class="line">        host=&apos;localhost&apos;))</span><br><span class="line">channel = connection.channel()</span><br><span class="line"></span><br><span class="line">channel.exchange_declare(exchange=&apos;logs&apos;,</span><br><span class="line">                         type=&apos;fanout&apos;)</span><br><span class="line"></span><br><span class="line">message = &apos; &apos;.join(sys.argv[1:]) or &quot;info: Hello World!&quot;</span><br><span class="line">channel.basic_publish(exchange=&apos;logs&apos;,</span><br><span class="line">                      routing_key=&apos;&apos;,</span><br><span class="line">                      body=message)</span><br><span class="line">print(&quot; [x] Sent %r&quot; % (message,))</span><br><span class="line">connection.close()</span><br></pre></td></tr></table></figure><p>(<a href="http://github.com/rabbitmq/rabbitmq-tutorials/blob/master/python/emit_log.py" target="_blank" rel="noopener">emit_log.py</a> 源文件)</p><p>正如你看到的那样，在连接成功之后，我们声明了一个交换器，这一个是很重要的，因为不允许发布消息到不存在的交换器。</p><p>如果没有绑定队列到交换器，消息将会丢失。但这个没有所谓，如果没有消费者监听，那么消息就会被忽略。</p><p>receive_logs.py的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line">import pika</span><br><span class="line"></span><br><span class="line">connection = pika.BlockingConnection(pika.ConnectionParameters(</span><br><span class="line">        host=&apos;localhost&apos;))</span><br><span class="line">channel = connection.channel()</span><br><span class="line"></span><br><span class="line">channel.exchange_declare(exchange=&apos;logs&apos;,</span><br><span class="line">                         type=&apos;fanout&apos;)</span><br><span class="line"></span><br><span class="line">result = channel.queue_declare(exclusive=True)</span><br><span class="line">queue_name = result.method.queue</span><br><span class="line"></span><br><span class="line">channel.queue_bind(exchange=&apos;logs&apos;,</span><br><span class="line">                   queue=queue_name)</span><br><span class="line"></span><br><span class="line">print(&apos; [*] Waiting for logs. To exit press CTRL+C&apos;)</span><br><span class="line"></span><br><span class="line">def callback(ch, method, properties, body):</span><br><span class="line">    print(&quot; [x] %r&quot; % (body,))</span><br><span class="line"></span><br><span class="line">channel.basic_consume(callback,</span><br><span class="line">                      queue=queue_name,</span><br><span class="line">                      no_ack=True)</span><br><span class="line"></span><br><span class="line">channel.start_consuming()</span><br></pre></td></tr></table></figure><p>(<a href="http://github.com/rabbitmq/rabbitmq-tutorials/blob/master/python/receive_logs.py" target="_blank" rel="noopener">receive_logs.py</a> source)</p><p>这样我们就完成了。如果你想把日志保存到文件中，只需要打开控制台输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ python receive_logs.py &gt; logs_from_rabbit.log</span><br></pre></td></tr></table></figure><p>如果你想在屏幕中查看日志，那么打开一个新的终端然后运行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ python receive_logs.py</span><br></pre></td></tr></table></figure><p>当然还要发送日志：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ python emit_log.py</span><br></pre></td></tr></table></figure><p>使用<code>rabbitmqctl list_bindings</code>你可确认已经创建的队列绑定。你可以看到运行中的两个receive_logs.py程序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ sudo rabbitmqctl list_bindings</span><br><span class="line">Listing bindings ...</span><br><span class="line"> ...</span><br><span class="line">logs    amq.gen-TJWkez28YpImbWdRKMa8sg==                []</span><br><span class="line">logs    amq.gen-x0kymA4yPzAT6BoC/YP+zw==                []</span><br><span class="line">...done.</span><br></pre></td></tr></table></figure><p>显示结果很直观：logs交换器把数据发送给两个系统命名的队列。这就是我们所期望的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;发布／订阅&quot;&gt;&lt;a href=&quot;#发布／订阅&quot; class=&quot;headerlink&quot; title=&quot;发布／订阅&quot;&gt;&lt;/a&gt;发布／订阅&lt;/h2&gt;&lt;p&gt;在上篇教程中，我们搭建了一个工作队列，每个任务只分发给一个工作者（worker）。在本篇教程中，我们要做的跟之前完全
      
    
    </summary>
    
      <category term="RabbitMQ" scheme="http://gavinliu4011.github.io/categories/RabbitMQ/"/>
    
    
      <category term="Python" scheme="http://gavinliu4011.github.io/tags/Python/"/>
    
      <category term="RabbitMQ" scheme="http://gavinliu4011.github.io/tags/RabbitMQ/"/>
    
      <category term="消息队列" scheme="http://gavinliu4011.github.io/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>Python版RabbitMQ消息队列之工作队列（二）</title>
    <link href="http://gavinliu4011.github.io/post/2efe5f21.html"/>
    <id>http://gavinliu4011.github.io/post/2efe5f21.html</id>
    <published>2018-03-18T21:53:17.000Z</published>
    <updated>2018-03-18T13:53:29.712Z</updated>
    
    <content type="html"><![CDATA[<h2 id="工作队列"><a href="#工作队列" class="headerlink" title="工作队列"></a>工作队列</h2><p><img src="http://www.rabbitmq.com/img/tutorials/python-two.png" alt="img"></p><p>在第一篇教程中，我们已经写了一个从已知队列中发送和获取消息的程序。在这篇教程中，我们将创建一个工作队列（Work Queue），它会发送一些耗时的任务给多个工作者（Worker）。</p><p>工作队列（又称：任务队列——Task Queues）是为了避免等待一些占用大量资源、时间的操作。当我们把任务（Task）当作消息发送到队列中，一个运行在后台的工作者（worker）进程就会取出任务然后处理。当你运行多个工作者（workers），任务就会在它们之间共享。</p><p>这个概念在网络应用中是非常有用的，它可以在短暂的HTTP请求中处理一些复杂的任务。</p><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>之前的教程中，我们发送了一个包含“Hello World!”的字符串消息。现在，我们将发送一些字符串，把这些字符串当作复杂的任务。我们没有真实的例子，例如图片缩放、pdf文件转换。所以使用time.sleep()函数来模拟这种情况。我们在字符串中加上点号（.）来表示任务的复杂程度，一个点（.）将会耗时1秒钟。比如”Hello…”就会耗时3秒钟。</p><p>我们对之前教程的send.py做些简单的调整，以便可以发送随意的消息。这个程序会按照计划发送任务到我们的工作队列中。我们把它命名为new_task.py：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import sys</span><br><span class="line"></span><br><span class="line">message = &apos; &apos;.join(sys.argv[1:]) or &quot;Hello World!&quot;</span><br><span class="line">channel.basic_publish(exchange=&apos;&apos;,</span><br><span class="line">                      routing_key=&apos;hello&apos;,</span><br><span class="line">                      body=message)</span><br><span class="line">print(&quot; [x] Sent %r&quot; % (message,))</span><br></pre></td></tr></table></figure><p>我们的旧脚本（receive.py）同样需要做一些改动：它需要为消息体中每一个点号（.）模拟1秒钟的操作。它会从队列中获取消息并执行，我们把它命名为worker.py：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import time</span><br><span class="line"></span><br><span class="line">def callback(ch, method, properties, body):</span><br><span class="line">    print(&quot; [x] Received %r&quot; % (body,))</span><br><span class="line">    time.sleep( body.count(&apos;.&apos;) )</span><br><span class="line">    print(&quot; [x] Done&quot;)</span><br></pre></td></tr></table></figure><h2 id="循环调度"><a href="#循环调度" class="headerlink" title="循环调度:"></a>循环调度:</h2><p>使用工作队列的一个好处就是它能够并行的处理队列。如果堆积了很多任务，我们只需要添加更多的工作者（workers）就可以了，扩展很简单。</p><p>首先，我们先同时运行两个worker.py脚本，它们都会从队列中获取消息，到底是不是这样呢？我们看看。</p><p>你需要打开三个终端，两个用来运行worker.py脚本，这两个终端就是我们的两个消费者（consumers）—— C1 和 C2。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">shell1$ python worker.py</span><br><span class="line"> [*] Waiting for messages. To exit press CTRL+C</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">shell2$ python worker.py</span><br><span class="line"> [*] Waiting for messages. To exit press CTRL+C</span><br></pre></td></tr></table></figure><p>第三个终端，我们用来发布新任务。你可以发送一些消息给消费者（consumers）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">shell3$ python new_task.py First message.</span><br><span class="line">shell3$ python new_task.py Second message..</span><br><span class="line">shell3$ python new_task.py Third message...</span><br><span class="line">shell3$ python new_task.py Fourth message....</span><br><span class="line">shell3$ python new_task.py Fifth message.....</span><br></pre></td></tr></table></figure><p>看看到底发送了什么给我们的工作者（workers）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">shell1$ python worker.py</span><br><span class="line"> [*] Waiting for messages. To exit press CTRL+C</span><br><span class="line"> [x] Received &apos;First message.&apos;</span><br><span class="line"> [x] Received &apos;Third message...&apos;</span><br><span class="line"> [x] Received &apos;Fifth message.....&apos;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">shell2$ python worker.py</span><br><span class="line"> [*] Waiting for messages. To exit press CTRL+C</span><br><span class="line"> [x] Received &apos;Second message..&apos;</span><br><span class="line"> [x] Received &apos;Fourth message....&apos;</span><br></pre></td></tr></table></figure><p>默认来说，RabbitMQ会按顺序得把消息发送给每个消费者（consumer）。平均每个消费者都会收到同等数量得消息。这种发送消息得方式叫做——轮询（round-robin）。试着添加三个或更多得工作者（workers）。</p><h2 id="消息确认"><a href="#消息确认" class="headerlink" title="消息确认"></a>消息确认</h2><p>当处理一个比较耗时得任务的时候，你也许想知道消费者（consumers）是否运行到一半就挂掉。当前的代码中，当消息被RabbitMQ发送给消费者（consumers）之后，马上就会在内存中移除。这种情况，你只要把一个工作者（worker）停止，正在处理的消息就会丢失。同时，所有发送到这个工作者的还没有处理的消息都会丢失。</p><p>我们不想丢失任何任务消息。如果一个工作者（worker）挂掉了，我们希望任务会重新发送给其他的工作者（worker）。</p><p>为了防止消息丢失，RabbitMQ提供了消息响应（acknowledgments）。消费者会通过一个ack（响应），告诉RabbitMQ已经收到并处理了某条消息，然后RabbitMQ就会释放并删除这条消息。</p><p>如果消费者（consumer）挂掉了，没有发送响应，RabbitMQ就会认为消息没有被完全处理，然后重新发送给其他消费者（consumer）。这样，及时工作者（workers）偶尔的挂掉，也不会丢失消息。</p><p>消息是没有超时这个概念的；当工作者与它断开连的时候，RabbitMQ会重新发送消息。这样在处理一个耗时非常长的消息任务的时候就不会出问题了。</p><p>消息响应默认是开启的。之前的例子中我们可以使用no_ack=True标识把它关闭。是时候移除这个标识了，当工作者（worker）完成了任务，就发送一个响应。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def callback(ch, method, properties, body):</span><br><span class="line">    print(&quot; [x] Received %r&quot; % (body,))</span><br><span class="line">    time.sleep( body.count(&apos;.&apos;) )</span><br><span class="line">    print(&quot; [x] Done&quot;)</span><br><span class="line">    ch.basic_ack(delivery_tag = method.delivery_tag)</span><br><span class="line"></span><br><span class="line">channel.basic_consume(callback, queue=&apos;hello&apos;)</span><br></pre></td></tr></table></figure><p>运行上面的代码，我们发现即使使用CTRL+C杀掉了一个工作者（worker）进程，消息也不会丢失。当工作者（worker）挂掉这后，所有没有响应的消息都会重新发送。</p><blockquote><h4 id="忘记确认"><a href="#忘记确认" class="headerlink" title="忘记确认"></a>忘记确认</h4><p>一个很容易犯的错误就是忘了basic_ack，后果很严重。消息在你的程序退出之后就会重新发送，如果它不能够释放没响应的消息，RabbitMQ就会占用越来越多的内存。</p><p>为了排除这种错误，你可以使用rabbitmqctl命令，输出messages_unacknowledged字段：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; $ sudo rabbitmqctl list_queues name messages_ready messages_unacknowledged</span><br><span class="line">&gt; Listing queues ...</span><br><span class="line">&gt; hello    0       0</span><br><span class="line">&gt; ...done.</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h2 id="消息持久化"><a href="#消息持久化" class="headerlink" title="消息持久化"></a>消息持久化</h2><p>如果你没有特意告诉RabbitMQ，那么在它退出或者崩溃的时候，将会丢失所有队列和消息。为了确保信息不会丢失，有两个事情是需要注意的：我们必须把“队列”和“消息”设为持久化。</p><p>首先，为了不让队列消失，需要把队列声明为持久化（durable）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.queue_declare(queue=&apos;hello&apos;, durable=True)</span><br></pre></td></tr></table></figure><p>尽管这行代码本身是正确的，但是仍然不会正确运行。因为我们已经定义过一个叫hello的非持久化队列。RabbitMq不允许你使用不同的参数重新定义一个队列，它会返回一个错误。但我们现在使用一个快捷的解决方法——用不同的名字，例如task_queue。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.queue_declare(queue=&apos;task_queue&apos;, durable=True)</span><br></pre></td></tr></table></figure><p>这个queue_declare必须在生产者（producer）和消费者（consumer）对应的代码中修改。</p><p>这时候，我们就可以确保在RabbitMq重启之后queue_declare队列不会丢失。另外，我们需要把我们的消息也要设为持久化——将delivery_mode的属性设为2。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">channel.basic_publish(exchange=&apos;&apos;,</span><br><span class="line">                      routing_key=&quot;task_queue&quot;,</span><br><span class="line">                      body=message,</span><br><span class="line">                      properties=pika.BasicProperties(</span><br><span class="line">                         delivery_mode = 2, # make message persistent</span><br><span class="line">                      ))</span><br></pre></td></tr></table></figure><blockquote><h4 id="注意：消息持久化"><a href="#注意：消息持久化" class="headerlink" title="注意：消息持久化"></a>注意：消息持久化</h4><p>将消息设为持久化并不能完全保证不会丢失。以上代码只是告诉了RabbitMq要把消息存到硬盘，但从RabbitMq收到消息到保存之间还是有一个很小的间隔时间。因为RabbitMq并不是所有的消息都使用fsync(2)——它有可能只是保存到缓存中，并不一定会写到硬盘中。并不能保证真正的持久化，但已经足够应付我们的简单工作队列。如果你一定要保证持久化，你需要改写你的代码来支持事务（transaction）。</p></blockquote><h2 id="公平调度"><a href="#公平调度" class="headerlink" title="公平调度"></a>公平调度</h2><p>你应该已经发现，它仍旧没有按照我们期望的那样进行分发。比如有两个工作者（workers），处理奇数消息的比较繁忙，处理偶数消息的比较轻松。然而RabbitMQ并不知道这些，它仍然一如既往的派发消息。</p><p>这时因为RabbitMQ只管分发进入队列的消息，不会关心有多少消费者（consumer）没有作出响应。它盲目的把第n-th条消息发给第n-th个消费者。</p><p><img src="http://www.rabbitmq.com/img/tutorials/prefetch-count.png" alt="img"></p><p>我们可以使用basic.qos方法，并设置prefetch_count=1。这样是告诉RabbitMQ，再同一时刻，不要发送超过1条消息给一个工作者（worker），直到它已经处理了上一条消息并且作出了响应。这样，RabbitMQ就会把消息分发给下一个空闲的工作者（worker）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.basic_qos(prefetch_count=1)</span><br></pre></td></tr></table></figure><blockquote><h4 id="关于队列大小"><a href="#关于队列大小" class="headerlink" title="关于队列大小"></a>关于队列大小</h4><p>如果所有的工作者都处理繁忙状态，你的队列就会被填满。你需要留意这个问题，要么添加更多的工作者（workers），要么使用其他策略。</p></blockquote><h2 id="整合代码"><a href="#整合代码" class="headerlink" title="整合代码"></a>整合代码</h2><p>new_task.py的完整代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line">import pika</span><br><span class="line">import sys</span><br><span class="line"></span><br><span class="line">connection = pika.BlockingConnection(pika.ConnectionParameters(</span><br><span class="line">        host=&apos;localhost&apos;))</span><br><span class="line">channel = connection.channel()</span><br><span class="line"></span><br><span class="line">channel.queue_declare(queue=&apos;task_queue&apos;, durable=True)</span><br><span class="line"></span><br><span class="line">message = &apos; &apos;.join(sys.argv[1:]) or &quot;Hello World!&quot;</span><br><span class="line">channel.basic_publish(exchange=&apos;&apos;,</span><br><span class="line">                      routing_key=&apos;task_queue&apos;,</span><br><span class="line">                      body=message,</span><br><span class="line">                      properties=pika.BasicProperties(</span><br><span class="line">                         delivery_mode = 2, # make message persistent</span><br><span class="line">                      ))</span><br><span class="line">print(&quot; [x] Sent %r&quot; % (message,))</span><br><span class="line">connection.close()</span><br></pre></td></tr></table></figure><p>(<a href="https://github.com/rabbitmq/rabbitmq-tutorials/blob/master/python/new_task.py" target="_blank" rel="noopener">new_task.py</a>源码)</p><p>我们的worker：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line">import pika</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line">connection = pika.BlockingConnection(pika.ConnectionParameters(</span><br><span class="line">        host=&apos;localhost&apos;))</span><br><span class="line">channel = connection.channel()</span><br><span class="line"></span><br><span class="line">channel.queue_declare(queue=&apos;task_queue&apos;, durable=True)</span><br><span class="line">print(&apos; [*] Waiting for messages. To exit press CTRL+C&apos;)</span><br><span class="line"></span><br><span class="line">def callback(ch, method, properties, body):</span><br><span class="line">    print(&quot; [x] Received %r&quot; % (body,))</span><br><span class="line">    time.sleep( body.count(&apos;.&apos;) )</span><br><span class="line">    print(&quot; [x] Done&quot;)</span><br><span class="line">    ch.basic_ack(delivery_tag = method.delivery_tag)</span><br><span class="line"></span><br><span class="line">channel.basic_qos(prefetch_count=1)</span><br><span class="line">channel.basic_consume(callback,</span><br><span class="line">                      queue=&apos;task_queue&apos;)</span><br><span class="line"></span><br><span class="line">channel.start_consuming()</span><br></pre></td></tr></table></figure><p>(<a href="http://github.com/rabbitmq/rabbitmq-tutorials/blob/master/python/worker.py" target="_blank" rel="noopener">worker.py</a> source)</p><p>使用消息响应和prefetch_count你就可以搭建起一个工作队列了。这些持久化的选项使得在RabbitMQ重启之后仍然能够恢复。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;工作队列&quot;&gt;&lt;a href=&quot;#工作队列&quot; class=&quot;headerlink&quot; title=&quot;工作队列&quot;&gt;&lt;/a&gt;工作队列&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://www.rabbitmq.com/img/tutorials/python-two.png
      
    
    </summary>
    
      <category term="RabbitMQ" scheme="http://gavinliu4011.github.io/categories/RabbitMQ/"/>
    
    
      <category term="Python" scheme="http://gavinliu4011.github.io/tags/Python/"/>
    
      <category term="RabbitMQ" scheme="http://gavinliu4011.github.io/tags/RabbitMQ/"/>
    
      <category term="消息队列" scheme="http://gavinliu4011.github.io/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>Python版RabbitMQ消息队列之Hello World（一）</title>
    <link href="http://gavinliu4011.github.io/post/79b12668.html"/>
    <id>http://gavinliu4011.github.io/post/79b12668.html</id>
    <published>2018-03-17T23:37:30.000Z</published>
    <updated>2018-03-17T15:37:41.094Z</updated>
    
    <content type="html"><![CDATA[<h2 id="RabbitMQ安装"><a href="#RabbitMQ安装" class="headerlink" title="RabbitMQ安装"></a>RabbitMQ安装</h2><p>请移步<a href="http://www.cnblogs.com/nulige/p/6351318.html" target="_blank" rel="noopener">努力哥</a>博客</p><h2 id="RabbitMQ队列"><a href="#RabbitMQ队列" class="headerlink" title="RabbitMQ队列"></a>RabbitMQ队列</h2><p>RabbitMQ是一个消息代理。它的工作就是接收和转发消息。你可以把它想像成一个邮局：你把信件放入邮箱，邮递员就会把信件投递到你的收件人处。在这个比喻中，RabbitMQ就扮演着邮箱、邮局以及邮递员的角色。</p><p>RabbitMQ和邮局的主要区别在于，它处理纸张，而是接收、存储和发送消息（message）这种二进制数据。</p><p>下面是RabbitMQ和消息所涉及到的一些术语。</p><ul><li><p>生产(Producing)的意思就是发送。发送消息的程序就是一个生产者(producer)。我们一般用”P”来表示:<br><img src="http://www.rabbitmq.com/img/tutorials/producer.png" alt="img"></p></li><li><p>队列(queue)就是存在于RabbitMQ中邮箱的名称。虽然消息的传输经过了RabbitMQ和你的应用程序，但是它只能被存储于队列当中。实质上队列就是个巨大的消息缓冲区，它的大小只受主机内存和硬盘限制。多个生产者（producers）可以把消息发送给同一个队列，同样，多个消费者（consumers）也能够从同一个队列（queue）中获取数据。队列可以绘制成这样（图上是队列的名称）：<br><img src="http://www.rabbitmq.com/img/tutorials/queue.png" alt="img"></p></li><li><p>在这里，消费（Consuming）和接收(receiving)是同一个意思。一个消费者（consumer）就是一个等待获取消息的程序。我们把它绘制为”C”：<br><img src="http://www.rabbitmq.com/img/tutorials/consumer.png" alt="img"></p></li></ul><p>需要指出的是生产者、消费者、代理需不要待在同一个设备上；事实上大多数应用也确实不在会将他们放在一台机器上。</p><h2 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h2><p>接下来我们用Python写两个小程序。一个发送单条消息的生产者（producer）和一个接收消息并将其输出的消费者（consumer）。传递的消息是”Hello World”。</p><p>下图中，“P”代表生产者，“C”代表消费者，中间的盒子代表为消费者保留的消息缓冲区，也就是我们的队列。</p><p><img src="http://www.rabbitmq.com/img/tutorials/python-one-overall.png" alt="img"></p><p>生产者（producer）把消息发送到一个名为“hello”的队列中。消费者（consumer）从这个队列中获取消息。</p><blockquote><h4 id="RabbitMQ库"><a href="#RabbitMQ库" class="headerlink" title="RabbitMQ库"></a>RabbitMQ库</h4><p>RabbitMQ使用的是AMQP 0.9.1协议。这是一个用于消息传递的开放、通用的协议。针对<a href="https://www.rabbitmq.com/devtools.html" target="_blank" rel="noopener">不同编程语言</a>有大量的RabbitMQ客户端可用。在这个系列教程中，RabbitMQ团队推荐使用<a href="https://pika.readthedocs.org/en/0.10.0/#" target="_blank" rel="noopener">Pika</a>这个Python客户端。大家可以通过<a href="https://pip.pypa.io/en/stable/quickstart/" target="_blank" rel="noopener">pip</a>这个包管理工具进行安装：</p></blockquote><h3 id="发送"><a href="#发送" class="headerlink" title="发送"></a>发送</h3><p><img src="http://www.rabbitmq.com/img/tutorials/sending.png" alt="img"></p><p>我们第一个程序<code>send.py</code>会发送一个消息到队列中。首先要做的事情就是建立一个到RabbitMQ服务器的连接。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line">import pika</span><br><span class="line"></span><br><span class="line">connection = pika.BlockingConnection(pika.ConnectionParameters(&apos;localhost&apos;))</span><br><span class="line">channel = connection.channel()</span><br></pre></td></tr></table></figure><p>现在我们已经跟本地机器的代理建立了连接。如果你想连接到其他机器的代理上，需要把代表本地的<code>localhost</code>改为指定的名字或IP地址。</p><p>接下来，在发送消息之前，我们需要确认服务于消费者的队列已经存在。如果将消息发送给一个不存在的队列，RabbitMQ会将消息丢弃掉。下面我们创建一个名为”hello”的队列用来将消息投递进去。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.queue_declare(queue=&apos;hello&apos;)</span><br></pre></td></tr></table></figure><p>这时候我们就可以发送消息了，我们第一条消息只包含了Hello World!字符串，我们打算把它发送到hello队列。</p><p>在RabbitMQ中，消息是不能直接发送到队列中的，这个过程需要通过交换机（exchange）来进行。但是为了不让细节拖累我们的进度，这里我们只需要知道如何使用由空字符串表示的默认交换机即可。如果你想要详细了解交换机，可以查看我们<a href="https://www.rabbitmq.com/tutorials/tutorial-three-python.html" target="_blank" rel="noopener">教程的第三部分</a>来获取更多细节。默认交换机比较特别，它允许我们指定消息究竟需要投递到哪个具体的队列中，队列名字需要在<code>routing_key</code>参数中指定。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">channel.basic_publish(exchange=&apos;&apos;,</span><br><span class="line">                      routing_key=&apos;hello&apos;,</span><br><span class="line">                      body=&apos;Hello World!&apos;)</span><br><span class="line">print(&quot; [x] Sent &apos;Hello World!&apos;&quot;)</span><br></pre></td></tr></table></figure><p>在退出程序之前，我们需要确认网络缓冲已经被刷写、消息已经投递到RabbitMQ。通过安全关闭连接可以做到这一点。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">connection.close()</span><br></pre></td></tr></table></figure><blockquote><p>发送不成功！</p><p>如果这是你第一次使用RabbitMQ，并且没有看到“Sent”消息出现在屏幕上，你可能会抓耳挠腮不知所以。这也许是因为没有足够的磁盘空间给代理使用所造成的（代理默认需要200MB的空闲空间），所以它才会拒绝接收消息。查看一下代理的日志文件进行确认，如果需要的话也可以减少限制。<a href="http://www.rabbitmq.com/configure.html#config-items" target="_blank" rel="noopener">配置文件文档</a>会告诉你如何更改磁盘空间限制（disk_free_limit）。</p></blockquote><h3 id="接收"><a href="#接收" class="headerlink" title="接收"></a>接收</h3><p><img src="https://www.rabbitmq.com/img/tutorials/receiving.png" alt="img"></p><p>我们的第二个程序<code>receive.py</code>，将会从队列中获取消息并将其打印到屏幕上。</p><p>这次我们还是需要要先连接到RabbitMQ服务器。连接服务器的代码和之前是一样的。</p><p>下一步也和之前一样，我们需要确认队列是存在的。我们可以多次使用<code>queue_declare</code>命令来创建同一个队列，但是只有一个队列会被真正的创建。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.queue_declare(queue=&apos;hello&apos;)</span><br></pre></td></tr></table></figure><p>你也许要问: 为什么要重复声明队列呢 —— 我们已经在前面的代码中声明过它了。如果我们确定了队列是已经存在的，那么我们可以不这么做，比如此前预先运行了send.py程序。可是我们并不确定哪个程序会首先运行。这种情况下，在程序中重复将队列重复声明一下是种值得推荐的做法。</p><blockquote><h4 id="列出所有队列"><a href="#列出所有队列" class="headerlink" title="列出所有队列"></a>列出所有队列</h4><p>你也许希望查看RabbitMQ中有哪些队列、有多少消息在队列中。此时你可以使用rabbitmqctl工具（使用有权限的用户）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; sudo rabbitmqctl list_queues</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p>（在Windows中不需要sudo命令）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; rabbitmqctl list_queues</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>从队列中获取消息相对来说稍显复杂。需要为队列定义一个回调（callback）函数。当我们获取到消息的时候，Pika库就会调用此回调函数。这个回调函数会将接收到的消息内容输出到屏幕上。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def callback(ch, method, properties, body):</span><br><span class="line">    print(&quot; [x] Received %r&quot; % body)</span><br></pre></td></tr></table></figure><p>下一步，我们需要告诉RabbitMQ这个回调函数将会从名为”hello”的队列中接收消息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.basic_consume(callback, queue=&apos;hello&apos;, no_ack=True)</span><br></pre></td></tr></table></figure><p>要成功运行这些命令，我们必须保证队列是存在的，我们的确可以确保它的存在——因为我们之前已经使用<code>queue_declare</code>将其声明过了。</p><p><code>no_ack</code>参数<a href="https://www.rabbitmq.com/tutorials/tutorial-two-python.html" target="_blank" rel="noopener">稍后</a>会进行介绍。</p><p>最后，我们运行一个用来等待消息数据并且在需要的时候运行回调函数的无限循环。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(&apos; [*] Waiting for messages. To exit press CTRL+C&apos;)</span><br><span class="line">channel.start_consuming()</span><br></pre></td></tr></table></figure><h3 id="将代码整合到一起"><a href="#将代码整合到一起" class="headerlink" title="将代码整合到一起"></a>将代码整合到一起</h3><p><strong>send.py的完整代码：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line">import pika</span><br><span class="line"></span><br><span class="line">connection =</span><br><span class="line">pika.BlockingConnection(pika.ConnectionParameters(host=&apos;localhost&apos;))</span><br><span class="line">channel = connection.channel()</span><br><span class="line"></span><br><span class="line">channel.queue_declare(queue=&apos;hello&apos;)</span><br><span class="line"></span><br><span class="line">channel.basic_publish(exchange=&apos;&apos;,</span><br><span class="line">                      routing_key=&apos;hello&apos;,</span><br><span class="line">                      body=&apos;Hello World!&apos;)</span><br><span class="line">print(&quot; [x] Sent &apos;Hello World!&apos;&quot;)</span><br><span class="line">connection.close()</span><br></pre></td></tr></table></figure><p>(<a href="http://github.com/rabbitmq/rabbitmq-tutorials/blob/master/python/send.py" target="_blank" rel="noopener">send.py源码</a>)</p><p><strong>receive.py的完整代码：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line">import pika</span><br><span class="line"></span><br><span class="line">connection =</span><br><span class="line">pika.BlockingConnection(pika.ConnectionParameters(host=&apos;localhost&apos;))</span><br><span class="line">channel = connection.channel()</span><br><span class="line"></span><br><span class="line">channel.queue_declare(queue=&apos;hello&apos;)</span><br><span class="line"></span><br><span class="line">def callback(ch, method, properties, body):</span><br><span class="line">    print(&quot; [x] Received %r&quot; % body)</span><br><span class="line"></span><br><span class="line">channel.basic_consume(callback,</span><br><span class="line">                      queue=&apos;hello&apos;,</span><br><span class="line">                      no_ack=True)</span><br><span class="line"></span><br><span class="line">print(&apos; [*] Waiting for messages. To exit press CTRL+C&apos;)</span><br><span class="line">channel.start_consuming()</span><br></pre></td></tr></table></figure><p>(<a href="http://github.com/rabbitmq/rabbitmq-tutorials/blob/master/python/receive.py" target="_blank" rel="noopener">receive.py源码</a>)</p><p>现在我们可以在终端中尝试一下我们的程序了。<br>首先我们启动一个消费者，它会持续的运行来等待投递到达。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">python receive.py</span><br><span class="line"># =&gt; [*] Waiting for messages. To exit press CTRL+C</span><br><span class="line"># =&gt; [x] Received &apos;Hello World!&apos;</span><br></pre></td></tr></table></figure><p>然后启动生产者，生产者程序每次执行后都会停止运行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python send.py</span><br><span class="line"># =&gt; [x] Sent &apos;Hello World!&apos;</span><br></pre></td></tr></table></figure><p><strong>成功了！</strong>我们已经通过RabbitMQ发送第一条消息。你也许已经注意到了，receive.py程序并没有退出。它一直在准备获取消息，你可以通过Ctrl-C来中止它。</p><p>试下在新的终端中再次运行<code>send.py</code>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;RabbitMQ安装&quot;&gt;&lt;a href=&quot;#RabbitMQ安装&quot; class=&quot;headerlink&quot; title=&quot;RabbitMQ安装&quot;&gt;&lt;/a&gt;RabbitMQ安装&lt;/h2&gt;&lt;p&gt;请移步&lt;a href=&quot;http://www.cnblogs.com/nul
      
    
    </summary>
    
      <category term="RabbitMQ" scheme="http://gavinliu4011.github.io/categories/RabbitMQ/"/>
    
    
      <category term="Python" scheme="http://gavinliu4011.github.io/tags/Python/"/>
    
      <category term="RabbitMQ" scheme="http://gavinliu4011.github.io/tags/RabbitMQ/"/>
    
      <category term="消息队列" scheme="http://gavinliu4011.github.io/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>Python之concurrent.futures</title>
    <link href="http://gavinliu4011.github.io/post/b1bc006d.html"/>
    <id>http://gavinliu4011.github.io/post/b1bc006d.html</id>
    <published>2018-03-08T23:19:00.000Z</published>
    <updated>2018-03-08T15:19:50.863Z</updated>
    
    <content type="html"><![CDATA[<h3 id="concurrent-futures"><a href="#concurrent-futures" class="headerlink" title="concurrent.futures"></a>concurrent.futures</h3><h4 id="ProcessPoolExecutor"><a href="#ProcessPoolExecutor" class="headerlink" title="ProcessPoolExecutor"></a>ProcessPoolExecutor</h4><p>进程池，提供异步调用</p><h5 id="基本方法"><a href="#基本方法" class="headerlink" title="基本方法"></a>基本方法</h5><ul><li><p>submit(fn, <em>args, *</em>kwargs) 异步提交任务</p></li><li><p>map(func, *iterables, timeout=None, chunksize=1) 取代for循环submit的操作</p></li><li><p>shutdown(wait=True) 相当于进程池的pool.close()+pool.join()操作</p><p>wait=True，等待池内所有任务执行完毕回收完资源后才继续<br>wait=False，立即返回，并不会等待池内的任务执行完毕<br>但不管wait参数为何值，整个程序都会等到所有任务执行完毕<br>submit和map必须在shutdown之前</p></li><li><p>result(timeout=None)取得结果</p></li><li><p>add_done_callback(fn)回调函数</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ThreadPoolExecutor, ProcessPoolExecutor</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> os, time, random</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task</span><span class="params">(n)</span>:</span></span><br><span class="line">    print(<span class="string">'%s is runing'</span> % os.getpid())</span><br><span class="line">    time.sleep(random.randint(<span class="number">1</span>, <span class="number">3</span>))</span><br><span class="line">    <span class="keyword">return</span> n ** <span class="number">2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line"></span><br><span class="line">    executor = ProcessPoolExecutor(max_workers=<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">    futures = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">11</span>):</span><br><span class="line">        future = executor.submit(task, i)</span><br><span class="line">        futures.append(future)</span><br><span class="line">    executor.shutdown(<span class="keyword">True</span>)</span><br><span class="line">    print(<span class="string">'+++&gt;'</span>)</span><br><span class="line">    <span class="keyword">for</span> future <span class="keyword">in</span> futures:</span><br><span class="line">        print(future.result())</span><br></pre></td></tr></table></figure><h4 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h4><p>线程池，提供异步调用，用法与ProcessPoolExecutor相同，只需要将ProcessPoolExecutor换成ThreadPoolExecutor</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ThreadPoolExecutor</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(n)</span>:</span></span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    print(n)</span><br><span class="line">    <span class="keyword">return</span> n * n</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">call_back</span><span class="params">(m)</span>:</span></span><br><span class="line">    print(<span class="string">'结果是 %s'</span> % m.result())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    tpool = ThreadPoolExecutor(max_workers=<span class="number">5</span>)  <span class="comment"># 默认 不要超过cpu个数*5</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">20</span>):</span><br><span class="line">        tpool.submit(func, i).add_done_callback(call_back)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;concurrent-futures&quot;&gt;&lt;a href=&quot;#concurrent-futures&quot; class=&quot;headerlink&quot; title=&quot;concurrent.futures&quot;&gt;&lt;/a&gt;concurrent.futures&lt;/h3&gt;&lt;h4 id=&quot;P
      
    
    </summary>
    
      <category term="Python线程" scheme="http://gavinliu4011.github.io/categories/Python%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="Python" scheme="http://gavinliu4011.github.io/tags/Python/"/>
    
      <category term="进程池" scheme="http://gavinliu4011.github.io/tags/%E8%BF%9B%E7%A8%8B%E6%B1%A0/"/>
    
      <category term="线程池" scheme="http://gavinliu4011.github.io/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    
  </entry>
  
  <entry>
    <title>Python线程——信号量（Semaphore）、队列（Queue）</title>
    <link href="http://gavinliu4011.github.io/post/d068a68c.html"/>
    <id>http://gavinliu4011.github.io/post/d068a68c.html</id>
    <published>2018-03-07T23:32:30.000Z</published>
    <updated>2018-03-08T15:19:50.873Z</updated>
    
    <content type="html"><![CDATA[<h3 id="信号量（Semaphore）"><a href="#信号量（Semaphore）" class="headerlink" title="信号量（Semaphore）"></a>信号量（Semaphore）</h3><p>之前讲的线程锁（互斥锁）同时只允许一个线程更改数据，而Semaphore是同时允许一定数量的线程更改数据 ，比如厕所有4个坑，那最多只允许4个人上厕所，后面的人只能等里面有人出来了才能再进去。 说白了就是在同一时间，可以只允许设定的数量的线程去执行 。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Semaphore, Thread</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(sem, a, b)</span>:</span></span><br><span class="line">    sem.acquire()</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    print(a + b)</span><br><span class="line">    sem.release()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sem = Semaphore(<span class="number">4</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">    t = Thread(target=func, args=(sem, i, i + <span class="number">5</span>))</span><br><span class="line">    t.start()</span><br></pre></td></tr></table></figure><h3 id="队列（Queue）"><a href="#队列（Queue）" class="headerlink" title="队列（Queue）"></a>队列（Queue）</h3><p>queue队列 ：使用import queue，用法与<a href="https://gavinliu4011.github.io/post/58b02bea.html#more">进程Queue</a>一样 </p><p>####class queue.Queue(maxsize=0) 先进先出</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> queue</span><br><span class="line"></span><br><span class="line">q=queue.Queue()</span><br><span class="line">q.put(<span class="string">'first'</span>)</span><br><span class="line">q.put(<span class="string">'second'</span>)</span><br><span class="line">q.put(<span class="string">'third'</span>)</span><br><span class="line"></span><br><span class="line">print(q.get())</span><br><span class="line">print(q.get())</span><br><span class="line">print(q.get())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行结果</span></span><br><span class="line">结果(先进先出):</span><br><span class="line">first</span><br><span class="line">second</span><br><span class="line">third</span><br></pre></td></tr></table></figure><h4 id="class-queue-LifoQueue-maxsize-0-后进先出"><a href="#class-queue-LifoQueue-maxsize-0-后进先出" class="headerlink" title="class queue.LifoQueue(maxsize=0) 后进先出"></a>class queue.LifoQueue(maxsize=0) 后进先出</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> queue</span><br><span class="line"></span><br><span class="line">q=queue.LifoQueue()</span><br><span class="line">q.put(<span class="string">'first'</span>)</span><br><span class="line">q.put(<span class="string">'second'</span>)</span><br><span class="line">q.put(<span class="string">'third'</span>)</span><br><span class="line"></span><br><span class="line">print(q.get())</span><br><span class="line">print(q.get())</span><br><span class="line">print(q.get())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行结果</span></span><br><span class="line">结果(后进先出):</span><br><span class="line">third</span><br><span class="line">second</span><br><span class="line">first</span><br></pre></td></tr></table></figure><h4 id="class-queue-PriorityQueue-maxsize-0"><a href="#class-queue-PriorityQueue-maxsize-0" class="headerlink" title="class queue.PriorityQueue(maxsize=0)"></a>class queue.PriorityQueue(maxsize=0)</h4><p>根据优先级来取数据。存放数据的格式  : Queue.put((priority_number,data))，priority_number越小，优先级越高，data代表存入的值 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> queue</span><br><span class="line">q = queue.PriorityQueue()</span><br><span class="line">q.put((<span class="number">1</span>, <span class="string">"d1"</span>))</span><br><span class="line">q.put((<span class="number">-1</span>, <span class="string">"d2"</span>))</span><br><span class="line">q.put((<span class="number">6</span>, <span class="string">"d3"</span>))</span><br><span class="line">print(q.get())</span><br><span class="line">print(q.get())</span><br><span class="line">print(q.get())</span><br><span class="line"> </span><br><span class="line"><span class="comment">#执行结果</span></span><br><span class="line">(<span class="number">-1</span>, <span class="string">'d2'</span>)</span><br><span class="line">(<span class="number">1</span>, <span class="string">'d1'</span>)</span><br><span class="line">(<span class="number">6</span>, <span class="string">'d3'</span>)</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意：</strong>maxsize代表这个队列最大能够put的长度 </p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;信号量（Semaphore）&quot;&gt;&lt;a href=&quot;#信号量（Semaphore）&quot; class=&quot;headerlink&quot; title=&quot;信号量（Semaphore）&quot;&gt;&lt;/a&gt;信号量（Semaphore）&lt;/h3&gt;&lt;p&gt;之前讲的线程锁（互斥锁）同时只允许一个线程更
      
    
    </summary>
    
      <category term="Python线程" scheme="http://gavinliu4011.github.io/categories/Python%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="Python" scheme="http://gavinliu4011.github.io/tags/Python/"/>
    
      <category term="线程" scheme="http://gavinliu4011.github.io/tags/%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="信号量" scheme="http://gavinliu4011.github.io/tags/%E4%BF%A1%E5%8F%B7%E9%87%8F/"/>
    
      <category term="队列" scheme="http://gavinliu4011.github.io/tags/%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>Python线程——GIL锁、线程锁（互斥锁）、递归锁（RLock）</title>
    <link href="http://gavinliu4011.github.io/post/5b18ac8.html"/>
    <id>http://gavinliu4011.github.io/post/5b18ac8.html</id>
    <published>2018-03-06T23:53:57.000Z</published>
    <updated>2018-03-08T15:19:50.844Z</updated>
    
    <content type="html"><![CDATA[<h3 id="GIL锁"><a href="#GIL锁" class="headerlink" title="GIL锁"></a>GIL锁</h3><p>​    计算机有4核，代表着同一时间，可以干4个任务。如果单核cpu的话，我启动10个线程，我看上去也是并发的，因为是执行了上下文的切换，让看上去是并发的。但是单核永远肯定时串行的，它肯定是串行的，cpu真正执行的时候，因为一会执行1，一会执行2.。。。。正常的线程就是这个样子的。但是，在python中，无论有多少核，永远都是假象。无论是4核，8核，还是16核…….不好意思，同一时间执行的线程只有一个(线程)，它就是这个样子的。</p><h4 id="全局解释器锁-GIL"><a href="#全局解释器锁-GIL" class="headerlink" title="全局解释器锁(GIL)"></a>全局解释器锁(GIL)</h4><p>​    Python代码的执行由Python虚拟机(也叫解释器主循环)来控制。Python在设计之初就考虑到要在主循环中，同时只有一个线程在执行。虽然 Python 解释器中可以“运行”多个线程，但在任意时刻只有一个线程在解释器中运行。<br>　　对Python虚拟机的访问由全局解释器锁(GIL)来控制，正是这个锁能保证同一时刻只有一个线程在运行。</p><p>　　在多线程环境中，Python 虚拟机按以下方式执行：</p><p>　　1、设置 GIL；</p><p>　　2、切换到一个线程去运行；</p><p>　　3、运行指定数量的字节码指令或者线程主动让出控制(可以调用 time.sleep(0))；</p><p>　　4、把线程设置为睡眠状态；</p><p>　　5、解锁 GIL；</p><p>　　6、再次重复以上所有步骤。<br>　　在调用外部代码(如 C/C++扩展函数)的时候，GIL将会被锁定，直到这个函数结束为止(由于在这期间没有Python的字节码被运行，所以不会做线程切换)编写扩展的程序员可以主动解锁GIL。</p><p>####GIL锁关系图</p><p>GIL(全局解释器锁)是加在python解释器里面的，效果如图 :</p><p><img src="..\img\thread\1449713172.png" alt=""></p><h5 id="为什么GIL锁要加在python解释器这一层，而却不加在其他地方？"><a href="#为什么GIL锁要加在python解释器这一层，而却不加在其他地方？" class="headerlink" title="为什么GIL锁要加在python解释器这一层，而却不加在其他地方？"></a>为什么GIL锁要加在python解释器这一层，而却不加在其他地方？</h5><p>​    很多资料说是因为python调用的所有线程都是原生线程。原生线程是通过C语言提供原生接口，相当于C语言的一个函数。你一调它，你就控制不了了它了，就必须等它给你返回结果。只要已通过python虚拟机，再往下就不受python控制了，就是C语言自己控制了。你加在python虚拟机以下，你是加不上去的。同一时间，只有一个线程穿过这个锁去真正执行。其他的线程，只能在python虚拟机这边等待。 </p><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>​    需要明确的一点是<code>GIL</code>并不是Python的特性，它是在实现Python解析器(CPython)时所引入的一个概念。就好比C++是一套语言（语法）标准，但是可以用不同的编译器来编译成可执行代码。有名的编译器例如GCC，INTEL C++，Visual C++等。Python也一样，同样一段代码可以通过CPython，JPython，PyPy，Psyco等不同的Python执行环境来执行。而JPython就没有GIL。然而因为CPython是大部分环境下默认的Python执行环境。所以在很多人的概念里CPython就是Python，也就想当然的把<code>GIL</code>归结为Python语言的缺陷。所以这里要先明确一点：<strong>GIL并不是Python的特性，Python完全可以不依赖于GIL</strong>。 </p><h3 id="线程锁（互斥锁）"><a href="#线程锁（互斥锁）" class="headerlink" title="线程锁（互斥锁）"></a>线程锁（互斥锁）</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">work</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 在这里模拟一个底层做运算的过程，具体为什么这个我不知道，看某资料写的，</span></span><br><span class="line">    <span class="comment"># 如果这里直接对num进行运算很难出现数据不安全的结果</span></span><br><span class="line">    <span class="keyword">global</span> num  <span class="comment"># 把num变成全局变量</span></span><br><span class="line">    temp = num</span><br><span class="line">    time.sleep(<span class="number">1</span>)  <span class="comment"># 注意了sleep的时候是不占有cpu的，这个时候cpu直接把这个线程挂起了，此时cpu去干别的事情去了</span></span><br><span class="line">    num = temp + <span class="number">1</span>  <span class="comment"># 所有的线程都做+1操作</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line"></span><br><span class="line">    num = <span class="number">0</span>  <span class="comment"># 初始化num为0</span></span><br><span class="line">    t_obj = list()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">100</span>):</span><br><span class="line">        t = Thread(target=work)</span><br><span class="line">        t.start()</span><br><span class="line">        t_obj.append(t)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> t <span class="keyword">in</span> t_obj:</span><br><span class="line">        t.join()</span><br><span class="line">    print(<span class="string">"num:"</span>, num)  <span class="comment"># 输出最后的num值，可能是1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 执行结果</span></span><br><span class="line">    num: <span class="number">1</span></span><br></pre></td></tr></table></figure><p>下面我们就用一张图来解释一下这个原因 ：</p><p><img src="..\img\thread\80064182.png" alt=""></p><p>上面的例子中出现数据不安全问题，那么我们应该怎么解决呢？在这里我们引用线程锁来解决这个问题</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Lock,Thread</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">work</span><span class="params">(lock)</span>:</span></span><br><span class="line">    <span class="comment"># 在这里模拟一个底层做运算的过程，具体为什么这个我不知道，看某资料写的，</span></span><br><span class="line">    <span class="comment"># 如果这里直接对num进行运算很难出现数据不安全的结果</span></span><br><span class="line">    <span class="keyword">global</span> num  <span class="comment"># 把num变成全局变量</span></span><br><span class="line">    lock.acquire()</span><br><span class="line">    temp = num</span><br><span class="line">    time.sleep(<span class="number">0.1</span>)  <span class="comment"># 注意了sleep的时候是不占有cpu的，这个时候cpu直接把这个线程挂起了，此时cpu去干别的事情去了</span></span><br><span class="line">    num = temp + <span class="number">1</span>  <span class="comment"># 所有的线程都做+1操作</span></span><br><span class="line">    lock.release()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line"></span><br><span class="line">    num = <span class="number">0</span>  <span class="comment"># 初始化num为0</span></span><br><span class="line">    t_obj = list()</span><br><span class="line">    lock = Lock()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">100</span>):</span><br><span class="line">        t = Thread(target=work, args=(lock,))</span><br><span class="line">        t.start()</span><br><span class="line">        t_obj.append(t)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> t <span class="keyword">in</span> t_obj:</span><br><span class="line">        t.join()</span><br><span class="line">    print(<span class="string">"num:"</span>, num)  <span class="comment"># 输出最后的num值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 执行结果</span></span><br><span class="line">    num: <span class="number">100</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>注意：</strong>这里的Lock创建的锁和GIL没有关系 ，</p></blockquote><h3 id="递归锁（RLock）"><a href="#递归锁（RLock）" class="headerlink" title="递归锁（RLock）"></a>递归锁（RLock）</h3><h4 id="线程死锁"><a href="#线程死锁" class="headerlink" title="线程死锁"></a>线程死锁</h4><p>​    所谓死锁： 是指两个或两个以上的进程或线程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程，比如下面例子中“科学家吃面”：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Lock, Thread</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">noodle_lock = Lock()</span><br><span class="line">fork_lock = Lock()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">eat1</span><span class="params">(name)</span>:</span></span><br><span class="line">    noodle_lock.acquire()</span><br><span class="line">    print(<span class="string">'%s拿到面条啦'</span> % name)</span><br><span class="line">    fork_lock.acquire()</span><br><span class="line">    print(<span class="string">'%s拿到叉子了'</span> % name)</span><br><span class="line">    print(<span class="string">'%s吃面'</span> % name)</span><br><span class="line">    fork_lock.release()</span><br><span class="line">    noodle_lock.release()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">eat2</span><span class="params">(name)</span>:</span></span><br><span class="line">    fork_lock.acquire()</span><br><span class="line">    print(<span class="string">'%s拿到叉子了'</span> % name)</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    noodle_lock.acquire()</span><br><span class="line">    print(<span class="string">'%s拿到面条啦'</span> % name)</span><br><span class="line">    print(<span class="string">'%s吃面'</span> % name)</span><br><span class="line">    noodle_lock.release()</span><br><span class="line">    fork_lock.release()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    Thread(target=eat1, args=(<span class="string">'张三'</span>,)).start()</span><br><span class="line">    Thread(target=eat2, args=(<span class="string">'李四'</span>,)).start()</span><br><span class="line">    Thread(target=eat1, args=(<span class="string">'王五'</span>,)).start()</span><br><span class="line">    Thread(target=eat2, args=(<span class="string">'赵六'</span>,)).start()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行结果</span></span><br><span class="line">张三拿到面条啦</span><br><span class="line">张三拿到叉子了</span><br><span class="line">张三吃面</span><br><span class="line">李四拿到叉子了</span><br><span class="line">王五拿到面条啦</span><br></pre></td></tr></table></figure><p>上面例子中情况是在线程间共享多个资源的时候，如果两个线程分别占有一部分资源并且同时等待对方的资源，就会造成死锁，因为系统判断这部分资源都正在使用，所有这两个线程在无外力作用下将一直等待下去。执行结果，是无限的进入死循环，所以不能这么加，这个时候就需要用到递归锁。 </p><h4 id="递归锁-RLock"><a href="#递归锁-RLock" class="headerlink" title="递归锁(RLock)"></a>递归锁(RLock)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread, RLock  <span class="comment"># 递归锁</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">fork_lock = noodle_lock = RLock()  <span class="comment"># 一个钥匙串上的两把钥匙</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">eat1</span><span class="params">(name)</span>:</span></span><br><span class="line">    noodle_lock.acquire()  <span class="comment"># 一把钥匙</span></span><br><span class="line">    print(<span class="string">'%s拿到面条啦'</span> % name)</span><br><span class="line">    fork_lock.acquire()</span><br><span class="line">    print(<span class="string">'%s拿到叉子了'</span> % name)</span><br><span class="line">    print(<span class="string">'%s吃面'</span> % name)</span><br><span class="line">    fork_lock.release()</span><br><span class="line">    noodle_lock.release()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">eat2</span><span class="params">(name)</span>:</span></span><br><span class="line">    fork_lock.acquire()</span><br><span class="line">    print(<span class="string">'%s拿到叉子了'</span> % name)</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    noodle_lock.acquire()</span><br><span class="line">    print(<span class="string">'%s拿到面条啦'</span> % name)</span><br><span class="line">    print(<span class="string">'%s吃面'</span> % name)</span><br><span class="line">    noodle_lock.release()</span><br><span class="line">    fork_lock.release()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    Thread(target=eat1, args=(<span class="string">'张三'</span>,)).start()</span><br><span class="line">    Thread(target=eat2, args=(<span class="string">'李四'</span>,)).start()</span><br><span class="line">    Thread(target=eat1, args=(<span class="string">'王五'</span>,)).start()</span><br><span class="line">    Thread(target=eat2, args=(<span class="string">'赵六'</span>,)).start()</span><br></pre></td></tr></table></figure><p>自我理解递归锁原理其实很简单：就是每开一把门，在字典里面存一份数据，退出的时候去到door1或者door2里面找到这个钥匙退出 </p><p><img src="..\img\thread\1032923525.png" alt=""></p><blockquote><p><strong>注意：</strong>递归锁用于多重锁的情况，如果只是一层锁，就用不上递归锁</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;GIL锁&quot;&gt;&lt;a href=&quot;#GIL锁&quot; class=&quot;headerlink&quot; title=&quot;GIL锁&quot;&gt;&lt;/a&gt;GIL锁&lt;/h3&gt;&lt;p&gt;​    计算机有4核，代表着同一时间，可以干4个任务。如果单核cpu的话，我启动10个线程，我看上去也是并发的，因为是执行
      
    
    </summary>
    
      <category term="Python线程" scheme="http://gavinliu4011.github.io/categories/Python%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="Python" scheme="http://gavinliu4011.github.io/tags/Python/"/>
    
      <category term="线程" scheme="http://gavinliu4011.github.io/tags/%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="锁" scheme="http://gavinliu4011.github.io/tags/%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>Python进程——守护线程</title>
    <link href="http://gavinliu4011.github.io/post/5965383b.html"/>
    <id>http://gavinliu4011.github.io/post/5965383b.html</id>
    <published>2018-03-05T22:44:26.000Z</published>
    <updated>2018-03-08T15:19:50.849Z</updated>
    
    <content type="html"><![CDATA[<h3 id="守护进程"><a href="#守护进程" class="headerlink" title="守护进程"></a>守护进程</h3><p>在上一遍文章中我们已经介绍了创建线程，对线程也有一些了解，现在一起来看看守护进程。</p><blockquote><p><strong>无论是进程还是线程，都遵循：守护xx会等待主xx运行完毕后被销毁。需要强调的是：运行完毕并非终止运行</strong> </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- 主进程在其代码结束后就已经算运行完毕了（守护进程在此时就被回收）,然后主进程会一直等非守护的子进程都运行完毕后回收子进程的资源(否则会产生僵尸进程)，才会结束。</span><br><span class="line">- 主线程在其他非守护线程运行完毕后才算运行完毕（守护线程在此时就被回收）。因为主线程的结束意味着进程的结束，进程整体的资源都将被回收，而进程必须保证非守护线程都运行完毕后才能结束。</span><br></pre></td></tr></table></figure><p>举个例，设置一个主人，在设置几个仆人，这几个仆人都是为主人服务的。可以帮主人做很多事情，一个主人（主线程）可以有多个仆人（守护线程），服务的前提是，主线程必须存在，如果主线程不存在，则守护进程也没了。那守护进程是干嘛的呢？可以管理一些资源，打开一些文件，监听一些端口，监听一些资源，把一些垃圾资源回收，可以干很多事情，可以随便定义。 </p><h4 id="守护线程设置"><a href="#守护线程设置" class="headerlink" title="守护线程设置"></a>守护线程设置</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(n)</span>:</span></span><br><span class="line">    print(<span class="string">'task:'</span>, n)</span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    print(<span class="string">'task done'</span>, n)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">start_time = time.time()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">    t = threading.Thread(target=run, args=(<span class="string">'t-&#123;0&#125;'</span>.format(i),))</span><br><span class="line">    t.setDaemon(<span class="keyword">True</span>)  <span class="comment"># Daemon意思是守护进程，这边是把当前线程设置为守护线程</span></span><br><span class="line">    t.start()</span><br><span class="line"></span><br><span class="line">print(<span class="string">"所有线程已经完成"</span>)</span><br><span class="line">print(<span class="string">'cost:'</span>, time.time() - start_time)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行结果</span></span><br><span class="line">task: t<span class="number">-0</span></span><br><span class="line">task: t<span class="number">-1</span></span><br><span class="line">task: t<span class="number">-2</span></span><br><span class="line">task: t<span class="number">-3</span></span><br><span class="line">task: t<span class="number">-4</span></span><br><span class="line">所有线程已经完成</span><br><span class="line">cost: <span class="number">0.0019915103912353516</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>注意：</strong>守护进程一定要在start之前设置，start之后就不能设置了，之后设置会报错，所以必须在start之前设置</p></blockquote><h4 id="统计线程数-补充点"><a href="#统计线程数-补充点" class="headerlink" title="统计线程数(补充点)"></a>统计线程数(补充点)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading, time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(n)</span>:</span></span><br><span class="line">    print(<span class="string">'task:'</span>, n)</span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    print(<span class="string">'task done'</span>, n, threading.current_thread())  <span class="comment"># 查看每个子线程</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">start_time = time.time()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">    t = threading.Thread(target=run, args=(<span class="string">'t-&#123;0&#125;'</span>.format(i),))</span><br><span class="line">    t.start()</span><br><span class="line"></span><br><span class="line">print(<span class="string">'--------'</span>, threading.current_thread(), threading.active_count())  <span class="comment"># 查看主线程和当前活动的所有线程数</span></span><br><span class="line">print(<span class="string">'cost:'</span>, time.time() - start_time)</span><br></pre></td></tr></table></figure><p>上面例子是查看当前线程和统计活动线程个数，用<strong>theading.current_thead()</strong> <em>查看当前线程</em>；用<strong>theading.active_count()</strong>来统计<em>当前活动的线程数</em>，<strong>线程个数=子线程数+主线程数</strong> </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;守护进程&quot;&gt;&lt;a href=&quot;#守护进程&quot; class=&quot;headerlink&quot; title=&quot;守护进程&quot;&gt;&lt;/a&gt;守护进程&lt;/h3&gt;&lt;p&gt;在上一遍文章中我们已经介绍了创建线程，对线程也有一些了解，现在一起来看看守护进程。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;
      
    
    </summary>
    
      <category term="Python线程" scheme="http://gavinliu4011.github.io/categories/Python%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="Python" scheme="http://gavinliu4011.github.io/tags/Python/"/>
    
      <category term="守护线程" scheme="http://gavinliu4011.github.io/tags/%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Python之线程</title>
    <link href="http://gavinliu4011.github.io/post/c52e9d45.html"/>
    <id>http://gavinliu4011.github.io/post/c52e9d45.html</id>
    <published>2018-03-04T23:16:54.000Z</published>
    <updated>2018-03-08T15:19:50.832Z</updated>
    
    <content type="html"><![CDATA[<h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><ul><li>CPU上的执行单位，线程也是程序运行过程中的一个抽象。</li><li>一个进程下可以有多个线程。</li><li>主线程：操作系统中的每一个进程都会对应一个地址空间。每一个进程中都会默认有一个控制线程，主线程随着进程的创建而出现。所以一个进程中主线程存在就代表了这个进程的存在，当进程中的主线程结束的时候，操作系统就会将该进程回收</li></ul><h4 id="有了进程为什么还要线程"><a href="#有了进程为什么还要线程" class="headerlink" title="有了进程为什么还要线程?"></a>有了进程为什么还要线程?</h4><p>进程有很多优点，它提供了多道编程，让我们感觉我们每个人都拥有自己的CPU和其他资源，可以提高计算机的利用率。很多人就不理解了，既然进程这么优秀，为什么还要线程呢？其实，仔细观察就会发现进程还是有很多缺陷的，主要体现在两点上：</p><ul><li>进程只能在一个时间干一件事，如果想同时干两件事或多件事，进程就无能为力了。</li><li>进程在执行的过程中如果阻塞，例如等待输入，整个进程就会挂起，即使进程中有些工作不依赖于输入的数据，也将无法执行。</li></ul><p>例如，我们在使用qq聊天， qq做为一个独立进程如果同一时间只能干一件事，那他如何实现在同一时刻 即能监听键盘输入、又能监听其它人给你发的消息、同时还能把别人发的消息显示在屏幕上呢？你会说，操作系统不是有分时么？但是分时是指在不同进程间的分时， 即操作系统处理一会你的qq任务，又切换到word文档任务上了，每个cpu时间片分给你的qq程序时，事实上，你的qq还是同一时间只能干一件事情。</p><p>再直白一点， 一个操作系统就像是一个工厂，工厂里面有很多个生产车间，不同的车间生产不同的产品，每个车间就相当于一个进程，且你的工厂又穷，供电不足，同一时间只能给一个车间供电，为了能让所有车间都能同时生产，你的工厂的电工只能给不同的车间分时供电，但是轮到你的qq车间时，发现只有一个干活的工人，结果生产效率极低，为了解决这个问题，就需要多加几个工人，让几个人工人并行工作，这每个工人，就是线程！</p><h4 id="线程的特点"><a href="#线程的特点" class="headerlink" title="线程的特点"></a>线程的特点</h4><p>在多线程的操作系统中，通常是在一个进程中包括多个线程，每个线程都是作为利用CPU的基本单位，是花费最小开销的实体。线程具有以下属性。</p><p>　　1）轻型实体</p><p>　　线程中的实体基本上不拥有系统资源，只是有一点必不可少的、能保证独立运行的资源。</p><p>　　线程的实体包括程序、数据和TCB。线程是动态概念，它的动态特性由线程控制块TCB（Thread Control Block）描述。</p><p>​    2）独立调度和分派的基本单位。</p><p>　　在多线程OS中，线程是能独立运行的基本单位，因而也是独立调度和分派的基本单位。由于线程很“轻”，故线程的切换非常迅速且开销小（在同一进程中的）。</p><p>　　线程在同一进程中的各个线程，都可以共享该进程所拥有的资源，这首先表现在：所有线程都具有相同的进程id，这意味着，线程可以访问该进程的每一个内存资源；此外，还可以访问进程所拥有的已打开文件、定时器、信号量机构等。由于同一个进程内的线程共享内存和文件，所以线程之间互相通信不必调用内核。</p><p>　　4<em>）可并发执行。</em></p><p>　　<em>在一个进程中的多个线程之间，可以并发执行，甚至允许在一个进程中所有线程都能并发执行；同样，不同进程中的线程也能并发执行，充分利用和发挥了处理机与外围设备并行工作的能力。</em></p><blockquote><p>TCB包括以下信息：<br>（1）线程状态。<br>（2）当线程不运行时，被保存的现场资源。<br>（3）一组执行堆栈。<br>（4）存放每个线程的局部变量主存区。<br>（5）访问同一个进程中的主存和其它资源。<br>用于指示被执行指令序列的程序计数器、保留局部变量、少数状态参数和返回地址等的一组寄存器和堆栈。</p></blockquote><h4 id="进程和线程的区别"><a href="#进程和线程的区别" class="headerlink" title="进程和线程的区别"></a>进程和线程的区别</h4><ol><li>线程是共享内存空间的；进程的内存是独立的。</li><li>线程可以直接访问此进程中的数据部分；进程有他们独立拷贝自己父进程的数据部分，每个进程是独立的</li><li>同一进程的线程之间直接交流(直接交流涉及到数据共享，信息传递)；两个进程想通信，必须通过一个中间代理来实现。</li><li>创建一个新的线程很容易；创建新的进程需要对其父进程进行一次克隆。</li><li>一个线程可以控制和操作同一进程里的其他线程；但是进程只能操作子进程。</li><li>对主线程的修改，可能会影响到进程中其他线程的修改；对于一个父进程的修改不会影响其他子进程(只要不删除父进程即可)</li></ol><h5 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a><strong>疑问</strong></h5><p>进程和线程那个运行快？</p><p>它俩是没有可比性的，线程是寄生在进程中的，你问它俩谁快。说白了，就是问在问两个线程谁快。因为进程只是资源的集合，进程也是要起一个线程的，它俩没有可比性。</p><p>进程和线程那个启动快？</p><p>答案是：线程快。因为进程相当于在修一个屋子。线程只是一下把一个来过来就行了。进程是一堆资源的集合。它要去内存里面申请空间，它要各种各样的东西去跟OS去申请。但是启动起来一运行，它俩是一样的，因为进程也是通过线程来运行的。</p><h4 id="自己理解"><a href="#自己理解" class="headerlink" title="自己理解"></a>自己理解</h4><ol><li>线程是操作系统最小的调度单位，是一串指令的集合。</li><li>进程要操作CPU，必须先创建一个线程。</li><li>进程本身是不可以执行的，操作cpu是通过线程实现的，因为它是一堆执行，而进程是不具备执行概念的。就像一个屋子，屋子就是进程，但是屋子里面的每一个人就是线程，屋子就是内存空间。</li><li>单核CPU只能同时干一件事，但是为什么给我们的感觉是在干了很多件事？因为上线的切换，刚才也说了跟读书那个例子一样。因为CPU太快了，可以有N多次切换，其实它都是在排着队呐。</li><li>寄存器是存上下文关系的。</li><li>进程是通过PID来区分的，并不是通过进程名来区分的。进程里面的第一个线程就是主线程，父线程和子线程是相互独立的，只是父线程创建了子线程，父线程down了，子线程不会受到影响的。</li><li>主线程修改影响其他线程的行文，因为它们是共享数据的。</li></ol><h4 id="线程的创建Threading-Thread类"><a href="#线程的创建Threading-Thread类" class="headerlink" title="线程的创建Threading.Thread类"></a>线程的创建Threading.Thread类</h4><h5 id="线程的创建"><a href="#线程的创建" class="headerlink" title="线程的创建"></a>线程的创建</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sayhi</span><span class="params">(name)</span>:</span></span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    print(<span class="string">'%s say hello'</span> %name)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    t=Thread(target=sayhi,args=(<span class="string">'egon'</span>,))</span><br><span class="line">    t.start()</span><br><span class="line">    print(<span class="string">'主线程'</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sayhi</span><span class="params">(Thread)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,name)</span>:</span></span><br><span class="line">        super().__init__()</span><br><span class="line">        self.name=name</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        time.sleep(<span class="number">2</span>)</span><br><span class="line">        print(<span class="string">'%s say hello'</span> % self.name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    t = Sayhi(<span class="string">'egon'</span>)</span><br><span class="line">    t.start()</span><br><span class="line">    print(<span class="string">'主线程'</span>)</span><br></pre></td></tr></table></figure><h5 id="多线程与多进程"><a href="#多线程与多进程" class="headerlink" title="多线程与多进程"></a>多线程与多进程</h5><h6 id="pid的比较"><a href="#pid的比较" class="headerlink" title="pid的比较"></a>pid的比较</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">work</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'hello'</span>,os.getpid())</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment">#part1:在主进程下开启多个线程,每个线程都跟主进程的pid一样</span></span><br><span class="line">    t1=Thread(target=work)</span><br><span class="line">    t2=Thread(target=work)</span><br><span class="line">    t1.start()</span><br><span class="line">    t2.start()</span><br><span class="line">    print(<span class="string">'主线程/主进程pid'</span>,os.getpid())</span><br><span class="line"></span><br><span class="line">    <span class="comment">#part2:开多个进程,每个进程都有不同的pid</span></span><br><span class="line">    p1=Process(target=work)</span><br><span class="line">    p2=Process(target=work)</span><br><span class="line">    p1.start()</span><br><span class="line">    p2.start()</span><br><span class="line">    print(<span class="string">'主线程/主进程pid'</span>,os.getpid())</span><br></pre></td></tr></table></figure><h6 id="开启效率的较量"><a href="#开启效率的较量" class="headerlink" title="开启效率的较量"></a>开启效率的较量</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">work</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'hello'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment">#在主进程下开启线程</span></span><br><span class="line">    t=Thread(target=work)</span><br><span class="line">    t.start()</span><br><span class="line">    print(<span class="string">'主线程/主进程'</span>)</span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    打印结果:</span></span><br><span class="line"><span class="string">    hello</span></span><br><span class="line"><span class="string">    主线程/主进程</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#在主进程下开启子进程</span></span><br><span class="line">    t=Process(target=work)</span><br><span class="line">    t.start()</span><br><span class="line">    print(<span class="string">'主线程/主进程'</span>)</span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    打印结果:</span></span><br><span class="line"><span class="string">    主线程/主进程</span></span><br><span class="line"><span class="string">    hello</span></span><br><span class="line"><span class="string">    '''</span></span><br></pre></td></tr></table></figure><h6 id="内存数据的共享问题"><a href="#内存数据的共享问题" class="headerlink" title="内存数据的共享问题"></a>内存数据的共享问题</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span>  threading <span class="keyword">import</span> Thread</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">work</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> n</span><br><span class="line">    n=<span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment"># n=100</span></span><br><span class="line">    <span class="comment"># p=Process(target=work)</span></span><br><span class="line">    <span class="comment"># p.start()</span></span><br><span class="line">    <span class="comment"># p.join()</span></span><br><span class="line">    <span class="comment"># print('主',n) #毫无疑问子进程p已经将自己的全局的n改成了0,但改的仅仅是它自己的,查看父进程的n仍然为100</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    n=<span class="number">1</span></span><br><span class="line">    t=Thread(target=work)</span><br><span class="line">    t.start()</span><br><span class="line">    t.join()</span><br><span class="line">    print(<span class="string">'主'</span>,n) <span class="comment">#查看结果为0,因为同一进程内的线程之间共享进程内的数据</span></span><br></pre></td></tr></table></figure><p>上面的例子中最多只启动了一个2个线程，还是用那种古老的方式t1,t2。要是一下子起10个或者100个线程，这种方式就不适用了，其实可以在启动线程的时候，把它加到循环里面去，并且来计算一下它的时间 ：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading,time</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(n)</span>:</span>   <span class="comment">#这边的run方法的名字是自行定义的，跟继承式多线程不一样，那个是强制的</span></span><br><span class="line">    print(<span class="string">"task:"</span>,n)</span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    print(<span class="string">"task done"</span>,n)</span><br><span class="line">  </span><br><span class="line">start_time = time.time()  <span class="comment">#开始时间</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):   <span class="comment">#一次性启动5个线程</span></span><br><span class="line">    t = threading.Thread(target=run,args=(<span class="string">"t-&#123;0&#125;"</span>.format(i),))</span><br><span class="line">    t.start()</span><br><span class="line">  </span><br><span class="line">print(<span class="string">"--------all thead has finished"</span>)</span><br><span class="line">print(<span class="string">"cost:"</span>,time.time()-start_time)  <span class="comment">#计算总耗时</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">#执行结果</span></span><br><span class="line">task: t<span class="number">-0</span></span><br><span class="line">task: t<span class="number">-1</span></span><br><span class="line">task: t<span class="number">-2</span></span><br><span class="line">task: t<span class="number">-3</span></span><br><span class="line">task: t<span class="number">-4</span></span><br><span class="line">--------all thead has finished</span><br><span class="line">cost: <span class="number">0.00096893310546875</span></span><br><span class="line">task done t<span class="number">-1</span></span><br><span class="line">task done t<span class="number">-2</span></span><br><span class="line">task done t<span class="number">-0</span></span><br><span class="line">task done t<span class="number">-4</span></span><br><span class="line">task done t<span class="number">-3</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>这里设置成启动5个线程，并且计算一下时间。这里有个疑问，为什么不启动1000个线程或者更多一点的线程？这是因为：计算机是4核的，它能干的事情，就是4个任务。启动的线程越多，就代表着要在这个很多线程之间进行上下文切换。相当于教室里有一本书，某个人只看了半页，因为cpu要确保每个人都能执行，也就是这本是要确保教室每个同学都能看到，那就相当于每个人看书的时间非常少。也就是说某个同学刚刚把这本书拿过来，一下子又被第二个人，第三个人拿走了。所以就导致所有的人都慢了，所以说如果线程启动1000就没有意义了，导致机器越来越慢，所以要适当设置</strong> </p></blockquote><p>从上面的程序发现，就是我主线程没有等其他的子线程执行完毕，就直接往下执行了，这是为什么呢？而且这个计算的时间根本不是我们想要的时间，中间的sleep 2秒哪里去了?</p><p>其实一个程序至少有一个线程，那先往下走的，没有等的就是主线程，主线程启动了子线程之后，子线程就是独立的，跟主线程就没有关系了。主线程和它启动的子线程是并行关系，这就解释了为什么我的主线程启动子线程之后，没有等子线程，而继续往下走了。所以计算不出来线程总共耗时时间，因为程序已经不是串行的了。程序本身就是一个线程，就是主线程。如果要想测试这五个线程总共花了多长时间，就需要用到线程的join()方法</p><h5 id="join"><a href="#join" class="headerlink" title="join"></a>join</h5><p><img src="..\img\thread\2062170187.png" alt=""></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span><span class="params">(threading.Thread)</span>:</span>  <span class="comment"># 继承threading.Thread</span></span><br><span class="line">    <span class="string">"""继承式多线程"""</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, n, sleep_time)</span>:</span>  <span class="comment"># 增加时间属性</span></span><br><span class="line">        threading.Thread.__init__(self)  <span class="comment"># 也可以写成这样super(MyThread,self).__init__()</span></span><br><span class="line">        self.n = n</span><br><span class="line">        self.sleep_time = sleep_time</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span>  <span class="comment"># 重写run方法</span></span><br><span class="line">        print(<span class="string">'run task'</span>, self.n)</span><br><span class="line">        time.sleep(self.sleep_time)  <span class="comment"># 每个线程可以传入不不同的时间</span></span><br><span class="line">        print(<span class="string">'task done,'</span>, self.n)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">t1 = MyThread(<span class="string">'t1'</span>, <span class="number">2</span>)  <span class="comment"># 实例化</span></span><br><span class="line">t2 = MyThread(<span class="string">'t2'</span>, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">t1.start()  <span class="comment"># 启动一个多线程</span></span><br><span class="line">t2.start()</span><br><span class="line"></span><br><span class="line">t1.join()  <span class="comment"># 把t1.join()放在线程启动之后</span></span><br><span class="line">print(<span class="string">"main thread....."</span>)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">#执行结果</span></span><br><span class="line">run task t1</span><br><span class="line">run task t2</span><br><span class="line">task done, t1</span><br><span class="line">main thread.....</span><br><span class="line">task done, t2</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意：</strong>t1.join() 只等t1的结果，然后主线程继续往下走，因为t2需要等4秒，所以，最后打出来的是t2的执行结果。t1的结果到了，就立刻算结果。这边只计算了t1的结果，没有t2的结果 </p></blockquote><p>那我们怎么计算多个线程的执行时间呢？来我们一起看一下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(n)</span>:</span>  <span class="comment"># 这边的run方法的名字是自行定义的，跟继承式多线程不一样，那个是强制的</span></span><br><span class="line">    print(<span class="string">'task:'</span>, n)</span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    print(<span class="string">'task done'</span>, n)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">start_time = time.time()  <span class="comment"># 开始时间</span></span><br><span class="line">t_obj = []  <span class="comment"># 存放子线程实例</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):  <span class="comment"># 一次性启动10个线程</span></span><br><span class="line">    t = threading.Thread(target=run, args=(<span class="string">'t-&#123;0&#125;'</span>.format(i),))</span><br><span class="line">    t.start()</span><br><span class="line">    t_obj.append(t)  <span class="comment"># 为了不阻塞后面线程的启动，不在这里join，先放到一个列表中</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> t <span class="keyword">in</span> t_obj:  <span class="comment"># 循环线程实例列表，等待所有线程执行完毕</span></span><br><span class="line">    t.join()</span><br><span class="line"></span><br><span class="line">print(<span class="string">'所有线程已经完成'</span>)</span><br><span class="line">print(<span class="string">'cost:'</span>, time.time() - start_time)  <span class="comment"># 计算总耗时</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 执行结果</span></span><br><span class="line">task: t<span class="number">-0</span></span><br><span class="line">task: t<span class="number">-1</span></span><br><span class="line">task: t<span class="number">-2</span></span><br><span class="line">task: t<span class="number">-3</span></span><br><span class="line">task: t<span class="number">-4</span></span><br><span class="line">task: t<span class="number">-5</span></span><br><span class="line">task: t<span class="number">-6</span></span><br><span class="line">task: t<span class="number">-7</span></span><br><span class="line">task: t<span class="number">-8</span></span><br><span class="line">task: t<span class="number">-9</span></span><br><span class="line">task done t<span class="number">-0</span></span><br><span class="line">task done t<span class="number">-1</span></span><br><span class="line">task done t<span class="number">-2</span></span><br><span class="line">task done t<span class="number">-4</span></span><br><span class="line">task done t<span class="number">-3</span></span><br><span class="line">task done t<span class="number">-5</span></span><br><span class="line">task done t<span class="number">-6</span></span><br><span class="line">task done t<span class="number">-9</span></span><br><span class="line">task done t<span class="number">-7</span></span><br><span class="line">task done t<span class="number">-8</span></span><br><span class="line">所有线程已经完成</span><br><span class="line">cost: <span class="number">2.007737159729004</span></span><br></pre></td></tr></table></figure><p>上面的例子在不加join的时候，主线程和子线程完全是并行的，没有了依赖关系，主线程执行了，子线程也执行了。但是加了join之后，主线程依赖子线程执行完毕才往下走。 下面将介绍守护线程</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;线程&quot;&gt;&lt;a href=&quot;#线程&quot; class=&quot;headerlink&quot; title=&quot;线程&quot;&gt;&lt;/a&gt;线程&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;CPU上的执行单位，线程也是程序运行过程中的一个抽象。&lt;/li&gt;
&lt;li&gt;一个进程下可以有多个线程。&lt;/li&gt;
&lt;li&gt;主线程：
      
    
    </summary>
    
      <category term="Python线程" scheme="http://gavinliu4011.github.io/categories/Python%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="Python" scheme="http://gavinliu4011.github.io/tags/Python/"/>
    
      <category term="线程" scheme="http://gavinliu4011.github.io/tags/%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>用Python操作Redis</title>
    <link href="http://gavinliu4011.github.io/post/9f312a12.html"/>
    <id>http://gavinliu4011.github.io/post/9f312a12.html</id>
    <published>2018-02-11T18:02:32.000Z</published>
    <updated>2018-02-11T10:02:43.090Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Redis安装和使用"><a href="#Redis安装和使用" class="headerlink" title="Redis安装和使用"></a>Redis安装和使用</h3><h4 id="Window-下安装"><a href="#Window-下安装" class="headerlink" title="Window 下安装"></a>Window 下安装</h4><p><strong>下载地址：</strong><a href="https://github.com/MSOpenTech/redis/releases" target="_blank" rel="noopener">https://github.com/MSOpenTech/redis/releases</a>。</p><p>Redis 支持 32 位和 64 位。这个需要根据你系统平台的实际情况选择，这里我们下载 <strong>Redis-x64-xxx.zip</strong>压缩包到 C 盘，解压后，将文件夹重新命名为 <strong>redis</strong>。</p><p><img src="http://www.runoob.com/wp-content/uploads/2014/11/3B8D633F-14CE-42E3-B174-FCCD48B11FF3.jpg" alt="img"></p><p>打开一个 <strong>cmd</strong> 窗口 使用cd命令切换目录到 <strong>C:\redis</strong> 运行 <strong>redis-server.exe redis.windows.conf</strong> 。</p><p>如果想方便的话，可以把 redis 的路径加到系统的环境变量里，这样就省得再输路径了，后面的那个 redis.windows.conf 可以省略，如果省略，会启用默认的。输入之后，会显示如下界面：</p><p>这时候另启一个cmd窗口，原来的不要关闭，不然就无法访问服务端了。</p><p>切换到redis目录下运行 <strong>redis-cli.exe -h 127.0.0.1 -p 6379</strong> 。</p><p>设置键值对 <strong>set myKey abc</strong></p><p>取出键值对 <strong>get myKey</strong></p><p><img src="http://www.runoob.com/wp-content/uploads/2014/11/redis-install2.jpg" alt="Redis 安装"></p><hr><h4 id="Linux-下安装"><a href="#Linux-下安装" class="headerlink" title="Linux 下安装"></a>Linux 下安装</h4><p><strong>下载地址：</strong><a href="http://redis.io/download" target="_blank" rel="noopener">http://redis.io/download</a>，下载最新稳定版本。</p><p>本文档使用3.2.11,下载并安装:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ wget http://download.redis.io/releases/redis-3.2.11.tar.gz</span><br><span class="line">$ tar -xvf redis-3.2.11.tar.gz</span><br><span class="line">$ <span class="built_in">cd</span> redis-3.2.11</span><br><span class="line">$ make &amp;&amp; make install</span><br></pre></td></tr></table></figure><p>安装完成后,我们先改一下redis.conf的配置:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ cp redis.conf ../myredis.conf <span class="comment"># 将文件redis.conf复制到上以及文件夹下并命名为myredis.conf</span></span><br><span class="line">$ <span class="built_in">cd</span> ..</span><br><span class="line">$ vim myredis.conf</span><br><span class="line"><span class="comment"># redis.conf是一个默认的配置文件。我们可以根据需要使用自己的配置文件。</span></span><br><span class="line"><span class="comment"># 建议修改以下地方:</span></span><br><span class="line"><span class="comment"># 找到bind这个地方并修改成[bind 本机内网地址]</span></span><br><span class="line"><span class="comment"># 再找到requirepass这个地方,这里是修改redis的密码</span></span><br><span class="line"><span class="comment"># 完成上述操作后保存退出</span></span><br><span class="line">$ redis-server myredis.conf</span><br></pre></td></tr></table></figure><p>启动redis服务进程后，就可以使用测试客户端程序redis-cli和redis服务交互了,如:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ redis-cli -h host -p port</span><br><span class="line">$ auth [password] <span class="comment"># 这里输入的密码就是你上面设置的密码,如果没有则跳过此步骤</span></span><br><span class="line">redis 127.0.0.1:6379&gt; ping</span><br><span class="line">PONG</span><br><span class="line">$ redis-cli -h host -p port -a password <span class="comment"># 这个命令也能登录</span></span><br></pre></td></tr></table></figure><h4 id="用Python连接Redis"><a href="#用Python连接Redis" class="headerlink" title="用Python连接Redis"></a>用Python连接Redis</h4><p>当前在本地我已经安装了 Redis 并运行在 9736 端口，密码设置为 123456</p><p>用下面例子连接Redis进行测试:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> redis</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    config = &#123;</span><br><span class="line">        <span class="string">'host'</span>: <span class="string">'localhost'</span>,</span><br><span class="line">        <span class="string">'port'</span>: <span class="number">9736</span>,</span><br><span class="line">        <span class="string">'db'</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="string">'password'</span>: <span class="string">'123456'</span></span><br><span class="line">    &#125;</span><br><span class="line">    client = redis.Redis(**config)</span><br><span class="line">    <span class="keyword">if</span> client.ping():</span><br><span class="line">        client.set(<span class="string">'name'</span>, <span class="string">'gavinliu'</span>)</span><br><span class="line">        print(client.get(<span class="string">'name'</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>在这里我们使用redis.Redis传入参数连接本地Redis服务,传入的四个参数分别为<code>Redis的地址</code>、<code>运行端口</code>、<code>使用的数据库</code>、<code>密码</code>，我们这里使用的Redis其实是继承了StrictRedis，所以在默认情况下不传这四个参数时，参数值会有默认值分别为localhost、6379、0、None。</p><p>上面运行的结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">b'gavinliu'</span></span><br></pre></td></tr></table></figure><p>在Python中使用Redis其实很方便，Redis的命令(命令详细情况可以参照<a href="http://redisdoc.com/" target="_blank" rel="noopener">Redis命令参考</a>)在Python中都能找到相应的方法，这里引用<a href="https://cuiqingcai.com/" target="_blank" rel="noopener">崔庆才老师</a>对Redis总结介绍一下Key(键)、String(字符串)、Hash(哈希表)、List(列表)、Set(集合)、SortedSet(有序集合)</p><blockquote><p><strong>Key(键)</strong></p></blockquote><table><thead><tr><th>方法</th><th>作用</th><th>参数说明</th><th>示例</th><th>示例说明</th><th>示例结果</th></tr></thead><tbody><tr><td>exists(name)</td><td>判断一个key是否存在</td><td>name: key名</td><td>redis.exists(‘name’)</td><td>是否存在name这个key</td><td>True</td></tr><tr><td>delete(name)</td><td>删除一个key</td><td>name: key名</td><td>redis.delete(‘name’)</td><td>删除name这个key</td><td>1</td></tr><tr><td>type(name)</td><td>判断key类型</td><td>name: key名</td><td>redis.type(‘name’)</td><td>判断name这个key类型</td><td>b’string’</td></tr><tr><td>keys(pattern)</td><td>获取所有符合规则的key</td><td>pattern: 匹配规则</td><td>redis.keys(‘n*’)</td><td>获取所有以n开头的key</td><td>[b’name’]</td></tr><tr><td>randomkey()</td><td>获取随机的一个key</td><td></td><td>randomkey()</td><td>获取随机的一个key</td><td>b’name’</td></tr><tr><td>rename(src, dst)</td><td>将key重命名</td><td>src: 原key名 dst: 新key名</td><td>redis.rename(‘name’, ‘nickname’)</td><td>将name重命名为nickname</td><td>True</td></tr><tr><td>dbsize()</td><td>获取当前数据库中key的数目</td><td></td><td>dbsize()</td><td>获取当前数据库中key的数目</td><td>100</td></tr><tr><td>expire(name, time)</td><td>设定key的过期时间，单位秒</td><td>name: key名 time: 秒数</td><td>redis.expire(‘name’, 2)</td><td>将name这key的过期时间设置2秒</td><td>True</td></tr><tr><td>ttl(name)</td><td>获取key的过期时间，单位秒，-1为永久不过期</td><td>name: key名</td><td>redis.ttl(‘name’)</td><td>获取name这key的过期时间</td><td>-1</td></tr><tr><td>move(name, db)</td><td>将key移动到其他数据库</td><td>name: key名 db: 数据库代号</td><td>move(‘name’, 2)</td><td>将name移动到2号数据库</td><td>True</td></tr><tr><td>flushdb()</td><td>删除当前选择数据库中的所有key</td><td></td><td>flushdb()</td><td>删除当前选择数据库中的所有key</td><td>True</td></tr><tr><td>flushall()</td><td>删除所有数据库中的所有key</td><td></td><td>flushall()</td><td>删除所有数据库中的所有key</td><td>True</td></tr></tbody></table><blockquote><p><strong>String(字符串)</strong></p></blockquote><table><thead><tr><th>方法</th><th>作用</th><th>参数说明</th><th>示例</th><th>示例说明</th><th>示例结果</th></tr></thead><tbody><tr><td>set(name, value)</td><td>给数据库中key为name的string赋予值value</td><td>name: key名 value: 值</td><td>redis.set(‘name’, ‘Bob’)</td><td>给name这个key的value赋值为Bob</td><td>True</td></tr><tr><td>get(name)</td><td>返回数据库中key为name的string的value</td><td>name: key名</td><td>redis.get(‘name’)</td><td>返回name这个key的value</td><td>b’Bob’</td></tr><tr><td>getset(name, value)</td><td>给数据库中key为name的string赋予值value并返回上次的value</td><td>name: key名 value: 新值</td><td>redis.getset(‘name’, ‘Mike’)</td><td>赋值name为Mike并得到上次的value</td><td>b’Bob’</td></tr><tr><td>mget(keys, *args)</td><td>返回多个key对应的value</td><td>keys: key的列表</td><td>redis.mget([‘name’, ‘nickname’])</td><td>返回name和nickname的value</td><td>[b’Mike’, b’Miker’]</td></tr><tr><td>setnx(name, value)</td><td>如果key不存在才设置value</td><td>name: key名</td><td>redis.setnx(‘newname’, ‘James’)</td><td>如果newname这key不存在则设置值为James</td><td>第一次运行True，第二次False</td></tr><tr><td>setex(name, time, value)</td><td>设置可以对应的值为string类型的value，并指定此键值对应的有效期</td><td>name: key名 time: 有效期 value: 值</td><td>redis.setex(‘name’, 1, ‘James’)</td><td>将name这key的值设为James，有效期1秒</td><td>True</td></tr><tr><td>setrange(name, offset, value)</td><td>设置指定key的value值的子字符串</td><td>name: key名 offset: 偏移量 value: 值</td><td>redis.set(‘name’, ‘Hello’) redis.setrange(‘name’, 6, ‘World’)</td><td>设置name为Hello字符串，并在index为6的位置补World</td><td>11，修改后的字符串长度</td></tr><tr><td>mset(mapping)</td><td>批量赋值</td><td>mapping: 字典</td><td>redis.mset({‘name1’: ‘Durant’, ‘name2’: ‘James’})</td><td>将name1设为Durant，name2设为James</td><td>True</td></tr><tr><td>msetnx(mapping)</td><td>key均不存在时才批量赋值</td><td>mapping: 字典</td><td>redis.msetnx({‘name3’: ‘Smith’, ‘name4’: ‘Curry’})</td><td>在name3和name4均不存在的情况下才设置二者值</td><td>True</td></tr><tr><td>incr(name, amount=1)</td><td>key为name的value增值操作，默认1，key不存在则被创建并设为amount</td><td>name: key名 amount:增长的值</td><td>redis.incr(‘age’, 1)</td><td>age对应的值增1，若不存在则会创建并设置为1</td><td>1，即修改后的值</td></tr><tr><td>decr(name, amount=1)</td><td>key为name的value减值操作，默认1，key不存在则被创建并设置为-amount</td><td>name: key名 amount:减少的值</td><td>redis.decr(‘age’, 1)</td><td>age对应的值减1，若不存在则会创建并设置为-1</td><td>-1，即修改后的值</td></tr><tr><td>append(key, value)</td><td>key为name的string的值附加value</td><td>key: key名</td><td>redis.append(‘nickname’, ‘OK’)</td><td>向key为nickname的值后追加OK</td><td>13，即修改后的字符串长度</td></tr><tr><td>substr(name, start, end=-1)</td><td>返回key为name的string的value的子串</td><td>name: key名 start: 起始索引 end: 终止索引，默认-1截取到末尾</td><td>redis.substr(‘name’, 1, 4)</td><td>返回key为name的值的字符串，截取索引为1-4的字符</td><td>b’ello’</td></tr><tr><td>getrange(key, start, end)</td><td>获取key的value值从start到end的子字符串</td><td>key: key名 start: 起始索引 end: 终止索引</td><td>redis.getrange(‘name’, 1, 4)</td><td>返回key为name的值的字符串，截取索引为1-4的字符</td><td>b’ello’</td></tr></tbody></table><blockquote><p><strong>Hash(哈希表)</strong></p></blockquote><p>Hash，即哈希。Redis 还提供了哈希表的数据结构，我们可以用name指定一个哈希表的名称，然后表内存储了各个键值对，用法总结如下：</p><table><thead><tr><th>方法</th><th>作用</th><th>参数说明</th><th>示例</th><th>示例说明</th><th>示例结果</th></tr></thead><tbody><tr><td>hset(name, key, value)</td><td>向key为name的hash中添加映射</td><td>name: key名 key: 映射键名 value: 映射键值</td><td>hset(‘price’, ‘cake’, 5)</td><td>向key为price的hash中添加映射关系，cake的值为5</td><td>1，即添加的映射个数</td></tr><tr><td>hsetnx(name, key, value)</td><td>向key为name的hash中添加映射，如果映射键名不存在</td><td>name: key名 key: 映射键名 value: 映射键值</td><td>hsetnx(‘price’, ‘book’, 6)</td><td>向key为price的hash中添加映射关系，book的值为6</td><td>1，即添加的映射个数</td></tr><tr><td>hget(name, key)</td><td>返回key为name的hash中field对应的value</td><td>name: key名 key: 映射键名</td><td>redis.hget(‘price’, ‘cake’)</td><td>获取key为price的hash中键名为cake的value</td><td>5</td></tr><tr><td>hmget(name, keys, *args)</td><td>返回key为name的hash中各个键对应的value</td><td>name: key名 keys: 映射键名列表</td><td>redis.hmget(‘price’, [‘apple’, ‘orange’])</td><td>获取key为price的hash中apple和orange的值</td><td>[b’3’, b’7’]</td></tr><tr><td>hmset(name, mapping)</td><td>向key为name的hash中批量添加映射</td><td>name: key名 mapping: 映射字典</td><td>redis.hmset(‘price’, {‘banana’: 2, ‘pear’: 6})</td><td>向key为price的hash中批量添加映射</td><td>True</td></tr><tr><td>hincrby(name, key, amount=1)</td><td>将key为name的hash中映射的value增加amount</td><td>name: key名 key: 映射键名 amount: 增长量</td><td>redis.hincrby(‘price’, ‘apple’, 3)</td><td>key为price的hash中apple的值增加3</td><td>6，修改后的值</td></tr><tr><td>hexists(name, key)</td><td>key为namehash中是否存在键名为key的映射</td><td>name: key名 key: 映射键名</td><td>redis.hexists(‘price’, ‘banana’)</td><td>key为price的hash中banana的值是否存在</td><td>True</td></tr><tr><td>hdel(name, *keys)</td><td>key为namehash中删除键名为key的映射</td><td>name: key名 key: 映射键名</td><td>redis.hdel(‘price’, ‘banana’)</td><td>从key为price的hash中删除键名为banana的映射</td><td>True</td></tr><tr><td>hlen(name)</td><td>从key为name的hash中获取映射个数</td><td>name: key名</td><td>redis.hlen(‘price’)</td><td>从key为price的hash中获取映射个数</td><td>6</td></tr><tr><td>hkeys(name)</td><td>从key为name的hash中获取所有映射键名</td><td>name: key名</td><td>redis.hkeys(‘price’)</td><td>从key为price的hash中获取所有映射键名</td><td>[b’cake’, b’book’, b’banana’, b’pear’]</td></tr><tr><td>hvals(name)</td><td>从key为name的hash中获取所有映射键值</td><td>name: key名</td><td>redis.hvals(‘price’)</td><td>从key为price的hash中获取所有映射键值</td><td>[b’5’, b’6’, b’2’, b’6’]</td></tr><tr><td>hgetall(name)</td><td>从key为name的hash中获取所有映射键值对</td><td>name: key名</td><td>redis.hgetall(‘price’)</td><td>从key为price的hash中获取所有映射键值对</td><td>{b’cake’: b’5’, b’book’: b’6’, b’orange’: b’7’, b’pear’: b’6’}</td></tr></tbody></table><blockquote><p><strong>List(列表)</strong></p></blockquote><p>Redis 还提供了列表存储，列表内的元素可以重复，而且可以从两端存储</p><table><thead><tr><th>方法</th><th>作用</th><th>参数说明</th><th>示例</th><th>示例说明</th><th>示例结果</th></tr></thead><tbody><tr><td>rpush(name, *values)</td><td>在key为name的list尾添加值为value的元素，可以传多个</td><td>name: key名 values: 值</td><td>redis.rpush(‘list’, 1, 2, 3)</td><td>给list这个key的list尾添加1、2、3</td><td>3，list大小</td></tr><tr><td>lpush(name, *values)</td><td>在key为name的list头添加值为value的元素，可以传多个</td><td>name: key名 values: 值</td><td>redis.lpush(‘list’, 0)</td><td>给list这个key的list头添加0</td><td>4，list大小</td></tr><tr><td>llen(name)</td><td>返回key为name的list的长度</td><td>name: key名</td><td>redis.llen(‘list’)</td><td>返回key为list的列表的长度</td><td>4</td></tr><tr><td>lrange(name, start, end)</td><td>返回key为name的list中start至end之间的元素</td><td>name: key名 start: 起始索引 end: 终止索引</td><td>redis.lrange(‘list’, 1, 3)</td><td>返回起始为1终止为3的索引范围对应的list</td><td><code>[b&#39;3&#39;, b&#39;2&#39;, b&#39;1&#39;]</code></td></tr><tr><td>ltrim(name, start, end)</td><td>截取key为name的list，保留索引为start到end的内容</td><td>name:key名 start: 起始索引 end: 终止索引</td><td>ltrim(‘list’, 1, 3)</td><td>保留key为list的索引为1到3的元素</td><td>True</td></tr><tr><td>lindex(name, index)</td><td>返回key为name的list中index位置的元素</td><td>name: key名 index: 索引</td><td>redis.lindex(‘list’, 1)</td><td>返回key为list的列表index为1的元素</td><td>b’2’</td></tr><tr><td>lset(name, index, value)</td><td>给key为name的list中index位置的元素赋值，越界则报错</td><td>name: key名 index: 索引位置 value: 值</td><td>redis.lset(‘list’, 1, 5)</td><td>将key为list的list索引1位置赋值为5</td><td>True</td></tr><tr><td>lrem(name, count, value)</td><td>删除count个key的list中值为value的元素</td><td>name: key名 count: 删除个数 value: 值</td><td>redis.lrem(‘list’, 2, 3)</td><td>将key为list的列表删除2个3</td><td>1，即删除的个数</td></tr><tr><td>lpop(name)</td><td>返回并删除key为name的list中的首元素</td><td>name: key名</td><td>redis.lpop(‘list’)</td><td>返回并删除名为list的list第一个元素</td><td>b’5’</td></tr><tr><td>rpop(name)</td><td>返回并删除key为name的list中的尾元素</td><td>name: key名</td><td>redis.rpop(‘list’)</td><td>返回并删除名为list的list最后一个元素</td><td>b’2’</td></tr><tr><td>blpop(keys, timeout=0)</td><td>返回并删除名称为在keys中的list中的首元素，如果list为空，则会一直阻塞等待</td><td>keys: key列表 timeout: 超时等待时间，0为一直等待</td><td>redis.blpop(‘list’)</td><td>返回并删除名为list的list的第一个元素</td><td>[b’5’]</td></tr><tr><td>brpop(keys, timeout=0)</td><td>返回并删除key为name的list中的尾元素，如果list为空，则会一直阻塞等待</td><td>keys: key列表 timeout: 超时等待时间，0为一直等待</td><td>redis.brpop(‘list’)</td><td>返回并删除名为list的list的最后一个元素</td><td>[b’2’]</td></tr><tr><td>rpoplpush(src, dst)</td><td>返回并删除名称为src的list的尾元素，并将该元素添加到名称为dst的list的头部</td><td>src: 源list的key dst: 目标list的key</td><td>redis.rpoplpush(‘list’, ‘list2’)</td><td>将key为list的list尾元素删除并返回并将其添加到key为list2的list头部</td><td>b’2’</td></tr></tbody></table><blockquote><p><strong>Set(集合)</strong></p></blockquote><p>Redis 还提供了集合存储，集合中的元素都是不重复的</p><table><thead><tr><th>方法</th><th>作用</th><th>参数说明</th><th>示例</th><th>示例说明</th><th>示例结果</th></tr></thead><tbody><tr><td>sadd(name, *values)</td><td>向key为name的set中添加元素</td><td>name: key名 values: 值，可为多个</td><td>redis.sadd(‘tags’, ‘Book’, ‘Tea’, ‘Coffee’)</td><td>向key为tags的set中添加Book、Tea、Coffee三个内容</td><td>3，即插入的数据个数</td></tr><tr><td>srem(name, *values)</td><td>从key为name的set中删除元素</td><td>name: key名 values: 值，可为多个</td><td>redis.srem(‘tags’, ‘Book’)</td><td>从key为tags的set中删除Book</td><td>1，即删除的数据个数</td></tr><tr><td>spop(name)</td><td>随机返回并删除key为name的set中一个元素</td><td>name: key名</td><td>redis.spop(‘tags’)</td><td>从key为tags的set中随机删除并返回该元素</td><td>b’Tea’</td></tr><tr><td>smove(src, dst, value)</td><td>从src对应的set中移除元素并添加到dst对应的set中</td><td>src: 源set dst: 目标set value: 元素值</td><td>redis.smove(‘tags’, ‘tags2’, ‘Coffee’)</td><td>从key为tags的set中删除元素Coffee并添加到key为tags2的set</td><td>True</td></tr><tr><td>scard(name)</td><td>返回key为name的set的元素个数</td><td>name: key名</td><td>redis.scard(‘tags’)</td><td>获取key为tags的set中元素个数</td><td>3</td></tr><tr><td>sismember(name, value)</td><td>测试member是否是key为name的set的元素</td><td>name:key值</td><td>redis.sismember(‘tags’, ‘Book’)</td><td>判断Book是否为key为tags的set元素</td><td>True</td></tr><tr><td>sinter(keys, *args)</td><td>返回所有给定key的set的交集</td><td>keys: key列表</td><td>redis.sinter([‘tags’, ‘tags2’])</td><td>返回key为tags的set和key为tags2的set的交集</td><td>{b’Coffee’}</td></tr><tr><td>sinterstore(dest, keys, *args)</td><td>求交集并将交集保存到dest的集合</td><td>dest:结果集合 keys:key列表</td><td>redis.sinterstore(‘inttag’, [‘tags’, ‘tags2’])</td><td>求key为tags的set和key为tags2的set的交集并保存为inttag</td><td>1</td></tr><tr><td>sunion(keys, *args)</td><td>返回所有给定key的set的并集</td><td>keys: key列表</td><td>redis.sunion([‘tags’, ‘tags2’])</td><td>返回key为tags的set和key为tags2的set的并集</td><td>{b’Coffee’, b’Book’, b’Pen’}</td></tr><tr><td>sunionstore(dest, keys, *args)</td><td>求并集并将并集保存到dest的集合</td><td>dest:结果集合 keys:key列表</td><td>redis.sunionstore(‘inttag’, [‘tags’, ‘tags2’])</td><td>求key为tags的set和key为tags2的set的并集并保存为inttag</td><td>3</td></tr><tr><td>sdiff(keys, *args)</td><td>返回所有给定key的set的差集</td><td>keys: key列表</td><td>redis.sdiff([‘tags’, ‘tags2’])</td><td>返回key为tags的set和key为tags2的set的差集</td><td>{b’Book’, b’Pen’}</td></tr><tr><td>sdiffstore(dest, keys, *args)</td><td>求差集并将差集保存到dest的集合</td><td>dest:结果集合 keys:key列表</td><td>redis.sdiffstore(‘inttag’, [‘tags’, ‘tags2’])</td><td>求key为tags的set和key为tags2的set的差集并保存为inttag</td><td>3</td></tr><tr><td>smembers(name)</td><td>返回key为name的set的所有元素</td><td>name: key名</td><td>redis.smembers(‘tags’)</td><td>返回key为tags的set的所有元素</td><td>{b’Pen’, b’Book’, b’Coffee’}</td></tr><tr><td>srandmember(name)</td><td>随机返回key为name的set的一个元素，但不删除元素</td><td>name: key值</td><td>redis.srandmember(‘tags’)</td><td>随机返回key为tags的set的一个元素</td></tr></tbody></table><blockquote><p><strong>SortedSet(有序集合)</strong></p></blockquote><p>有序集合，它相比集合多了一个分数字段，利用它我们可以对集合中的数据进行排序</p><table><thead><tr><th>方法</th><th>作用</th><th>参数说明</th><th>示例</th><th>示例说明</th><th>示例结果</th></tr></thead><tbody><tr><td>zadd(name, <em>args, *</em>kwargs)</td><td>向key为name的zset中添加元素member，score用于排序。如果该元素存在，则更新其顺序</td><td>name: key名 args: 可变参数</td><td>redis.zadd(‘grade’, 100, ‘Bob’, 98, ‘Mike’)</td><td>向key为grade的zset中添加Bob，score为100，添加Mike，score为98</td><td>2，即添加的元素个数</td></tr><tr><td>zrem(name, *values)</td><td>删除key为name的zset中的元素</td><td>name: key名 values: 元素</td><td>redis.zrem(‘grade’, ‘Mike’)</td><td>从key为grade的zset中删除Mike</td><td>1，即删除的元素个数</td></tr><tr><td>zincrby(name, value, amount=1)</td><td>如果在key为name的zset中已经存在元素value，则该元素的score增加amount，否则向该集合中添加该元素，其score的值为amount</td><td>name: key名 value: 元素 amount: 增长的score值</td><td>redis.zincrby(‘grade’, ‘Bob’, -2)</td><td>key为grade的zset中Bob的score减2</td><td>98.0，即修改后的值</td></tr><tr><td>zrank(name, value)</td><td>返回key为name的zset中元素的排名（按score从小到大排序）即下标</td><td>name: key名 value: 元素值</td><td>redis.zrank(‘grade’, ‘Amy’)</td><td>得到key为grade的zset中Amy的排名</td><td>1</td></tr><tr><td>zrevrank(name, value)</td><td>返回key为name的zset中元素的倒数排名（按score从大到小排序）即下标</td><td>name: key名 value: 元素值</td><td>redis.zrevrank(‘grade’, ‘Amy’)</td><td>得到key为grade的zset中Amy的倒数排名</td><td>2</td></tr><tr><td>zrevrange(name, start, end, withscores=False)</td><td>返回key为name的zset（按score从大到小排序）中的index从start到end的所有元素</td><td>name: key值 start: 开始索引 end: 结束索引 withscores: 是否带score</td><td>redis.zrevrange(‘grade’, 0, 3)</td><td>返回key为grade的zset前四名元素</td><td>[b’Bob’, b’Mike’, b’Amy’, b’James’]</td></tr><tr><td>zrangebyscore(name, min, max, start=None, num=None, withscores=False)</td><td>返回key为name的zset中score在给定区间的元素</td><td>name:key名 min: 最低score max:最高score start: 起始索引 num: 个数 withscores: 是否带score</td><td>redis.zrangeby score(‘grade’, 80, 95)</td><td>返回key为grade的zset中score在80和95之间的元素</td><td>[b’Amy’, b’James’]</td></tr><tr><td>zcount(name, min, max)</td><td>返回key为name的zset中score在给定区间的数量</td><td>name:key名 min: 最低score max: 最高score</td><td>redis.zcount(‘grade’, 80, 95)</td><td>返回key为grade的zset中score在80到95的元素个数</td><td>2</td></tr><tr><td>zcard(name)</td><td>返回key为name的zset的元素个数</td><td>name: key名</td><td>redis.zcard(‘grade’)</td><td>获取key为grade的zset中元素个数</td><td>3</td></tr><tr><td>zremrangebyrank(name, min, max)</td><td>删除key为name的zset中排名在给定区间的元素</td><td>name:key名 min: 最低位次 max: 最高位次</td><td>redis.zremran gebyrank(‘grade’, 0, 0)</td><td>删除key为grade的zset中排名第一的元素</td><td>1，即删除的元素个数</td></tr><tr><td>zremrangebyscore(name, min, max)</td><td>删除key为name的zset中score在给定区间的元素</td><td>name:key名 min: 最低score max:最高score</td><td>redis.zremran gebyscore (‘grade’, 80, 90)</td><td>删除score在80到90之间的元素</td><td>1，即删除的元素个数</td></tr></tbody></table><blockquote><p>注意：上面代码中由于展示显示不完全，本人做了相应的处理，原本是一个方法名的可能方法名中间会出现空格</p></blockquote><p>以上便是用Python操作Redis的总结了，在后面的项目中会常用到Redis操作，所以我们还是需要掌握一些常用操作。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Redis安装和使用&quot;&gt;&lt;a href=&quot;#Redis安装和使用&quot; class=&quot;headerlink&quot; title=&quot;Redis安装和使用&quot;&gt;&lt;/a&gt;Redis安装和使用&lt;/h3&gt;&lt;h4 id=&quot;Window-下安装&quot;&gt;&lt;a href=&quot;#Window-下安装&quot;
      
    
    </summary>
    
      <category term="Redis" scheme="http://gavinliu4011.github.io/categories/Redis/"/>
    
    
      <category term="Redis" scheme="http://gavinliu4011.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Python进程池</title>
    <link href="http://gavinliu4011.github.io/post/d1bc6a63.html"/>
    <id>http://gavinliu4011.github.io/post/d1bc6a63.html</id>
    <published>2018-01-17T21:51:06.000Z</published>
    <updated>2018-01-17T13:51:44.114Z</updated>
    
    <content type="html"><![CDATA[<h3 id="进程池"><a href="#进程池" class="headerlink" title="进程池"></a>进程池</h3><p>为什么要有进程池?</p><p>在程序实际处理问题过程中，忙时会有成千上万的任务需要被执行，闲时可能只有零星任务。那么在成千上万个任务需要被执行的时候，我们就需要去创建成千上万个进程么？首先，创建进程需要消耗时间，销毁进程也需要消耗时间。第二即便开启了成千上万的进程，操作系统也不能让他们同时执行，这样反而会影响程序的效率。因此我们不能无限制的根据任务开启或者结束进程。那么我们要怎么做呢？</p><p>在这里，要给大家介绍一个进程池的概念，定义一个池子，在里面放上固定数量的进程，有需求来了，就拿一个池中的进程来处理任务，等到处理完毕，进程并不关闭，而是将进程再放回进程池中继续等待任务。如果有很多任务需要执行，池中的进程数量不够，任务就要等待之前的进程执行任务完毕归来，拿到空闲进程才能继续执行。也就是说，池中进程的数量是固定的，那么同一时间最多有固定数量的进程在运行。这样不会增加操作系统的调度难度，还节省了开闭进程的时间，也一定程度上能够实现并发效果。</p><h3 id="multiprocess-Pool模块"><a href="#multiprocess-Pool模块" class="headerlink" title="multiprocess.Pool模块"></a>multiprocess.Pool模块</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Pool([numprocess  [,initializer [, initargs]]]):创建进程池</span><br></pre></td></tr></table></figure><p>参数介绍 ：</p><ul><li>numprocess：要创建的进程数，如果省略，将默认使用cpu_count()的值</li><li>initializer：是每个工作进程启动时要执行的可调用对象，默认为None</li><li>initargs：是要传给initializer的参数组</li></ul><p>主要方法 ：</p><ul><li><p>p.apply(func [, args [, kwargs]]):在一个池工作进程中执行func(<em>args,*</em>kwargs),然后返回结果。</p><blockquote><p>注意：此操作并不会在所有池工作进程中并执行func函数。如果要通过不同参数并发地执行func函数，必须从不同线程调用p.apply()函数或者使用p.apply_async()</p></blockquote></li><li><p>p.apply_async(func [, args [, kwargs [, callback]]]):在一个池工作进程中执行func(<em>args,*</em>kwargs),然后返回结果。</p><blockquote><p>此方法的结果是AsyncResult类的实例，callback是可调用对象，接收输入参数。当func的结果变为可用时，将理解传递给callback。callback禁止执行任何阻塞操作，否则将接收其他异步操作中的结果。</p></blockquote></li><li><p>p.close():关闭进程池，防止进一步操作。如果所有操作持续挂起，它们将在工作进程终止前完成</p></li><li><p>P.jion():等待所有工作进程退出。此方法只能在close（）或teminate()之后调用</p></li></ul><p>其他方法：</p><p>​    方法apply_async()和map_async（）的返回值是AsyncResul的实例obj。实例具有以下方法</p><ul><li><ul><li>obj.get():返回结果，如果有必要则等待结果到达。timeout是可选的。如果在指定时间内还没有到达，将引发异常。如果远程操作中引发了异常，它将在调用此方法时再次被引发。</li><li>obj.ready():如果调用完成，返回True</li><li>obj.successful():如果调用完成且没有引发异常，返回True，如果在结果就绪之前调用此方法，引发异常</li><li>obj.wait([timeout]):等待结果变为可用</li><li>obj.terminate()：立即终止所有工作进程，同时不执行任何清理或结束任何挂起工作。如果p被垃圾回收，将自动调用此函数</li></ul></li></ul><h4 id="进程池的同步调用"><a href="#进程池的同步调用" class="headerlink" title="进程池的同步调用"></a>进程池的同步调用</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os,time</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">work</span><span class="params">(n)</span>:</span></span><br><span class="line">    print(<span class="string">'%s run'</span> %os.getpid())</span><br><span class="line">    time.sleep(<span class="number">3</span>)</span><br><span class="line">    <span class="keyword">return</span> n**<span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    p=Pool(<span class="number">3</span>)  <span class="comment"># 进程池中从无到有创建三个进程,以后一直是这三个进程在执行任务</span></span><br><span class="line">    res_l=[]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        res=p.apply(work,args=(i,))  <span class="comment"># 同步调用，直到本次任务执行完毕拿到res，等待任务work执行的过程中可能有阻塞也可能没有阻塞</span></span><br><span class="line">    <span class="comment"># 但不管该任务是否存在阻塞，同步调用都会在原地等着</span></span><br><span class="line">    print(res_l)</span><br></pre></td></tr></table></figure><h4 id="进程池的异步调用"><a href="#进程池的异步调用" class="headerlink" title="进程池的异步调用"></a>进程池的异步调用</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">work</span><span class="params">(n)</span>:</span></span><br><span class="line">    print(<span class="string">'%s run'</span> %os.getpid())</span><br><span class="line">    time.sleep(random.random())</span><br><span class="line">    <span class="keyword">return</span> n**<span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    p=Pool(<span class="number">3</span>)  <span class="comment"># 进程池中从无到有创建三个进程,以后一直是这三个进程在执行任务</span></span><br><span class="line">    res_l=[]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        res=p.apply_async(work,args=(i,))  <span class="comment"># 异步运行，根据进程池中有的进程数，每次最多3个子进程在异步执行</span></span><br><span class="line">                                           <span class="comment"># 返回结果之后，将结果放入列表，归还进程，之后再执行新的任务</span></span><br><span class="line">                                           <span class="comment"># 需要注意的是，进程池中的三个进程不会同时开启或者同时结束</span></span><br><span class="line">                                           <span class="comment"># 而是执行完一个就释放一个进程，这个进程就去接收新的任务。  </span></span><br><span class="line">        res_l.append(res)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 异步apply_async用法：如果使用异步提交的任务，主进程需要使用jion，等待进程池内任务都处理完，然后可以用get收集结果</span></span><br><span class="line">    <span class="comment"># 否则，主进程结束，进程池可能还没来得及执行，也就跟着一起结束了</span></span><br><span class="line">    p.close()</span><br><span class="line">    p.join()</span><br><span class="line">    <span class="keyword">for</span> res <span class="keyword">in</span> res_l:</span><br><span class="line">        print(res.get()) <span class="comment">#使用get来获取apply_aync的结果,如果是apply,则没有get方法,因为apply是同步执行,立刻获取结果,也根本无需get</span></span><br></pre></td></tr></table></figure><h4 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h4><p>需要回调函数的场景：进程池中任何一个任务一旦处理完了，就立即告知主进程：我好了额，你可以处理我的结果了。主进程则调用一个函数去处理该结果，该函数即回调函数</p><p>我们可以把耗时间（阻塞）的任务放到进程池中，然后指定回调函数（主进程负责执行），这样主进程在执行回调函数时就省去了I/O的过程，直接拿到的是任务的结果。</p><p>下面来看看实例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">from</span> urllib.request <span class="keyword">import</span> urlopen</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_page</span><span class="params">(url,pattern)</span>:</span></span><br><span class="line">    response=urlopen(url).read().decode(<span class="string">'utf-8'</span>)</span><br><span class="line">    <span class="keyword">return</span> pattern,response</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse_page</span><span class="params">(info)</span>:</span></span><br><span class="line">    pattern,page_content=info</span><br><span class="line">    res=re.findall(pattern,page_content)</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> res:</span><br><span class="line">        dic=&#123;</span><br><span class="line">            <span class="string">'index'</span>:item[<span class="number">0</span>].strip(),</span><br><span class="line">            <span class="string">'title'</span>:item[<span class="number">1</span>].strip(),</span><br><span class="line">            <span class="string">'actor'</span>:item[<span class="number">2</span>].strip(),</span><br><span class="line">            <span class="string">'time'</span>:item[<span class="number">3</span>].strip(),</span><br><span class="line">        &#125;</span><br><span class="line">        print(dic)</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    regex = <span class="string">r'&lt;dd&gt;.*?&lt;.*?class="board-index.*?&gt;(\d+)&lt;/i&gt;.*?title="(.*?)".*?class="movie-item-info".*?&lt;p class="star"&gt;(.*?)&lt;/p&gt;.*?&lt;p class="releasetime"&gt;(.*?)&lt;/p&gt;'</span></span><br><span class="line">    pattern1=re.compile(regex,re.S)</span><br><span class="line"></span><br><span class="line">    url_dic=&#123;</span><br><span class="line">        <span class="string">'http://maoyan.com/board/7'</span>:pattern1,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    p=Pool()</span><br><span class="line">    res_l=[]</span><br><span class="line">    <span class="keyword">for</span> url,pattern <span class="keyword">in</span> url_dic.items():</span><br><span class="line">        res=p.apply_async(get_page,args=(url,pattern),callback=parse_page)</span><br><span class="line">        res_l.append(res)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> res_l:</span><br><span class="line">        i.get()</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意：如果在主进程中等待进程池中所有任务都执行完毕后，再统一处理结果，则无需回调函数</strong> </p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;进程池&quot;&gt;&lt;a href=&quot;#进程池&quot; class=&quot;headerlink&quot; title=&quot;进程池&quot;&gt;&lt;/a&gt;进程池&lt;/h3&gt;&lt;p&gt;为什么要有进程池?&lt;/p&gt;
&lt;p&gt;在程序实际处理问题过程中，忙时会有成千上万的任务需要被执行，闲时可能只有零星任务。那么在成千上万个
      
    
    </summary>
    
      <category term="Python进程" scheme="http://gavinliu4011.github.io/categories/Python%E8%BF%9B%E7%A8%8B/"/>
    
    
      <category term="Python" scheme="http://gavinliu4011.github.io/tags/Python/"/>
    
      <category term="进程池" scheme="http://gavinliu4011.github.io/tags/%E8%BF%9B%E7%A8%8B%E6%B1%A0/"/>
    
  </entry>
  
  <entry>
    <title>Python进程间通信之队列</title>
    <link href="http://gavinliu4011.github.io/post/58b02bea.html"/>
    <id>http://gavinliu4011.github.io/post/58b02bea.html</id>
    <published>2018-01-16T22:17:34.000Z</published>
    <updated>2018-01-16T14:17:43.088Z</updated>
    
    <content type="html"><![CDATA[<h3 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h3><p>进程间通信有队列（multiprocess.Queue）和管道（multiprocess.Pipe），在这里只简单介绍队列</p><h4 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h4><h5 id="概念介绍"><a href="#概念介绍" class="headerlink" title="概念介绍"></a>概念介绍</h5><p>创建共享的进程队列，Queue是多进程安全的队列，可以使用Queue实现多进程之间的数据传递。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Queue([maxsize]) </span><br><span class="line">创建共享的进程队列。</span><br><span class="line">参数 ：maxsize是队列中允许的最大项数。如果省略此参数，则无大小限制。</span><br><span class="line">底层队列使用管道和锁定实现，另外，还需要运行支持线程以便队列中的数据传输到底层管道中</span><br></pre></td></tr></table></figure><p>方法介绍 ：</p><ul><li><p>q.get( [ block [ ,timeout ] ] ) </p><p>返回q中的一个项目。如果q为空，此方法将阻塞，直到队列中有项目可用为止。block用于控制阻塞行为，默认为True. 如果设置为False，将引发Queue.Empty异常（定义在Queue模块中）。timeout是可选超时时间，用在阻塞模式中。如果在制定的时间间隔内没有项目变为可用，将引发Queue.Empty异常。</p></li><li><p>q.get_nowait( ) </p><p>同q.get(False)方法。</p></li><li><p>q.put(item [, block [,timeout ] ] ) </p><p>将item放入队列。如果队列已满，此方法将阻塞至有空间可用为止。block控制阻塞行为，默认为True。如果设置为False，将引发Queue.Empty异常（定义在Queue库模块中）。timeout指定在阻塞模式中等待可用空间的时间长短。超时后将引发Queue.Full异常。</p></li><li><p>q.qsize() </p><p>返回队列中目前项目的正确数量。此函数的结果并不可靠，因为在返回结果和在稍后程序中使用结果之间，队列中可能添加或删除了项目。在某些系统上，此方法可能引发NotImplementedError异常。</p></li><li><p>q.empty() </p><p>如果调用此方法时 q为空，返回True。如果其他进程或线程正在往队列中添加项目，结果是不可靠的。也就是说，在返回和使用结果之间，队列中可能已经加入新的项目。</p></li><li><p>q.full() </p><p>如果q已满，返回为True. 由于线程的存在，结果也可能是不可靠的（参考q.empty（）方法）</p></li><li><p>q.close() </p><p>关闭队列，防止队列中加入更多数据。调用此方法时，后台线程将继续写入那些已入队列但尚未写入的数据，但将在此方法完成时马上关闭。如果q被垃圾收集，将自动调用此方法。关闭队列不会在队列使用者中生成任何类型的数据结束信号或异常。例如，如果某个使用者正被阻塞在get（）操作上，关闭生产者中的队列不会导致get（）方法返回错误。</p></li><li><p>q.cancel_join_thread() </p><p>不会再进程退出时自动连接后台线程。这可以防止join_thread()方法阻塞。</p></li><li><p>q.join_thread() </p><p>连接队列的后台线程。此方法用于在调用q.close()方法后，等待所有队列项被消耗。默认情况下，此方法由不是q的原始创建者的所有进程调用。调用q.cancel_join_thread()方法可以禁止这种行为。</p></li></ul><h5 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h5><ul><li><p>单看队列用法 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Queue</span><br><span class="line"></span><br><span class="line">q = Queue(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># put ,get ,put_nowait,get_nowait,full,empty</span></span><br><span class="line">q.put(<span class="number">3</span>)</span><br><span class="line">q.put(<span class="number">3</span>)</span><br><span class="line">q.put(<span class="number">3</span>)</span><br><span class="line"><span class="comment"># q.put(3)   # 如果队列已经满了，程序就会停在这里，等待数据被别人取走，再将数据放入队列。</span></span><br><span class="line"><span class="comment"># 如果队列中的数据一直不被取走，程序就会永远停在这里。</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    q.put_nowait(<span class="number">3</span>)  <span class="comment"># 可以使用put_nowait，如果队列满了不会阻塞，但是会因为队列满了而报错。</span></span><br><span class="line"><span class="keyword">except</span>:  <span class="comment"># 因此我们可以用一个try语句来处理这个错误。这样程序不会一直阻塞下去，但是会丢掉这个消息。</span></span><br><span class="line">    print(<span class="string">'队列已经满了'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 因此，我们再放入数据之前，可以先看一下队列的状态，如果已经满了，就不继续put了。</span></span><br><span class="line">print(q.full())  <span class="comment"># 满了</span></span><br><span class="line"></span><br><span class="line">print(q.get())</span><br><span class="line">print(q.get())</span><br><span class="line">print(q.get())</span><br><span class="line"><span class="comment"># print(q.get()) # 同put方法一样，如果队列已经空了，那么继续取就会出现阻塞。</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    q.get_nowait(<span class="number">3</span>)  <span class="comment"># 可以使用get_nowait，如果队列满了不会阻塞，但是会因为没取到值而报错。</span></span><br><span class="line"><span class="keyword">except</span>:  <span class="comment"># 因此我们可以用一个try语句来处理这个错误。这样程序不会一直阻塞下去。</span></span><br><span class="line">    print(<span class="string">'队列已经空了'</span>)</span><br><span class="line"></span><br><span class="line">print(q.empty())  <span class="comment"># 空了</span></span><br></pre></td></tr></table></figure></li></ul><p>上面这个例子还没有加入进程通信，只是先来看看队列为我们提供的方法，以及这些方法的使用和现象 </p><ul><li><p>子进程发送数据给父进程 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process, Queue</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(q)</span>:</span></span><br><span class="line">    q.put([time.asctime(), <span class="string">'from Eva'</span>, <span class="string">'hello'</span>])  <span class="comment"># 调用主函数中p进程传递过来的进程参数 put函数为向队列中添加一条数据。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    q = Queue()  <span class="comment"># 创建一个Queue对象</span></span><br><span class="line">    p = Process(target=func, args=(q,))  <span class="comment"># 创建一个进程</span></span><br><span class="line">    p.start()</span><br><span class="line">    print(q.get())</span><br><span class="line">    p.join()</span><br></pre></td></tr></table></figure></li></ul><p>上面是一个queue的简单应用，使用队列q对象调用get函数来取得队列中最先进入的数据 </p><ul><li><p>批量生产数据放入队列再批量获取结果 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process, Queue</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">consumer</span><span class="params">(q)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        res = q.get()</span><br><span class="line">        time.sleep(random.randint(<span class="number">1</span>, <span class="number">3</span>))</span><br><span class="line">        print(<span class="string">'%s 吃 %s'</span> % (os.getpid(), res))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">producer</span><span class="params">(q)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        time.sleep(random.randint(<span class="number">1</span>, <span class="number">3</span>))</span><br><span class="line">        res = <span class="string">'包子%s'</span> % i</span><br><span class="line">        q.put(res)</span><br><span class="line">        print(<span class="string">'%s 生产了 %s'</span> % (os.getpid(), res))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    q = Queue()</span><br><span class="line">    <span class="comment"># 生产者们:即厨师们</span></span><br><span class="line">    p1 = Process(target=producer, args=(q,))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 消费者们:即吃货们</span></span><br><span class="line">    c1 = Process(target=consumer, args=(q,))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 开始</span></span><br><span class="line">    p1.start()</span><br><span class="line">    c1.start()</span><br><span class="line">    print(<span class="string">'主'</span>)</span><br></pre></td></tr></table></figure><p><img src="..\img\process\20180629165826.png" alt=""></p></li></ul><p>问题来了，我们看结果主进程永远不会结束，原因是：生产者p在生产完后就结束了，但是消费者c在取空了q之后，则一直处于死循环中且卡在q.get()这一步。</p><p>在解决上面问题之前，这里引入一个<strong>生产者消费者模型</strong></p><h5 id="生产者消费者模型"><a href="#生产者消费者模型" class="headerlink" title="生产者消费者模型"></a>生产者消费者模型</h5><p><em>在并发编程中使用生产者和消费者模式能够解决绝大多数并发问题。该模式通过平衡生产线程和消费线程的工作能力来提高程序的整体处理数据的速度</em> </p><p><strong>为什么要使用生产者和消费者模式</strong></p><p><em>在线程世界里，生产者就是生产数据的线程，消费者就是消费数据的线程。在多线程开发当中，如果生产者处理速度很快，而消费者处理速度很慢，那么生产者就必须等待消费者处理完，才能继续生产数据。同样的道理，如果消费者的处理能力大于生产者，那么消费者就必须等待生产者。为了解决这个问题于是引入了生产者和消费者模式。</em></p><p><strong>什么是生产者消费者模式</strong></p><p><em>生产者消费者模式是通过一个容器来解决生产者和消费者的强耦合问题。生产者和消费者彼此之间不直接通讯，而通过阻塞队列来进行通讯，所以生产者生产完数据之后不用等待消费者处理，直接扔给阻塞队列，消费者不找生产者要数据，而是直接从阻塞队列里取，阻塞队列就相当于一个缓冲区，平衡了生产者和消费者的处理能力。</em></p><p>要解决上面产生的问题无非是让生产者在生产完毕后，往队列中再发一个结束信号，这样消费者在接收到结束信号后就可以break出死循环 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process, Queue</span><br><span class="line"><span class="keyword">import</span> time, random, os</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">consumer</span><span class="params">(q)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        res = q.get()</span><br><span class="line">        <span class="keyword">if</span> res <span class="keyword">is</span> <span class="keyword">None</span>: <span class="keyword">break</span>  <span class="comment"># 收到结束信号则结束</span></span><br><span class="line">        time.sleep(random.randint(<span class="number">1</span>, <span class="number">3</span>))</span><br><span class="line">        print(<span class="string">'%s 吃 %s'</span> % (os.getpid(), res))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">producer</span><span class="params">(q)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        time.sleep(random.randint(<span class="number">1</span>, <span class="number">3</span>))</span><br><span class="line">        res = <span class="string">'包子%s'</span> % i</span><br><span class="line">        q.put(res)</span><br><span class="line">        print(<span class="string">'%s 生产了 %s'</span> % (os.getpid(), res))</span><br><span class="line">    q.put(<span class="keyword">None</span>)  <span class="comment"># 发送结束信号</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    q = Queue()</span><br><span class="line">    <span class="comment"># 生产者们:即厨师们</span></span><br><span class="line">    p1 = Process(target=producer, args=(q,))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 消费者们:即吃货们</span></span><br><span class="line">    c1 = Process(target=consumer, args=(q,))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 开始</span></span><br><span class="line">    p1.start()</span><br><span class="line">    c1.start()</span><br><span class="line">    print(<span class="string">'主'</span>)</span><br></pre></td></tr></table></figure><blockquote><p>注意：结束信号None，不一定要由生产者发，主进程里同样可以发，但主进程需要等生产者结束后才应该发送该信号 </p></blockquote><p>下面再看看多个消费者的例子：有几个消费者就需要发送几次结束信号 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process, Queue</span><br><span class="line"><span class="keyword">import</span> time, random, os</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">consumer</span><span class="params">(q)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        res = q.get()</span><br><span class="line">        <span class="keyword">if</span> res <span class="keyword">is</span> <span class="keyword">None</span>: <span class="keyword">break</span>  <span class="comment"># 收到结束信号则结束</span></span><br><span class="line">        time.sleep(random.randint(<span class="number">1</span>, <span class="number">3</span>))</span><br><span class="line">        print(<span class="string">'%s 吃 %s'</span> % (os.getpid(), res))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">producer</span><span class="params">(name, q)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>):</span><br><span class="line">        time.sleep(random.randint(<span class="number">1</span>, <span class="number">3</span>))</span><br><span class="line">        res = <span class="string">'%s%s'</span> % (name, i)</span><br><span class="line">        q.put(res)</span><br><span class="line">        print(<span class="string">'%s 生产了 %s'</span> % (os.getpid(), res))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    q = Queue()</span><br><span class="line">    <span class="comment"># 生产者们:即厨师们</span></span><br><span class="line">    p1 = Process(target=producer, args=(<span class="string">'啤酒鸭'</span>, q))</span><br><span class="line">    p2 = Process(target=producer, args=(<span class="string">'烤鱼'</span>, q))</span><br><span class="line">    p3 = Process(target=producer, args=(<span class="string">'烧鸡'</span>, q))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 消费者们:即吃货们</span></span><br><span class="line">    c1 = Process(target=consumer, args=(q,))</span><br><span class="line">    c2 = Process(target=consumer, args=(q,))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 开始</span></span><br><span class="line">    p1.start()</span><br><span class="line">    p2.start()</span><br><span class="line">    p3.start()</span><br><span class="line">    c1.start()</span><br><span class="line">    c2.start()</span><br><span class="line"></span><br><span class="line">    p1.join()  <span class="comment"># 必须保证生产者全部生产完毕,才应该发送结束信号</span></span><br><span class="line">    p2.join()</span><br><span class="line">    p3.join()</span><br><span class="line">    q.put(<span class="keyword">None</span>)  <span class="comment"># 有几个消费者就应该发送几次结束信号None</span></span><br><span class="line">    q.put(<span class="keyword">None</span>)  <span class="comment"># 发送结束信号</span></span><br><span class="line">    print(<span class="string">'主'</span>)</span><br></pre></td></tr></table></figure><p>有没有发现上面的方法很low，有几个消费者就要发送几次结束信号，下面再优化一下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">JoinableQueue([maxsize])  </span><br><span class="line">创建可连接的共享进程队列，这就像是一个Queue对象，但队列允许项目的使用者通知生产者项目已经被成功处理。通知进程是使用共享的信号和条件变量来实现的。</span><br></pre></td></tr></table></figure><p>JoinableQueue的实例p除了与Queue对象相同的方法之外，还具有以下方法</p><p>方法介绍 ：</p><ul><li><p>q.task_done() </p><p>使用者使用此方法发出信号，表示q.get()返回的项目已经被处理。如果调用此方法的次数大于从队列中删除的项目数量，将引发ValueError异常。</p></li><li><p>q.join() </p><p>生产者将使用此方法进行阻塞，直到队列中所有项目均被处理。阻塞将持续到为队列中的每个项目均调用q.task_done()方法为止。 </p></li></ul><p>下面的例子说明如何建立永远运行的进程，使用和处理队列上的项目。生产者将项目放入队列，并等待它们被处理</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process, JoinableQueue</span><br><span class="line"><span class="keyword">import</span> time, random, os</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">consumer</span><span class="params">(q)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        res = q.get()</span><br><span class="line">        <span class="keyword">if</span> res <span class="keyword">is</span> <span class="keyword">None</span>: <span class="keyword">break</span>  <span class="comment"># 收到结束信号则结束</span></span><br><span class="line">        time.sleep(random.randint(<span class="number">1</span>, <span class="number">3</span>))</span><br><span class="line">        print(<span class="string">'%s 吃 %s'</span> % (os.getpid(), res))</span><br><span class="line">        q.task_done()  <span class="comment"># 向q.join()发送一次信号,证明一个数据已经被取走了</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">producer</span><span class="params">(name, q)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>):</span><br><span class="line">        time.sleep(random.randint(<span class="number">1</span>, <span class="number">3</span>))</span><br><span class="line">        res = <span class="string">'%s%s'</span> % (name, i)</span><br><span class="line">        q.put(res)</span><br><span class="line">        print(<span class="string">'%s 生产了 %s'</span> % (os.getpid(), res))</span><br><span class="line">    q.join()  <span class="comment"># 生产完毕，使用此方法进行阻塞，直到队列中所有项目均被处理</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    q = JoinableQueue()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 生产者们:即厨师们</span></span><br><span class="line">    p1 = Process(target=producer, args=(<span class="string">'啤酒鸭'</span>, q))</span><br><span class="line">    p2 = Process(target=producer, args=(<span class="string">'烤鱼'</span>, q))</span><br><span class="line">    p3 = Process(target=producer, args=(<span class="string">'烧鸡'</span>, q))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 消费者们:即吃货们</span></span><br><span class="line">    c1 = Process(target=consumer, args=(q,))</span><br><span class="line">    c2 = Process(target=consumer, args=(q,))</span><br><span class="line">    c1.daemon = <span class="keyword">True</span></span><br><span class="line">    c2.daemon = <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 开始</span></span><br><span class="line">    p_l = [p1, p2, p3, c1, c2]</span><br><span class="line">    <span class="keyword">for</span> p <span class="keyword">in</span> p_l:</span><br><span class="line">        p.start()</span><br><span class="line"></span><br><span class="line">    p1.join()  <span class="comment"># 必须保证生产者全部生产完毕,才应该发送结束信号</span></span><br><span class="line">    p2.join()</span><br><span class="line">    p3.join()</span><br><span class="line">    print(<span class="string">'主'</span>)</span><br><span class="line"><span class="comment"># p1,p2,p3结束了,证明c1,c2肯定全都收完了p1,p2,p3发到队列的数据</span></span><br><span class="line"><span class="comment"># 因而c1,c2也没有存在的价值了,不需要继续阻塞在进程中影响主进程了。应该随着主进程的结束而结束,所以设置成守护进程就可以了</span></span><br></pre></td></tr></table></figure><p>参考资料：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">http://www.cnblogs.com/Eva-J/articles/8253549.html</span><br><span class="line">http://www.cnblogs.com/linhaifeng/articles/6817679.html</span><br><span class="line">https://www.jianshu.com/p/1200fd49b583</span><br><span class="line">https://www.jianshu.com/p/aed6067eeac9</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;进程间通信&quot;&gt;&lt;a href=&quot;#进程间通信&quot; class=&quot;headerlink&quot; title=&quot;进程间通信&quot;&gt;&lt;/a&gt;进程间通信&lt;/h3&gt;&lt;p&gt;进程间通信有队列（multiprocess.Queue）和管道（multiprocess.Pipe），在这里只简单介
      
    
    </summary>
    
      <category term="Python进程" scheme="http://gavinliu4011.github.io/categories/Python%E8%BF%9B%E7%A8%8B/"/>
    
    
      <category term="Python" scheme="http://gavinliu4011.github.io/tags/Python/"/>
    
      <category term="队列" scheme="http://gavinliu4011.github.io/tags/%E9%98%9F%E5%88%97/"/>
    
      <category term="进程通信" scheme="http://gavinliu4011.github.io/tags/%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1/"/>
    
  </entry>
  
  <entry>
    <title>Python进程同步之锁</title>
    <link href="http://gavinliu4011.github.io/post/779a7de2.html"/>
    <id>http://gavinliu4011.github.io/post/779a7de2.html</id>
    <published>2018-01-15T21:43:49.000Z</published>
    <updated>2018-01-15T13:44:01.595Z</updated>
    
    <content type="html"><![CDATA[<h3 id="锁-——-multiprocess-Lock"><a href="#锁-——-multiprocess-Lock" class="headerlink" title="锁 —— multiprocess.Lock"></a>锁 —— multiprocess.Lock</h3><p>通过刚刚的学习，我们千方百计实现了程序的异步，让多个任务可以同时在几个进程中并发处理，他们之间的运行没有顺序，一旦开启也不受我们控制。尽管并发编程让我们能更加充分的利用IO资源，但是也给我们带来了新的问题。</p><p>当多个进程使用同一份数据资源的时候，就会引发数据安全或顺序混乱问题。</p><p>接下来我们以模拟抢票为例，来看看数据安全的重要性。 </p><p>先看看不使用锁保护的多进程同时抢购余票结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 文件ticket的内容为：&#123;"count":1&#125;</span></span><br><span class="line"><span class="comment"># 注意一定要用双引号，不然json无法识别</span></span><br><span class="line"><span class="comment"># 并发运行，效率高，但竞争写同一文件，数据写入错乱</span></span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process, Lock</span><br><span class="line"><span class="keyword">import</span> time, json</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">()</span>:</span></span><br><span class="line">    dic = json.load(open(<span class="string">'ticket'</span>))</span><br><span class="line">    print(<span class="string">'\033[31m剩余票数%s\033[0m'</span> % dic[<span class="string">'count'</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(i)</span>:</span></span><br><span class="line">    dic = json.load(open(<span class="string">'ticket'</span>))</span><br><span class="line">    time.sleep(<span class="number">0.1</span>)  <span class="comment"># 模拟读数据的网络延迟</span></span><br><span class="line">    <span class="keyword">if</span> dic[<span class="string">'count'</span>] &gt; <span class="number">0</span>:</span><br><span class="line">        dic[<span class="string">'count'</span>] -= <span class="number">1</span></span><br><span class="line">        time.sleep(<span class="number">0.2</span>)  <span class="comment"># 模拟写数据的网络延迟</span></span><br><span class="line">        json.dump(dic, open(<span class="string">'ticket'</span>, <span class="string">'w'</span>))</span><br><span class="line">        print(<span class="string">'\033[32m用户%s购票成功\033[0m'</span> % i)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task</span><span class="params">(i)</span>:</span></span><br><span class="line">    search()</span><br><span class="line">    get(i)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):  <span class="comment"># 模拟并发10个客户端抢票</span></span><br><span class="line">        p = Process(target=task, args=(i,))</span><br><span class="line">        p.start()</span><br></pre></td></tr></table></figure><p>想想上面代码中会有什么样的结果出现？是只有一个用户购票成功，还是多个用户，下面一起来看看结果：</p><p><img src="..\img\process\20180629162519.png" alt=""></p><p>为什么会出现这样的情况呢？明明只有一张票，怎么会被这么多人购买成功，这个就是数据安全问题！！！</p><p>下面来解决这个数据安全问题：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 文件ticket的内容为：&#123;"count":1&#125;</span></span><br><span class="line"><span class="comment"># 注意一定要用双引号，不然json无法识别</span></span><br><span class="line"><span class="comment"># 并发运行，效率高，但竞争写同一文件，数据写入错乱</span></span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process, Lock</span><br><span class="line"><span class="keyword">import</span> time, json</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">()</span>:</span></span><br><span class="line">    dic = json.load(open(<span class="string">'ticket'</span>))</span><br><span class="line">    print(<span class="string">'\033[31m剩余票数%s\033[0m'</span> % dic[<span class="string">'count'</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(i)</span>:</span></span><br><span class="line">    dic = json.load(open(<span class="string">'ticket'</span>))</span><br><span class="line">    time.sleep(<span class="number">0.1</span>)  <span class="comment"># 模拟读数据的网络延迟</span></span><br><span class="line">    <span class="keyword">if</span> dic[<span class="string">'count'</span>] &gt; <span class="number">0</span>:</span><br><span class="line">        dic[<span class="string">'count'</span>] -= <span class="number">1</span></span><br><span class="line">        time.sleep(<span class="number">0.2</span>)  <span class="comment"># 模拟写数据的网络延迟</span></span><br><span class="line">        json.dump(dic, open(<span class="string">'ticket'</span>, <span class="string">'w'</span>))</span><br><span class="line">        print(<span class="string">'\033[32m用户%s购票成功\033[0m'</span> % i)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task</span><span class="params">(i, lock)</span>:</span></span><br><span class="line">    search()</span><br><span class="line">    lock.acquire()  <span class="comment"># 获取钥匙</span></span><br><span class="line">    get(i)  <span class="comment"># 有钥匙后进入方法执行代码</span></span><br><span class="line">    lock.release()  <span class="comment"># 归还钥匙</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    lock = Lock()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):  <span class="comment"># 模拟并发10个客户端抢票</span></span><br><span class="line">        p = Process(target=task, args=(i, lock))</span><br><span class="line">        p.start()</span><br></pre></td></tr></table></figure><p>结果：</p><p><img src="..\img\process\20180629163404.png" alt=""></p><blockquote><p>加锁可以保证多个进程修改同一块数据时，同一时间只能有一个任务可以进行修改，即串行的修改，没错，速度是慢了，但牺牲了速度却保证了数据安全。<br>虽然可以用文件共享数据实现进程间通信，但问题是：<br>1、效率低（共享数据基于文件，而文件是硬盘上的数据）<br>2、需要自己加锁处理</p><p>因此我们最好找寻一种解决方案能够兼顾：</p><p>1、效率高（多个进程共享一块内存的数据）</p><p>2、帮我们处理好锁问题。这就是mutiprocessing模块为我们提供的基于消息的IPC通信机制：队列和管道。<br>队列和管道都是将数据存放于内存中<br>队列又是基于（管道+锁）实现的，可以让我们从复杂的锁问题中解脱出来，<br>我们应该尽量避免使用共享数据，尽可能使用消息传递和队列，避免处理复杂的同步和锁问题，而且在进程数目增多时，往往可以获得更好的可获展性。</p></blockquote><p>参考资料：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">http://www.cnblogs.com/Eva-J/articles/8253549.html</span><br><span class="line">http://www.cnblogs.com/linhaifeng/articles/6817679.html</span><br><span class="line">https://www.jianshu.com/p/1200fd49b583</span><br><span class="line">https://www.jianshu.com/p/aed6067eeac9</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;锁-——-multiprocess-Lock&quot;&gt;&lt;a href=&quot;#锁-——-multiprocess-Lock&quot; class=&quot;headerlink&quot; title=&quot;锁 —— multiprocess.Lock&quot;&gt;&lt;/a&gt;锁 —— multiprocess.Lo
      
    
    </summary>
    
      <category term="Python进程" scheme="http://gavinliu4011.github.io/categories/Python%E8%BF%9B%E7%A8%8B/"/>
    
    
      <category term="Python" scheme="http://gavinliu4011.github.io/tags/Python/"/>
    
      <category term="进程同步" scheme="http://gavinliu4011.github.io/tags/%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5/"/>
    
      <category term="进程锁" scheme="http://gavinliu4011.github.io/tags/%E8%BF%9B%E7%A8%8B%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>Python之进程</title>
    <link href="http://gavinliu4011.github.io/post/d3c89889.html"/>
    <id>http://gavinliu4011.github.io/post/d3c89889.html</id>
    <published>2018-01-14T11:09:46.000Z</published>
    <updated>2018-01-14T03:09:55.018Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是进程"><a href="#什么是进程" class="headerlink" title="什么是进程"></a>什么是进程</h3><p>进程（Process）是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是<a href="https://baike.baidu.com/item/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F" target="_blank" rel="noopener">操作系统</a>结构的基础。在早期面向进程设计的计算机结构中，进程是程序的基本执行实体；在当代面向线程设计的计算机结构中，进程是线程的容器。程序是指令、数据及其组织形式的描述，进程是程序的实体。</p><p>狭义定义：进程是正在运行的程序的实例（an instance of a computer program that is being executed）。</p><p>广义定义：进程是一个具有一定独立功能的程序关于某个数据集合的一次运行活动。它是<a href="https://baike.baidu.com/item/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/192" target="_blank" rel="noopener">操作系统</a>动态执行的<a href="https://baike.baidu.com/item/%E5%9F%BA%E6%9C%AC%E5%8D%95%E5%85%83" target="_blank" rel="noopener">基本单元</a>，在传统的<a href="https://baike.baidu.com/item/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F" target="_blank" rel="noopener">操作系统</a>中，进程既是基本的<a href="https://baike.baidu.com/item/%E5%88%86%E9%85%8D%E5%8D%95%E5%85%83" target="_blank" rel="noopener">分配单元</a>，也是基本的执行单元。</p><h4 id="进程的概念"><a href="#进程的概念" class="headerlink" title="进程的概念"></a>进程的概念</h4><p>第一，进程是一个实体。每一个进程都有它自己的地址空间，一般情况下，包括文本区域（text region）、数据区域（data region）和堆栈（stack region）。文本区域存储处理器执行的代码；数据区域存储变量和进程执行期间使用的动态分配的内存；堆栈区域存储着活动过程调用的指令和本地变量。<br>第二，进程是一个“执行中的程序”。程序是一个没有生命的实体，只有处理器赋予程序生命时（操作系统执行之），它才能成为一个活动的实体，我们称其为进程。<br>进程是操作系统中最基本、重要的概念。是多道程序系统出现后，为了刻画系统内部出现的动态情况，描述系统内部各道程序的活动规律引进的一个概念,所有多道程序设计操作系统都建立在进程的基础上。</p><h4 id="进程的特征"><a href="#进程的特征" class="headerlink" title="进程的特征"></a>进程的特征</h4><p>动态性：进程的实质是程序在多道程序系统中的一次执行过程，进程是动态产生，动态消亡的。<br>并发性：任何进程都可以同其他进程一起并发执行<br>独立性：进程是一个能独立运行的基本单位，同时也是系统分配资源和调度的独立单位；<br>异步性：由于进程间的相互制约，使进程具有执行的间断性，即进程按各自独立的、不可预知的速度向前推进<br>结构特征：进程由程序、数据和进程控制块三部分组成。<br>多个不同的进程可以包含相同的程序：一个程序在不同的数据集里就构成不同的进程，能得到不同的结果；但是执行过程中，程序不能发生改变。</p><h4 id="进程与程序中的区别"><a href="#进程与程序中的区别" class="headerlink" title="进程与程序中的区别"></a>进程与程序中的区别</h4><p>程序是指令和数据的有序集合，其本身没有任何运行的含义，是一个静态的概念。<br>而进程是程序在处理机上的一次执行过程，它是一个动态的概念。<br>程序可以作为一种软件资料长期存在，而进程是有一定生命期的。<br>程序是永久的，进程是暂时的。</p><blockquote><p><strong>注意：同一个程序执行两次，就会在操作系统中出现两个进程，所以我们可以同时运行一个软件，分别做不同的事情也不会混乱。</strong> </p></blockquote><h3 id="进程的并行与并发"><a href="#进程的并行与并发" class="headerlink" title="进程的并行与并发"></a>进程的并行与并发</h3><p><strong>并行</strong> : 并行是指两者同时执行，比如赛跑，两个人都在不停的往前跑；（资源够用，比如三个线程，四核的CPU ）</p><p><strong>并发</strong> : 并发是指资源有限的情况下，两者交替轮流使用资源，比如一段路(单核CPU资源)同时只能过一个人，A走一段后，让给B，B用完继续给A ，交替使用，目的是提高效率。</p><p><strong>区别</strong>:</p><ul><li><strong>并行</strong>是从微观上，也就是在一个精确的时间片刻，有不同的程序在执行，这就要求必须有多个处理器。</li><li><strong>并发</strong>是从宏观上，在一个时间段上可以看出是同时执行的，比如一个服务器同时处理多个session。</li></ul><h3 id="同步异步阻塞非阻塞"><a href="#同步异步阻塞非阻塞" class="headerlink" title="同步异步阻塞非阻塞"></a>同步异步阻塞非阻塞</h3><h4 id="状态介绍"><a href="#状态介绍" class="headerlink" title="状态介绍"></a>状态介绍</h4><p><img src="..\img\process\1120359184.png" alt=""></p><p>​    在了解其他概念之前，我们首先要了解进程的几个状态。在程序运行的过程中，由于被操作系统的调度算法控制，程序会进入几个状态：就绪，运行和阻塞。</p><p>　　（1）就绪(Ready)状态</p><p>　　当进程已分配到除CPU以外的所有必要的资源，只要获得处理机便可立即执行，这时的进程状态称为就绪状态。</p><p>　　（2）执行/运行（Running）状态当进程已获得处理机，其程序正在处理机上执行，此时的进程状态称为执行状态。</p><p>　　（3）阻塞(Blocked)状态正在执行的进程，由于等待某个事件发生而无法执行时，便放弃处理机而处于阻塞状态。引起进程阻塞的事件可有多种，例如，等待I/O完成、申请缓冲区不能满足、等待信件(信号)等。</p><p><img src="..\img\process\135915799.png" alt=""></p><h4 id="同步和异步"><a href="#同步和异步" class="headerlink" title="同步和异步"></a>同步和异步</h4><p>​    所谓同步就是一个任务的完成需要依赖另外一个任务时，只有等待被依赖的任务完成后，依赖的任务才能算完成，这是一种可靠的任务序列。<strong>要么成功都成功，失败都失败，两个任务的状态可以保持一致。</strong></p><p>​    所谓异步是不需要等待被依赖的任务完成，只是通知被依赖的任务要完成什么工作，依赖的任务也立即执行，只要自己完成了整个任务就算完成了。<strong>至于被依赖的任务最终是否真正完成，依赖它的任务无法确定</strong>，所以它是不可靠的任务序列。</p><p>​    比如我去银行办理业务，可能会有两种方式：<br>        第一种 ：选择排队等候；<br>        第二种 ：选择取一个小纸条上面有我的号码，等到排到我这一号时由柜台的人通知我轮到我去办理业务了；</p><p>​        第一种：前者(排队等候)就是同步等待消息通知，也就是我要一直在等待银行办理业务情况；</p><p>​        第二种：后者(等待别人通知)就是异步等待消息通知。在异步消息处理中，等待消息通知者(在这个例子中就是等待办理业务的人)往往注册一个回调机制，在所等待的事件被触发时由触发机制(在这里是柜台的人)通过某种机制(在这里是写在小纸条上的号码，喊号)找到等待该事件的人。</p><h4 id="阻塞与非阻塞"><a href="#阻塞与非阻塞" class="headerlink" title="阻塞与非阻塞"></a>阻塞与非阻塞</h4><p>​    阻塞和非阻塞这两个概念与程序（线程）等待消息通知(无所谓同步或者异步)时的状态有关。也就是说阻塞与非阻塞主要是程序（线程）等待消息通知时的状态角度来说的 </p><p>​    继续上面的那个例子，不论是排队还是使用号码等待通知，如果在这个等待的过程中，等待者除了等待消息通知之外不能做其它的事情，那么该机制就是阻塞的，表现在程序中,也就是该程序一直阻塞在该函数调用处不能继续往下执行。<br>相反，有的人喜欢在银行办理这些业务的时候一边打打电话发发短信一边等待，这样的状态就是非阻塞的，因为他(等待者)没有阻塞在这个消息通知上，而是一边做自己的事情一边等待。</p><blockquote><p>注意：同步非阻塞形式实际上是效率低下的，想象一下你一边打着电话一边还需要抬头看到底队伍排到你了没有。如果把打电话和观察排队的位置看成是程序的两个操作的话，这个程序需要在这两种不同的行为之间来回的切换，效率可想而知是低下的；而异步非阻塞形式却没有这样的问题，因为打电话是你(等待者)的事情，而通知你则是柜台(消息触发机制)的事情，程序没有在两种不同的操作中来回切换。</p></blockquote><h4 id="同步-异步与阻塞-非阻塞"><a href="#同步-异步与阻塞-非阻塞" class="headerlink" title="同步/异步与阻塞/非阻塞"></a>同步/异步与阻塞/非阻塞</h4><h5 id="同步阻塞形式"><a href="#同步阻塞形式" class="headerlink" title="同步阻塞形式"></a>同步阻塞形式</h5><p>​    效率最低。拿上面的例子来说，就是你专心排队，什么别的事都不做。 </p><h5 id="异步阻塞形式"><a href="#异步阻塞形式" class="headerlink" title="异步阻塞形式"></a>异步阻塞形式</h5><p>​    如果在银行等待办理业务的人<code>采用的是异步的方式去等待消息被触发（通知）</code>，也就是领了一张小纸条，假如在这段时间里他不能离开银行做其它的事情，那么很显然，这个人被阻塞在了这个等待的操作上面； <strong>异步操作是可以被阻塞住的，只不过它不是在处理消息时阻塞，而是在等待消息通知时被阻塞。</strong> </p><h5 id="同步非阻塞形式"><a href="#同步非阻塞形式" class="headerlink" title="同步非阻塞形式"></a>同步非阻塞形式</h5><p>​    实际上是效率低下的。</p><p>​    想象一下你一边打着电话一边还需要抬头看到底队伍排到你了没有，如果把打电话和观察排队的位置看成是程序的两个操作的话，<code>这个程序需要在这两种不同的行为之间来回的切换</code>，效率可想而知是低下的。</p><h5 id="异步非阻塞形式"><a href="#异步非阻塞形式" class="headerlink" title="异步非阻塞形式"></a>异步非阻塞形式</h5><p>​    效率更高，因为打电话是你(等待者)的事情，而通知你则是柜台(消息触发机制)的事情，<code>程序没有在两种不同的操作中来回切换</code>。</p><p>​    比如说，这个人突然发觉自己烟瘾犯了，需要出去抽根烟，于是他告诉大堂经理说，排到我这个号码的时候麻烦到外面通知我一下，那么他就没有被阻塞在这个等待的操作上面，自然这个就是异步+非阻塞的方式了。</p><p>很多人会把同步和阻塞混淆，是<code>因为很多时候同步操作会以阻塞的形式表现出来</code>，同样的，很多人也会把异步和非阻塞混淆，<code>因为异步操作一般都不会在真正的IO操作处被阻塞</code>。 </p><p>下面来看看在python程序中的进程操作:</p><h3 id="在python程序中的进程操作"><a href="#在python程序中的进程操作" class="headerlink" title="在python程序中的进程操作"></a>在python程序中的进程操作</h3><p>之前已经了解了很多进程相关的理论知识，了解进程是什么应该不再困难了，刚刚我们已经了解了，运行中的程序就是一个进程。所有的进程都是通过它的父进程来创建的。因此，运行起来的python程序也是一个进程，那么我们也可以在程序中再创建进程。多个进程可以实现并发效果，也就是说，当我们的程序中存在多个进程的时候，在某些时候，就会让程序的执行速度变快。以我们之前所学的知识，并不能实现创建进程这个功能，所以我们就需要借助python中强大的模块。 </p><h4 id="multiprocess模块"><a href="#multiprocess模块" class="headerlink" title="multiprocess模块"></a>multiprocess模块</h4><p>仔细说来，multiprocess不是一个模块而是python中一个操作、管理进程的包。 之所以叫multi是取自multiple的多功能的意思,在这个包中几乎包含了和进程有关的所有子模块。由于提供的子模块非常多，为了方便大家归类记忆，我将这部分大致分为四个部分：创建进程部分，进程同步部分，进程池部分，进程之间数据共享。 </p><h4 id="multiprocess-process模块"><a href="#multiprocess-process模块" class="headerlink" title="multiprocess.process模块"></a>multiprocess.process模块</h4><h5 id="process模块介绍"><a href="#process模块介绍" class="headerlink" title="process模块介绍"></a>process模块介绍</h5><p>process模块是一个创建进程的模块，借助这个模块，就可以完成进程的创建。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Process([group [, target [, name [, args [, kwargs]]]]])，由该类实例化得到的对象，表示一个子进程中的任务（尚未启动）</span><br><span class="line"></span><br><span class="line">强调：</span><br><span class="line">1. 需要使用关键字的方式来指定参数</span><br><span class="line">2. args指定的为传给target函数的位置参数，是一个元组形式，必须有逗号</span><br><span class="line"></span><br><span class="line">参数介绍：</span><br><span class="line">1. group参数未使用，值始终为None</span><br><span class="line">2. target表示调用对象，即子进程要执行的任务</span><br><span class="line">3. args表示调用对象的位置参数元组，args=(1,2,&apos;egon&apos;,)</span><br><span class="line">4. kwargs表示调用对象的字典,kwargs=&#123;&apos;name&apos;:&apos;egon&apos;,&apos;age&apos;:18&#125;</span><br><span class="line">5. name为子进程的名称</span><br></pre></td></tr></table></figure><p>方法介绍 :</p><ul><li>p.start()：启动进程，并调用该子进程中的p.run() </li><li>p.run():进程启动时运行的方法，正是它去调用target指定的函数，我们自定义类的类中一定要实现该方法  </li><li>p.terminate():强制终止进程p，不会进行任何清理操作，如果p创建了子进程，该子进程就成了僵尸进程，使用该方法需要特别小心这种情况。如果p还保存了一个锁那么也将不会被释放，进而导致死锁</li><li>p.is_alive():如果p仍然运行，返回True</li><li>p.join([timeout]):主线程等待p终止（强调：是主线程处于等的状态，而p是处于运行的状态）。timeout是可选的超时时间，需要强调的是，p.join只能join住start开启的进程，而不能join住run开启的进程</li></ul><p>属性介绍 :</p><ul><li>p.daemon：默认值为False，如果设为True，代表p为后台运行的守护进程，当p的父进程终止时，p也随之终止，并且设定为True后，p不能创建自己的新进程，必须在p.start()之前设置</li><li>p.name:进程的名称</li><li>p.pid：进程的pid</li><li>p.exitcode:进程在运行时为None、如果为–N，表示被信号N结束(了解即可)</li><li>p.authkey:进程的身份验证键,默认是由os.urandom()随机生成的32字符的字符串。这个键的用途是为涉及网络连接的底层进程间通信提供安全性，这类连接只有在具有相同的身份验证键时才能成功（了解即可）</li></ul><h5 id="使用process模块创建进程"><a href="#使用process模块创建进程" class="headerlink" title="使用process模块创建进程"></a>使用process模块创建进程</h5><p>在一个python进程中开启子进程，start方法和并发效果。 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(args1, args2)</span>:</span></span><br><span class="line">    print(args1, args2)</span><br><span class="line">    time.sleep(<span class="number">3</span>)</span><br><span class="line">    print(<span class="string">'子进程 :'</span>, os.getpid())</span><br><span class="line">    print(<span class="string">'子进程的父进程 :'</span>, os.getppid())</span><br><span class="line">    print(<span class="number">12345</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    p = Process(target=func, args=(<span class="string">'参数1'</span>, <span class="string">'参数2'</span>))  <span class="comment"># 注册</span></span><br><span class="line">    <span class="comment"># p是一个进程对象,还没有启动进程</span></span><br><span class="line">    p.start()  <span class="comment"># 开启了一个子进程</span></span><br><span class="line">    <span class="comment"># p.join()  # 是感知一个子进程的结束,将异步的程序改为同步</span></span><br><span class="line">    print(<span class="string">'我是父进程'</span>)</span><br><span class="line">    print(<span class="string">'*'</span> * <span class="number">10</span>)</span><br><span class="line">    print(<span class="string">'父进程 :'</span>, os.getpid())  <span class="comment"># 查看当前进程的进程号</span></span><br><span class="line">    print(<span class="string">'父进程的父进程 :'</span>, os.getppid())  <span class="comment"># 查看当前进程的父进程</span></span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="..\img\process\20180628141032.png" alt=""></p><p>上面是单个进程，那么多个进程同时运行又是怎么样的呢？一起来看看：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(filename, content)</span>:</span></span><br><span class="line">    print(filename)</span><br><span class="line">    <span class="keyword">with</span> open(filename, <span class="string">'w'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(content * <span class="number">10</span> * <span class="string">'*'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    p_list = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        p = Process(target=func, args=(<span class="string">'info%s'</span> % i, <span class="number">0</span>))</span><br><span class="line">        p_list.append(p)</span><br><span class="line">        p.start()</span><br></pre></td></tr></table></figure><p>这里同时启动了10个进程，并创建10文件向文件中写入内容，它们同时在10个进程中并发处理，但是它们之间的运行没有顺序 </p><p>运行结果：</p><p><img src="..\img\process\20180628162043.png" alt=""></p><p>那我们又怎么写入内容后查看这10个文件呢？这里我们再次用到join方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(filename, content)</span>:</span></span><br><span class="line">    print(filename)</span><br><span class="line">    <span class="keyword">with</span> open(filename, <span class="string">'w'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(content * <span class="number">10</span> * <span class="string">'*'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    p_list = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        p = Process(target=func, args=(<span class="string">'info%s'</span> % i, <span class="number">0</span>))</span><br><span class="line">        p_list.append(p)</span><br><span class="line">        p.start()</span><br><span class="line">    [p.join() <span class="keyword">for</span> p <span class="keyword">in</span> p_list]  <span class="comment"># 之前的所有进程必须在这里都执行完才能执行下面的代码</span></span><br><span class="line">    print([i <span class="keyword">for</span> i <span class="keyword">in</span> os.walk(<span class="string">r'C:\GavinLiu\projects\my_process'</span>)])</span><br></pre></td></tr></table></figure><p>除了上面这些开启进程的方法，还有一种以继承Process类的形式开启进程的方式 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyProcess</span><span class="params">(Process)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, arg1, arg2)</span>:</span></span><br><span class="line">        super().__init__()</span><br><span class="line">        self.arg1 = arg1</span><br><span class="line">        self.arg2 = arg2</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(self.pid)</span><br><span class="line">        print(self.name)</span><br><span class="line">        print(self.arg1)</span><br><span class="line">        print(self.arg2)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    p1 = MyProcess(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">    p1.start()  <span class="comment"># start会自动调用run</span></span><br><span class="line">    p2 = MyProcess(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">    p2.start()</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="..\img\process\20180628163308.png" alt=""></p><p>进程之间的数据隔离问题 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> n  <span class="comment"># 声明了一个全局变量</span></span><br><span class="line">    n = <span class="number">0</span>  <span class="comment"># 重新定义了一个n</span></span><br><span class="line">    print(<span class="string">'子进程: %s'</span> % os.getpid(), n)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    n = <span class="number">100</span></span><br><span class="line">    p = Process(target=func)</span><br><span class="line">    p.start()</span><br><span class="line">    p.join()</span><br><span class="line">    print(<span class="string">'父进程: '</span>, os.getpid(), n)</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="..\img\process\20180628163825.png" alt=""></p><h5 id="守护进程"><a href="#守护进程" class="headerlink" title="守护进程"></a>守护进程</h5><p>主进程创建守护进程</p><p>　　其一：守护进程会在主进程代码执行结束后就终止</p><p>　　其二：守护进程内无法再开启子进程,否则抛出异常：AssertionError: daemonic processes are not allowed to have children</p><blockquote><p>注意：进程之间是互相独立的，主进程代码运行结束，守护进程随即终止</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Myprocess</span><span class="params">(Process)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, person)</span>:</span></span><br><span class="line">        super().__init__()</span><br><span class="line">        self.person = person</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(os.getpid(), self.name)</span><br><span class="line">        print(<span class="string">'%s正在和女主播聊天'</span> % self.person)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    p = Myprocess(<span class="string">'少林'</span>)</span><br><span class="line">    p.daemon = <span class="keyword">True</span>  <span class="comment"># 一定要在p.start()前设置,设置p为守护进程,禁止p创建子进程,并且父进程代码执行结束,p即终止运行</span></span><br><span class="line">    p.start()</span><br><span class="line">    time.sleep(<span class="number">10</span>)  <span class="comment"># 在sleep时查看进程id对应的进程ps -ef|grep id(linux下)</span></span><br><span class="line">    print(<span class="string">'主'</span>)</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="..\img\process\20180628170154.png" alt=""></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="number">123</span>)</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    print(<span class="string">"end123"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bar</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="number">456</span>)</span><br><span class="line">    time.sleep(<span class="number">3</span>)</span><br><span class="line">    print(<span class="string">"end456"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    p1 = Process(target=foo)</span><br><span class="line">    p2 = Process(target=bar)</span><br><span class="line"></span><br><span class="line">    p1.daemon = <span class="keyword">True</span></span><br><span class="line">    p1.start()</span><br><span class="line">    p2.start()</span><br><span class="line">    time.sleep(<span class="number">0.1</span>)</span><br><span class="line">    print(<span class="string">"main-------"</span>)  <span class="comment"># 打印该行则主进程代码结束,则守护进程p1应该被终止.#可能会有p1任务执行的打印信息123,因为主进程打印main----时,p1也执行了,但是随即被终止.</span></span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="..\img\process\20180628165703.png" alt=""></p><p><img src="..\img\process\20180628165719.png" alt=""></p><p>参考资料：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">http://www.cnblogs.com/Eva-J/articles/8253549.html</span><br><span class="line">http://www.cnblogs.com/linhaifeng/articles/6817679.html</span><br><span class="line">https://www.jianshu.com/p/1200fd49b583</span><br><span class="line">https://www.jianshu.com/p/aed6067eeac9</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;什么是进程&quot;&gt;&lt;a href=&quot;#什么是进程&quot; class=&quot;headerlink&quot; title=&quot;什么是进程&quot;&gt;&lt;/a&gt;什么是进程&lt;/h3&gt;&lt;p&gt;进程（Process）是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是&lt;a h
      
    
    </summary>
    
      <category term="Python进程" scheme="http://gavinliu4011.github.io/categories/Python%E8%BF%9B%E7%A8%8B/"/>
    
    
      <category term="Python" scheme="http://gavinliu4011.github.io/tags/Python/"/>
    
      <category term="进程" scheme="http://gavinliu4011.github.io/tags/%E8%BF%9B%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Django之中间件</title>
    <link href="http://gavinliu4011.github.io/post/11a0df73.html"/>
    <id>http://gavinliu4011.github.io/post/11a0df73.html</id>
    <published>2018-01-06T21:17:43.000Z</published>
    <updated>2018-01-06T13:18:09.805Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Django中间件"><a href="#Django中间件" class="headerlink" title="Django中间件"></a>Django中间件</h1><h2 id="中间件介绍"><a href="#中间件介绍" class="headerlink" title="中间件介绍"></a>中间件介绍</h2><h3 id="什么是中间件"><a href="#什么是中间件" class="headerlink" title="什么是中间件?"></a>什么是中间件?</h3><p>官方的说法：中间件是一个用来处理Django的请求和响应的框架级别的钩子。它是一个轻量、低级别的插件系统，用于在全局范围内改变Django的输入和输出。每个中间件组件都负责做一些特定的功能。</p><p>但是由于其影响的是全局，所以需要谨慎使用，使用不当会影响性能。</p><p>说的直白一点中间件是帮助我们在视图函数执行之前和执行之后都可以做一些额外的操作，它本质上就是一个自定义类，类中定义了几个方法，Django框架会在请求的特定的时间去执行这些方法。</p><p>我们一直都在使用中间件，只是没有注意到而已，打开Django项目的settings.py文件，看到下图的MIDDLEWARE配置项。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">MIDDLEWARE = [</span><br><span class="line">    <span class="string">'django.middleware.security.SecurityMiddleware'</span>,</span><br><span class="line">    <span class="string">'django.contrib.sessions.middleware.SessionMiddleware'</span>,</span><br><span class="line">    <span class="string">'django.middleware.common.CommonMiddleware'</span>,</span><br><span class="line">    <span class="string">'django.middleware.csrf.CsrfViewMiddleware'</span>,</span><br><span class="line">    <span class="string">'django.contrib.auth.middleware.AuthenticationMiddleware'</span>,</span><br><span class="line">    <span class="string">'django.contrib.messages.middleware.MessageMiddleware'</span>,</span><br><span class="line">    <span class="string">'django.middleware.clickjacking.XFrameOptionsMiddleware'</span>,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>MIDDLEWARE配置项是一个列表，列表中是一个个字符串，这些字符串其实是一个个类，也就是一个个中间件。</p><p>我们之前已经接触过一个csrf相关的中间件了？我们一开始把他注释掉，再提交post请求的时候，就不会被forbidden了，后来学会使用csrf_token之后就不再注释这个中间件了。</p><p>那接下来就学习中间件中的方法以及这些方法什么时候被执行。</p><h2 id="自定义中间件"><a href="#自定义中间件" class="headerlink" title="自定义中间件"></a>自定义中间件</h2><p>中间件可以定义五个方法，分别是：（主要的是process_request和process_response）</p><ul><li>process_request(self,request)</li><li>process_view(self, request, view_func, view_args, view_kwargs)</li><li>process_template_response(self,request,response)</li><li>process_exception(self, request, exception)</li><li>process_response(self, request, response)</li></ul><p>以上方法的返回值可以是None或一个HttpResponse对象，如果是None，则继续按照django定义的规则向后继续执行，如果是HttpResponse对象，则直接将该对象返回给用户。</p><p>views.py中 :</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">(request)</span>:</span></span><br><span class="line">    print(<span class="string">'index视图'</span>)</span><br><span class="line">    <span class="keyword">return</span> HttpResponse(<span class="string">'OK'</span>)</span><br></pre></td></tr></table></figure><p>下面我们来一一说明中间件的五个方法:</p><h3 id="process-request"><a href="#process-request" class="headerlink" title="process_request"></a>process_request</h3><p>先来撸一段代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.utils.deprecation <span class="keyword">import</span> MiddlewareMixin</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MD1</span><span class="params">(MiddlewareMixin)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_request</span><span class="params">(self, request)</span>:</span></span><br><span class="line">        print(<span class="string">'MD1里面的 process_request'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MD2</span><span class="params">(MiddlewareMixin)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_request</span><span class="params">(self, request)</span>:</span></span><br><span class="line">        print(<span class="string">'MD2里面的 process_request'</span>)</span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>在settings.py的MIDDLEWARE配置项中注册上述两个自定义中间件： </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">MIDDLEWARE = [</span><br><span class="line">    <span class="string">'django.middleware.security.SecurityMiddleware'</span>,</span><br><span class="line">    <span class="string">'django.contrib.sessions.middleware.SessionMiddleware'</span>,</span><br><span class="line">    <span class="string">'django.middleware.common.CommonMiddleware'</span>,</span><br><span class="line">    <span class="string">'django.middleware.csrf.CsrfViewMiddleware'</span>,</span><br><span class="line">    <span class="string">'django.contrib.auth.middleware.AuthenticationMiddleware'</span>,</span><br><span class="line">    <span class="string">'django.contrib.messages.middleware.MessageMiddleware'</span>,</span><br><span class="line">    <span class="string">'django.middleware.clickjacking.XFrameOptionsMiddleware'</span>,</span><br><span class="line">    <span class="string">'middlewares.MD1'</span>,  <span class="comment"># 自定义中间件MD1</span></span><br><span class="line">    <span class="string">'middlewares.MD2'</span>  <span class="comment"># 自定义中间件MD2</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>完成以上操作后,我们运行一下项目并访问某个视图:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MD1里面的 process_request</span><br><span class="line">MD2里面的 process_request</span><br><span class="line">index视图</span><br></pre></td></tr></table></figure><p>再把MD1和MD2在settings.py中的位置调换一下，再访问一个视图，会发现终端中打印的内容如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MD2里面的 process_request</span><br><span class="line">MD1里面的 process_request</span><br><span class="line">index视图</span><br></pre></td></tr></table></figure><p>看结果我们知道：视图函数还是最后执行的，MD2比MD1先执行自己的process_request方法。</p><p>在打印一下两个自定义中间件中process_request方法中的request参数，会发现它们是同一个对象。</p><p>由此总结一下：</p><ol><li>中间件的process_request方法是在执行视图函数之前执行的。</li><li>当配置多个中间件时，会按照MIDDLEWARE中的注册顺序，也就是列表的索引值，从前到后依次执行的。（在settings.py里面设置中 从上到下的顺序）</li><li>不同中间件之间传递的request都是同一个对象</li><li>返回None，继续执行后续的中间件的process_request方法，返回response , 不执行后续的中间件的process_request方法</li></ol><h3 id="process-response"><a href="#process-response" class="headerlink" title="process_response"></a>process_response</h3><p>process_response 有两个参数，一个是request，一个是response，request就是上述例子中一样的对象，response是视图函数返回的HttpResponse对象。该方法的返回值也必须是HttpResponse对象。</p><p>给上述的MD1和MD2加上process_response方法： </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.utils.deprecation <span class="keyword">import</span> MiddlewareMixin</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MD1</span><span class="params">(MiddlewareMixin)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_request</span><span class="params">(self, request)</span>:</span></span><br><span class="line">        print(<span class="string">'MD1里面的 process_request'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_response</span><span class="params">(self, request, response)</span>:</span></span><br><span class="line">        print(<span class="string">'MD1里面的 process_response'</span>)</span><br><span class="line">        <span class="keyword">return</span> response</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MD2</span><span class="params">(MiddlewareMixin)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_request</span><span class="params">(self, request)</span>:</span></span><br><span class="line">        print(<span class="string">'MD2里面的 process_request'</span>)</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_response</span><span class="params">(self, request, response)</span>:</span></span><br><span class="line">        print(<span class="string">'MD2里面的 process_response'</span>)</span><br><span class="line">        <span class="keyword">return</span> response</span><br></pre></td></tr></table></figure><p> 访问一个视图，看一下终端的输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MD2里面的 process_request</span><br><span class="line">MD1里面的 process_request</span><br><span class="line">index视图</span><br><span class="line">MD1里面的 process_response</span><br><span class="line">MD2里面的 process_response</span><br></pre></td></tr></table></figure><p>看结果可知：process_response方法是在视图函数之后执行的，并且顺序是MD1比MD2先执行。(此时settings.py中 MD2比MD1先注册)</p><p>由此总结一下：</p><ol><li>多个中间件中的process_response方法是按照MIDDLEWARE中的注册顺序<strong>倒序</strong>执行的（在settings.py里面设置中 从下到上的顺序）</li><li>在请求有响应的时候执行process_response方法</li><li>该方法的返回值也必须是HttpResponse对象</li></ol><h3 id="process-view"><a href="#process-view" class="headerlink" title="process_view"></a>process_view</h3><p>process_view(self, request, view_func, view_args, view_kwargs)</p><p>该方法有四个参数</p><p>request是HttpRequest对象。</p><p>view_func是Django即将使用的视图函数。 （它是实际的函数对象，而不是函数的名称作为字符串。）</p><p>view_args是将传递给视图的位置参数的列表.</p><p>view_kwargs是将传递给视图的关键字参数的字典。 view_args和view_kwargs都不包含第一个视图参数（request）。</p><p>Django会在调用视图函数之前调用process_view方法。</p><p>它应该返回None或一个HttpResponse对象。 如果返回None，Django将继续处理这个请求，执行任何其他中间件的process_view方法，然后在执行相应的视图。 如果它返回一个HttpResponse对象，Django不会调用适当的视图函数。 它将执行中间件的process_response方法并将应用到该HttpResponse并返回结果。</p><p> 给MD1和MD2添加process_view方法:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.utils.deprecation <span class="keyword">import</span> MiddlewareMixin</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MD1</span><span class="params">(MiddlewareMixin)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_request</span><span class="params">(self, request)</span>:</span></span><br><span class="line">        print(<span class="string">'MD1里面的 process_request'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_response</span><span class="params">(self, request, response)</span>:</span></span><br><span class="line">        print(<span class="string">'MD1里面的 process_response'</span>)</span><br><span class="line">        <span class="keyword">return</span> response</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_view</span><span class="params">(self, request, view_func, view_args, view_kwargs)</span>:</span></span><br><span class="line">        print(<span class="string">'-'</span> * <span class="number">80</span>)</span><br><span class="line">        print(<span class="string">'MD1 中的process_view'</span>)</span><br><span class="line">        print(view_func, view_func.__name__)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MD2</span><span class="params">(MiddlewareMixin)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_request</span><span class="params">(self, request)</span>:</span></span><br><span class="line">        print(<span class="string">'MD2里面的 process_request'</span>)</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_response</span><span class="params">(self, request, response)</span>:</span></span><br><span class="line">        print(<span class="string">'MD2里面的 process_response'</span>)</span><br><span class="line">        <span class="keyword">return</span> response</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_view</span><span class="params">(self, request, view_func, view_args, view_kwargs)</span>:</span></span><br><span class="line">        print(<span class="string">'-'</span> * <span class="number">80</span>)</span><br><span class="line">        print(<span class="string">'MD2 中的process_view'</span>)</span><br><span class="line">        print(view_func, view_func.__name__)</span><br></pre></td></tr></table></figure><p>访问index视图函数，看一下输出结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">MD2里面的 process_request</span><br><span class="line">MD1里面的 process_request</span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line">MD2 中的process_view</span><br><span class="line">&lt;function index at 0x000001DE68317488&gt; index</span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line">MD1 中的process_view</span><br><span class="line">&lt;function index at 0x000001DE68317488&gt; index</span><br><span class="line">index视图</span><br><span class="line">MD1里面的 process_response</span><br><span class="line">MD2里面的 process_response</span><br></pre></td></tr></table></figure><p>process_view方法是在process_request之后，视图函数之前执行的，执行顺序按照MIDDLEWARE中的注册顺序<strong>从前到后顺序</strong>执行的，返回None，继续执行后续的中间件的process_view方法，返回response , 不执行后续的中间件的process_view方法。</p><h3 id="process-exception"><a href="#process-exception" class="headerlink" title="process_exception"></a>process_exception</h3><p>process_exception(self, request, exception)</p><p>该方法两个参数:</p><p>一个HttpRequest对象</p><p>一个exception是视图函数异常产生的Exception对象。</p><p>这个方法只有在视图函数中出现异常了才执行，它返回的值可以是一个None也可以是一个HttpResponse对象。如果是HttpResponse对象，Django将调用模板和中间件中的process_response方法，并返回给浏览器，否则将默认处理异常。如果返回一个None，则交给下一个中间件的process_exception方法来处理异常。它的执行顺序也是按照中间件注册顺序的<strong>倒序</strong>执行。</p><p> 给MD1和MD2添加上这个方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.utils.deprecation <span class="keyword">import</span> MiddlewareMixin</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MD1</span><span class="params">(MiddlewareMixin)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_request</span><span class="params">(self, request)</span>:</span></span><br><span class="line">        print(<span class="string">'MD1里面的 process_request'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_response</span><span class="params">(self, request, response)</span>:</span></span><br><span class="line">        print(<span class="string">'MD1里面的 process_response'</span>)</span><br><span class="line">        <span class="keyword">return</span> response</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_view</span><span class="params">(self, request, view_func, view_args, view_kwargs)</span>:</span></span><br><span class="line">        print(<span class="string">'-'</span> * <span class="number">80</span>)</span><br><span class="line">        print(<span class="string">'MD1 中的process_view'</span>)</span><br><span class="line">        print(view_func, view_func.__name__)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_exception</span><span class="params">(self, request, exception)</span>:</span></span><br><span class="line">        print(exception)</span><br><span class="line">        print(<span class="string">'MD1 中的process_exception'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MD2</span><span class="params">(MiddlewareMixin)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_request</span><span class="params">(self, request)</span>:</span></span><br><span class="line">        print(<span class="string">'MD2里面的 process_request'</span>)</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_response</span><span class="params">(self, request, response)</span>:</span></span><br><span class="line">        print(<span class="string">'MD2里面的 process_response'</span>)</span><br><span class="line">        <span class="keyword">return</span> response</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_view</span><span class="params">(self, request, view_func, view_args, view_kwargs)</span>:</span></span><br><span class="line">        print(<span class="string">'-'</span> * <span class="number">80</span>)</span><br><span class="line">        print(<span class="string">'MD2 中的process_view'</span>)</span><br><span class="line">        print(view_func, view_func.__name__)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_exception</span><span class="params">(self, request, exception)</span>:</span></span><br><span class="line">        print(exception)</span><br><span class="line">        print(<span class="string">'MD2 中的process_exception'</span>)</span><br></pre></td></tr></table></figure><p>如果视图函数中无异常，process_exception方法不执行。</p><p>想办法，在视图函数中抛出一个异常：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">(request)</span>:</span></span><br><span class="line">    print(<span class="string">'index视图'</span>)</span><br><span class="line">    <span class="keyword">raise</span> ValueError(<span class="string">'呵呵'</span>)</span><br><span class="line">    <span class="keyword">return</span> HttpResponse(<span class="string">'OK'</span>)</span><br></pre></td></tr></table></figure><p>在MD1的process_exception中返回一个响应对象：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MD1</span><span class="params">(MiddlewareMixin)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_request</span><span class="params">(self, request)</span>:</span></span><br><span class="line">        print(<span class="string">'MD1里面的 process_request'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_response</span><span class="params">(self, request, response)</span>:</span></span><br><span class="line">        print(<span class="string">'MD1里面的 process_response'</span>)</span><br><span class="line">        <span class="keyword">return</span> response</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_view</span><span class="params">(self, request, view_func, view_args, view_kwargs)</span>:</span></span><br><span class="line">        print(<span class="string">'-'</span> * <span class="number">80</span>)</span><br><span class="line">        print(<span class="string">'MD1 中的process_view'</span>)</span><br><span class="line">        print(view_func, view_func.__name__)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_exception</span><span class="params">(self, request, exception)</span>:</span></span><br><span class="line">        print(exception)</span><br><span class="line">        print(<span class="string">'MD1 中的process_exception'</span>)</span><br><span class="line">        <span class="keyword">return</span> HttpResponse(str(exception))  <span class="comment"># 返回一个响应对象</span></span><br></pre></td></tr></table></figure><p>看输出结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">MD2里面的 process_request</span><br><span class="line">MD1里面的 process_request</span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line">MD2 中的process_view</span><br><span class="line">&lt;function index at 0x0000022C09727488&gt; index</span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line">MD1 中的process_view</span><br><span class="line">&lt;function index at 0x0000022C09727488&gt; index</span><br><span class="line">index视图</span><br><span class="line">呵呵</span><br><span class="line">MD1 中的process_exception</span><br><span class="line">MD1里面的 process_response</span><br><span class="line">MD2里面的 process_response</span><br></pre></td></tr></table></figure><p>注意，这里并没有执行MD2的process_exception方法，因为MD1中的process_exception方法直接返回了一个响应对象。</p><h3 id="process-template-response"><a href="#process-template-response" class="headerlink" title="process_template_response"></a>process_template_response</h3><p>process_template_response(self, request, response)</p><p>它的参数，一个HttpRequest对象，response是TemplateResponse对象（由视图函数或者中间件产生）。</p><p>process_template_response是在视图函数执行完成后立即执行，但是它有一个前提条件，那就是视图函数返回的对象有一个render()方法（或者表明该对象是一个TemplateResponse对象或等价方法）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MD1</span><span class="params">(MiddlewareMixin)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_request</span><span class="params">(self, request)</span>:</span></span><br><span class="line">        print(<span class="string">'MD1里面的 process_request'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_response</span><span class="params">(self, request, response)</span>:</span></span><br><span class="line">        print(<span class="string">'MD1里面的 process_response'</span>)</span><br><span class="line">        <span class="keyword">return</span> response</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_view</span><span class="params">(self, request, view_func, view_args, view_kwargs)</span>:</span></span><br><span class="line">        print(<span class="string">'-'</span> * <span class="number">80</span>)</span><br><span class="line">        print(<span class="string">'MD1 中的process_view'</span>)</span><br><span class="line">        print(view_func, view_func.__name__)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_exception</span><span class="params">(self, request, exception)</span>:</span></span><br><span class="line">        print(exception)</span><br><span class="line">        print(<span class="string">'MD1 中的process_exception'</span>)</span><br><span class="line">        <span class="keyword">return</span> HttpResponse(str(exception))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_template_response</span><span class="params">(self, request, response)</span>:</span></span><br><span class="line">        print(<span class="string">'MD1 中的process_template_response'</span>)</span><br><span class="line">        <span class="keyword">return</span> response</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MD2</span><span class="params">(MiddlewareMixin)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_request</span><span class="params">(self, request)</span>:</span></span><br><span class="line">        print(<span class="string">'MD2里面的 process_request'</span>)</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_response</span><span class="params">(self, request, response)</span>:</span></span><br><span class="line">        print(<span class="string">'MD2里面的 process_response'</span>)</span><br><span class="line">        <span class="keyword">return</span> response</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_view</span><span class="params">(self, request, view_func, view_args, view_kwargs)</span>:</span></span><br><span class="line">        print(<span class="string">'-'</span> * <span class="number">80</span>)</span><br><span class="line">        print(<span class="string">'MD2 中的process_view'</span>)</span><br><span class="line">        print(view_func, view_func.__name__)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_exception</span><span class="params">(self, request, exception)</span>:</span></span><br><span class="line">        print(exception)</span><br><span class="line">        print(<span class="string">'MD2 中的process_exception'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_template_response</span><span class="params">(self, request, response)</span>:</span></span><br><span class="line">        print(<span class="string">'MD2 中的process_template_response'</span>)</span><br><span class="line">        <span class="keyword">return</span> response</span><br></pre></td></tr></table></figure><p>修改views.py中代码 :</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">(request)</span>:</span></span><br><span class="line">    print(<span class="string">'index视图'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">render</span><span class="params">()</span>:</span></span><br><span class="line">        print(<span class="string">'render'</span>)</span><br><span class="line">        <span class="keyword">return</span> HttpResponse(<span class="string">'render'</span>)</span><br><span class="line">    rep = HttpResponse(<span class="string">'OK'</span>)</span><br><span class="line">    rep.render = render</span><br><span class="line">    <span class="keyword">return</span> rep</span><br></pre></td></tr></table></figure><p>访问index视图，终端输出的结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">MD2里面的 process_request</span><br><span class="line">MD1里面的 process_request</span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line">MD2 中的process_view</span><br><span class="line">&lt;function index at 0x000001C111B97488&gt; index</span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line">MD1 中的process_view</span><br><span class="line">&lt;function index at 0x000001C111B97488&gt; index</span><br><span class="line">index视图</span><br><span class="line">MD1 中的process_template_response</span><br><span class="line">MD2 中的process_template_response</span><br><span class="line">render</span><br><span class="line">MD1里面的 process_response</span><br><span class="line">MD2里面的 process_response</span><br></pre></td></tr></table></figure><p>从结果看出：</p><p>视图函数执行完之后，立即执行了中间件的process_template_response方法，顺序是倒序，先执行MD1的，在执行MD2的，接着执行了视图函数返回的HttpResponse对象的render方法，返回了一个新的HttpResponse对象，接着执行中间件的process_response方法。</p><h2 id="中间件的执行流程"><a href="#中间件的执行流程" class="headerlink" title="中间件的执行流程"></a>中间件的执行流程</h2><p>上面我们一一了解了中间件中的5个方法，它们的参数、返回值以及什么时候执行，现在总结一下中间件的执行流程。 </p><p>请求到达中间件之后，先按照正序执行每个注册中间件的process_reques方法，process_request方法返回的值是None，就依次执行，如果返回的值是HttpResponse对象，不再执行后面的process_request方法，而是执行当前对应中间件的process_response方法，将HttpResponse对象返回给浏览器。也就是说：如果MIDDLEWARE中注册了6个中间件，执行过程中，第3个中间件返回了一个HttpResponse对象，那么第4,5,6中间件的process_request和process_response方法都不执行，顺序执行3,2,1中间件的process_response方法。</p><p><img src="..\img\django\middlewares1.png" alt="图一"> </p><p>process_request方法都执行完后，匹配路由，找到要执行的视图函数，先不执行视图函数，先执行中间件中的process_view方法，process_view方法返回None，继续按顺序执行，所有process_view方法执行完后执行视图函数。假如中间件3 的process_view方法返回了HttpResponse对象，则4,5,6的process_view以及视图函数都不执行，直接从最后一个中间件，也就是中间件6的process_response方法开始倒序执行。 </p><p><img src="..\img\django\867021-20180409214307195-1684061444.png" alt="图二"></p><p>process_template_response和process_exception两个方法的触发是有条件的，执行顺序也是倒序。总结所有的执行流程如下： </p><p><img src="..\img\django\286908304.png" alt="图三"></p><p><img src="..\img\django\2137571775.png" alt="图四"></p><h2 id="Django请求流程图"><a href="#Django请求流程图" class="headerlink" title="Django请求流程图"></a>Django请求流程图</h2><p><img src="..\img\django\196913305.png" alt="图五"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Django中间件&quot;&gt;&lt;a href=&quot;#Django中间件&quot; class=&quot;headerlink&quot; title=&quot;Django中间件&quot;&gt;&lt;/a&gt;Django中间件&lt;/h1&gt;&lt;h2 id=&quot;中间件介绍&quot;&gt;&lt;a href=&quot;#中间件介绍&quot; class=&quot;header
      
    
    </summary>
    
      <category term="Django" scheme="http://gavinliu4011.github.io/categories/Django/"/>
    
    
      <category term="Python" scheme="http://gavinliu4011.github.io/tags/Python/"/>
    
      <category term="Django" scheme="http://gavinliu4011.github.io/tags/Django/"/>
    
      <category term="中间件" scheme="http://gavinliu4011.github.io/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>Django(二)之模型</title>
    <link href="http://gavinliu4011.github.io/post/2116a065.html"/>
    <id>http://gavinliu4011.github.io/post/2116a065.html</id>
    <published>2017-10-30T22:29:28.000Z</published>
    <updated>2017-10-30T14:29:36.680Z</updated>
    
    <content type="html"><![CDATA[<p>本文档使用Django 2.x，Django是一个基于MVC架构的Web框架，MVC架构要追求的是模型和视图的解耦合，而其中的模型说得更直白一些就是数据，所以通常也被称作数据模型。在实际的项目中，数据模型通常通过数据库实现持久化操作，而关系型数据库在很长一段时间都是持久化的首选方案，在我们的OA项目中，我们选择使用MySQL来实现数据持久化。</p><h3 id="配置关系型数据库MySQL"><a href="#配置关系型数据库MySQL" class="headerlink" title="配置关系型数据库MySQL"></a>配置关系型数据库MySQL</h3><ol><li><p>进入oa文件夹，修改项目的settings.py文件，首先将我们之前创建的应用hrs添加已安装的项目中，然后配置MySQL作为持久化方案。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">(venv)$</span><span class="bash"> <span class="built_in">cd</span> oa</span></span><br><span class="line"><span class="meta">(venv)$</span><span class="bash"> vim settings.py</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 此处省略上面的代码</span></span><br><span class="line"></span><br><span class="line">INSTALLED_APPS = [</span><br><span class="line">    <span class="string">'django.contrib.admin'</span>,</span><br><span class="line">    <span class="string">'django.contrib.auth'</span>,</span><br><span class="line">    <span class="string">'django.contrib.contenttypes'</span>,</span><br><span class="line">    <span class="string">'django.contrib.sessions'</span>,</span><br><span class="line">    <span class="string">'django.contrib.messages'</span>,</span><br><span class="line">    <span class="string">'django.contrib.staticfiles'</span>,</span><br><span class="line">    <span class="string">'hrs'</span>,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">DATABASES = &#123;</span><br><span class="line">    <span class="string">'default'</span>: &#123;</span><br><span class="line">        <span class="string">'ENGINE'</span>: <span class="string">'django.db.backends.mysql'</span>,</span><br><span class="line">        <span class="string">'NAME'</span>: <span class="string">'oa'</span>,</span><br><span class="line">        <span class="string">'HOST'</span>: <span class="string">'localhost'</span>,</span><br><span class="line">        <span class="string">'PORT'</span>: <span class="number">3306</span>,</span><br><span class="line">        <span class="string">'USER'</span>: <span class="string">'root'</span>,</span><br><span class="line">        <span class="string">'PASSWORD'</span>: <span class="string">'123456'</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 此处省略下面的代码</span></span><br></pre></td></tr></table></figure><p>在配置ENGINE属性时，常用的可选值包括：</p><ul><li><code>&#39;django.db.backends.sqlite3&#39;</code>：SQLite嵌入式数据库</li><li><code>&#39;django.db.backends.postgresql&#39;</code>：BSD许可证下发行的开源关系型数据库产品</li><li><code>&#39;django.db.backends.mysql&#39;</code>：转手多次目前属于甲骨文公司的经济高效的数据库产品</li><li><code>&#39;django.db.backends.oracle&#39;</code>：甲骨文公司的旗舰关系型数据库产品</li></ul><p>其他的配置可以参考官方文档中<a href="https://docs.djangoproject.com/zh-hans/2.0/ref/databases/#third-party-notes" target="_blank" rel="noopener">数据库配置</a>的部分。</p><p>NAME属性代表数据库的名称，如果使用SQLite它对应着一个文件，在这种情况下NAME的属性值应该是一个绝对路径。如果使用其他关系型数据库，还要配置对应的HOST（主机）、PORT（端口）、USER（用户名）、PASSWORD（口令）等属性。</p></li><li><p>安装MySQL客户端工具，Python 3中使用PyMySQL，Python 2中用MySQLdb。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">(venv)$</span><span class="bash"> pip install pymysql</span></span><br></pre></td></tr></table></figure><p>如果使用Python 3需要修改<strong>项目</strong>的<code>__init__.py</code>文件并加入如下所示的代码，这段代码的作用是将PyMySQL视为MySQLdb来使用，从而避免Django找不到连接MySQL的客户端工具而询问你：“Did you install mysqlclient? ”（你安装了mysqlclient吗？）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pymysql</span><br><span class="line"></span><br><span class="line">pymysql.install_as_MySQLdb()</span><br></pre></td></tr></table></figure></li><li><p>运行manage.py并指定migrate参数实现数据库迁移，为应用程序创建对应的数据表，当然在此之前需要<strong>先启动MySQL数据库服务器并创建名为oa的数据库</strong>，在MySQL中创建数据库的语句如下所示。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">database</span> <span class="keyword">if</span> <span class="keyword">exists</span> oa;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">database</span> oa <span class="keyword">default</span> <span class="keyword">charset</span> utf8;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">(venv)$</span><span class="bash"> <span class="built_in">cd</span> ..</span></span><br><span class="line"><span class="meta">(venv)$</span><span class="bash"> python manage.py migrate</span></span><br><span class="line">Operations to perform:</span><br><span class="line">  Apply all migrations: admin, auth, contenttypes, sessions</span><br><span class="line">Running migrations:</span><br><span class="line">  Applying contenttypes.0001_initial... OK</span><br><span class="line">  Applying auth.0001_initial... OK</span><br><span class="line">  Applying admin.0001_initial... OK</span><br><span class="line">  Applying admin.0002_logentry_remove_auto_add... OK</span><br><span class="line">  Applying contenttypes.0002_remove_content_type_name... OK</span><br><span class="line">  Applying auth.0002_alter_permission_name_max_length... OK</span><br><span class="line">  Applying auth.0003_alter_user_email_max_length... OK</span><br><span class="line">  Applying auth.0004_alter_user_username_opts... OK</span><br><span class="line">  Applying auth.0005_alter_user_last_login_null... OK</span><br><span class="line">  Applying auth.0006_require_contenttypes_0002... OK</span><br><span class="line">  Applying auth.0007_alter_validators_add_error_messages... OK</span><br><span class="line">  Applying auth.0008_alter_user_username_max_length... OK</span><br><span class="line">  Applying auth.0009_alter_user_last_name_max_length... OK</span><br><span class="line">  Applying sessions.0001_initial... OK</span><br></pre></td></tr></table></figure></li><li><p>可以看到，Django帮助我们创建了10张表，这些都是使用Django框架需要的东西，稍后我们就会用到这些表。除此之外，我们还应该为我们自己的应用创建数据模型。如果要在hrs应用中实现对部门和员工的管理，我们可以创建如下所示的数据模型。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">(venv)$</span><span class="bash"> <span class="built_in">cd</span> hrs</span></span><br><span class="line"><span class="meta">(venv)$</span><span class="bash"> vim models.py</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dept</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    <span class="string">"""部门类"""</span></span><br><span class="line">    </span><br><span class="line">    no = models.IntegerField(primary_key=<span class="keyword">True</span>, db_column=<span class="string">'dno'</span>, verbose_name=<span class="string">'部门编号'</span>)</span><br><span class="line">    name = models.CharField(max_length=<span class="number">20</span>, db_column=<span class="string">'dname'</span>, verbose_name=<span class="string">'部门名称'</span>)</span><br><span class="line">    location = models.CharField(max_length=<span class="number">10</span>, db_column=<span class="string">'dloc'</span>, verbose_name=<span class="string">'部门所在地'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        db_table = <span class="string">'tb_dept'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Emp</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    <span class="string">"""员工类"""</span></span><br><span class="line">    </span><br><span class="line">    no = models.IntegerField(primary_key=<span class="keyword">True</span>, db_column=<span class="string">'eno'</span>, verbose_name=<span class="string">'员工编号'</span>)</span><br><span class="line">    name = models.CharField(max_length=<span class="number">20</span>, db_column=<span class="string">'ename'</span>, verbose_name=<span class="string">'员工姓名'</span>)</span><br><span class="line">    job = models.CharField(max_length=<span class="number">10</span>, verbose_name=<span class="string">'职位'</span>)</span><br><span class="line">    <span class="comment"># 自参照完整性多对一外键关联</span></span><br><span class="line">    mgr = models.ForeignKey(<span class="string">'self'</span>, on_delete=models.SET_NULL, null=<span class="keyword">True</span>, blank=<span class="keyword">True</span>, verbose_name=<span class="string">'主管编号'</span>)</span><br><span class="line">    sal = models.DecimalField(max_digits=<span class="number">7</span>, decimal_places=<span class="number">2</span>, verbose_name=<span class="string">'月薪'</span>)</span><br><span class="line">    comm = models.DecimalField(max_digits=<span class="number">7</span>, decimal_places=<span class="number">2</span>, null=<span class="keyword">True</span>, blank=<span class="keyword">True</span>, verbose_name=<span class="string">'补贴'</span>)</span><br><span class="line">    dept = models.ForeignKey(Dept, db_column=<span class="string">'dno'</span>, on_delete=models.PROTECT, verbose_name=<span class="string">'所在部门'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        db_table = <span class="string">'tb_emp'</span></span><br></pre></td></tr></table></figure><blockquote><p>说明：上面定义模型时使用了字段类及其属性，其中IntegerField对应数据库中的integer类型，CharField对应数据库的varchar类型，DecimalField对应数据库的decimal类型，ForeignKey用来建立多对一外键关联。字段属性primary_key用于设置主键，max_length用来设置字段的最大长度，db_column用来设置数据库中与字段对应的列，verbose_name则设置了Django后台管理系统中该字段显示的名称。如果对这些东西感到很困惑也不要紧，文末提供了字段类、字段属性、元数据选项等设置的相关说明，不清楚的读者可以稍后查看对应的参考指南。</p></blockquote></li><li><p>通过模型创建数据表。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">(venv)$</span><span class="bash"> <span class="built_in">cd</span> ..</span></span><br><span class="line"><span class="meta">(venv)$</span><span class="bash"> python manage.py makemigrations hrs</span></span><br><span class="line">Migrations for 'hrs':</span><br><span class="line">  hrs/migrations/0001_initial.py</span><br><span class="line">    - Create model Dept</span><br><span class="line">    - Create model Emp</span><br><span class="line"><span class="meta">(venv)$</span><span class="bash"> python manage.py migrate</span></span><br><span class="line">Operations to perform:</span><br><span class="line">  Apply all migrations: admin, auth, contenttypes, hrs, sessions</span><br><span class="line">Running migrations:</span><br><span class="line">  Applying hrs.0001_initial... OK</span><br></pre></td></tr></table></figure><p>执行完数据迁移操作之后，可以在通过图形化的MySQL客户端工具查看到E-R图（实体关系图）。</p><p><img src="..\img\django\er-graph.png" alt=""></p></li></ol><h3 id="在后台管理模型"><a href="#在后台管理模型" class="headerlink" title="在后台管理模型"></a>在后台管理模型</h3><ol><li><p>创建超级管理员账号。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">(venv)$</span><span class="bash"> python manage.py createsuperuser</span></span><br><span class="line">Username (leave blank to use 'hao'): jackfrued</span><br><span class="line">Email address: jackfrued@126.com</span><br><span class="line">Password: </span><br><span class="line">Password (again): </span><br><span class="line">Superuser created successfully.</span><br></pre></td></tr></table></figure></li><li><p>启动Web服务器，登录后台管理系统。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">(venv)$</span><span class="bash"> python manage.py runserver</span></span><br></pre></td></tr></table></figure><p>访问<a href="http://127.0.0.1:8000/admin" target="_blank" rel="noopener">http://127.0.0.1:8000/admin</a>，会来到如下图所示的登录界面。</p><p><img src="..\img\django\admin-login.png" alt=""></p><p>登录后进入管理员操作平台。</p><p><img src="..\img\django\admin-welcome.png" alt=""></p><p>至此我们还没有看到之前创建的模型类，需要在应用的admin.py文件中模型进行注册。</p></li><li><p>注册模型类。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">(venv)$</span><span class="bash"> <span class="built_in">cd</span> hrs</span></span><br><span class="line"><span class="meta">(venv)$</span><span class="bash"> vim admin.py</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.contrib <span class="keyword">import</span> admin</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> hrs.models <span class="keyword">import</span> Emp, Dept</span><br><span class="line"></span><br><span class="line">admin.site.register(Dept)</span><br><span class="line">admin.site.register(Emp)</span><br></pre></td></tr></table></figure><p>注册模型类后，就可以在后台管理系统中看到它们。</p><p><img src="..\img\django\admin-model.png" alt=""></p></li><li><p>对模型进行CRUD操作。</p><p>可以在管理员平台对模型进行C（新增）R（查看）U（更新）D（删除）操作，如下图所示。</p><p>添加新的部门。</p><p><img src="..\img\django\admin-model-create-g.png" alt=""></p><p>查看所有部门。</p><p><img src="..\img\django\admin-model-read-g.png" alt=""></p><p>更新和删除部门。</p><p><img src="..\img\django\admin-model-delete-and-update.png" alt=""></p></li><li><p>注册模型管理类。</p><p>再次修改admin.py文件，通过注册模型管理类，可以在后台管理系统中更好的管理模型。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.contrib <span class="keyword">import</span> admin</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> hrs.models <span class="keyword">import</span> Emp, Dept</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DeptAdmin</span><span class="params">(admin.ModelAdmin)</span>:</span></span><br><span class="line"></span><br><span class="line">    list_display = (<span class="string">'no'</span>, <span class="string">'name'</span>, <span class="string">'location'</span>)</span><br><span class="line">    ordering = (<span class="string">'no'</span>, )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EmpAdmin</span><span class="params">(admin.ModelAdmin)</span>:</span></span><br><span class="line"></span><br><span class="line">    list_display = (<span class="string">'no'</span>, <span class="string">'name'</span>, <span class="string">'job'</span>, <span class="string">'mgr'</span>, <span class="string">'sal'</span>, <span class="string">'comm'</span>, <span class="string">'dept'</span>)</span><br><span class="line">    search_fields = (<span class="string">'name'</span>, <span class="string">'job'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">admin.site.register(Dept, DeptAdmin)</span><br><span class="line">admin.site.register(Emp, EmpAdmin)</span><br></pre></td></tr></table></figure><p><img src="..\img\django\admin-model-depts.png" alt=""></p><p><img src="..\img\django\admin-model-emps.png" alt=""></p><p>为了更好的查看模型数据，可以为Dept和Emp两个模型类添加<code>__str__</code>魔法方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dept</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    <span class="string">"""部门类"""</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 此处省略上面的代码</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.name</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 此处省略下面的代码</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Emp</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    <span class="string">"""员工类"""</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 此处省略上面的代码</span></span><br><span class="line">    </span><br><span class="line">    mgr = models.ForeignKey(<span class="string">'self'</span>, on_delete=models.SET_NULL, null=<span class="keyword">True</span>, blank=<span class="keyword">True</span>, verbose_name=<span class="string">'直接主管'</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 此处省略下面的代码</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 此处省略上面的代码</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.name</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 此处省略下面的代码</span></span><br></pre></td></tr></table></figure><p>修改代码后刷新查看Emp模型的页面，效果如下图所示。</p><p><img src="..\img\django\admin-model-emps-modified.png" alt=""></p></li></ol><h3 id="使用ORM完成模型的CRUD操作"><a href="#使用ORM完成模型的CRUD操作" class="headerlink" title="使用ORM完成模型的CRUD操作"></a>使用ORM完成模型的CRUD操作</h3><p>在了解了Django提供的模型管理平台之后，我们来看看如何从代码层面完成对模型的CRUD（Create / Read / Update / Delete）操作。我们可以通过manage.py开启Shell交互式环境，然后使用Django内置的ORM框架对模型进行CRUD操作。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">(venv)$</span><span class="bash"> <span class="built_in">cd</span> ..</span></span><br><span class="line"><span class="meta">(venv)$</span><span class="bash"> python manage.py shell</span></span><br><span class="line">Python 3.6.4 (v3.6.4:d48ecebad5, Dec 18 2017, 21:07:28) </span><br><span class="line">[GCC 4.2.1 (Apple Inc. build 5666) (dot 3)] on darwin</span><br><span class="line">Type "help", "copyright", "credits" or "license" for more information.</span><br><span class="line">(InteractiveConsole)</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt;</span></span><br></pre></td></tr></table></figure><h4 id="新增"><a href="#新增" class="headerlink" title="新增"></a>新增</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt;</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; from hrs.models import Dept, Emp</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; dept = Dept(40, <span class="string">'研发2部'</span>, <span class="string">'深圳'</span>)</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; dept.save()</span></span><br></pre></td></tr></table></figure><h4 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt;</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; dept.name = <span class="string">'研发3部'</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; dept.save()</span></span><br></pre></td></tr></table></figure><h4 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h4><p>查询所有对象。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt;</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; Dept.objects.all()</span></span><br><span class="line">&lt;QuerySet [&lt;Dept: 研发1部&gt;, &lt;Dept: 销售1部&gt;, &lt;Dept: 运维1部&gt;, &lt;Dept: 研发3部&gt;]&gt;</span><br></pre></td></tr></table></figure><p>过滤数据。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; </span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; Dept.objects.filter(name=<span class="string">'研发3部'</span>) <span class="comment"># 查询部门名称为“研发3部”的部门</span></span></span><br><span class="line">&lt;QuerySet [&lt;Dept: 研发3部&gt;]&gt;</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt;</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; Dept.objects.filter(name__contains=<span class="string">'研发'</span>) <span class="comment"># 查询部门名称包含“研发”的部门(模糊查询)</span></span></span><br><span class="line">&lt;QuerySet [&lt;Dept: 研发1部&gt;, &lt;Dept: 研发3部&gt;]&gt;</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt;</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; Dept.objects.filter(no__gt=10).filter(no__lt=40) <span class="comment"># 查询部门编号大于10小于40的部门</span></span></span><br><span class="line">&lt;QuerySet [&lt;Dept: 销售1部&gt;, &lt;Dept: 运维1部&gt;]&gt;</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt;</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; Dept.objects.filter(no__range=(10, 30)) <span class="comment"># 查询部门编号在10到30之间的部门</span></span></span><br><span class="line">&lt;QuerySet [&lt;Dept: 研发1部&gt;, &lt;Dept: 销售1部&gt;, &lt;Dept: 运维1部&gt;]&gt;</span><br></pre></td></tr></table></figure><p>查询单个对象。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; </span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; Dept.objects.get(pk=10)</span></span><br><span class="line">&lt;Dept: 研发1部&gt;</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt;</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; Dept.objects.get(no=20)</span></span><br><span class="line">&lt;Dept: 销售1部&gt;</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt;</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; Dept.objects.get(no__exact=30)</span></span><br><span class="line">&lt;Dept: 运维1部&gt;</span><br></pre></td></tr></table></figure><p>排序数据。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt;</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; Dept.objects.order_by(<span class="string">'no'</span>) <span class="comment"># 查询所有部门按部门编号升序排列</span></span></span><br><span class="line">&lt;QuerySet [&lt;Dept: 研发1部&gt;, &lt;Dept: 销售1部&gt;, &lt;Dept: 运维1部&gt;, &lt;Dept: 研发3部&gt;]&gt;</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt;</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; Dept.objects.order_by(<span class="string">'-no'</span>) <span class="comment"># 查询所有部门按部门编号降序排列</span></span></span><br><span class="line">&lt;QuerySet [&lt;Dept: 研发3部&gt;, &lt;Dept: 运维1部&gt;, &lt;Dept: 销售1部&gt;, &lt;Dept: 研发1部&gt;]&gt;</span><br></pre></td></tr></table></figure><p>切片数据。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt;</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; Dept.objects.order_by(<span class="string">'no'</span>)[0:2] <span class="comment"># 按部门编号排序查询1~2部门</span></span></span><br><span class="line">&lt;QuerySet [&lt;Dept: 研发1部&gt;, &lt;Dept: 销售1部&gt;]&gt;</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt;</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; Dept.objects.order_by(<span class="string">'no'</span>)[2:4] <span class="comment"># 按部门编号排序查询3~4部门</span></span></span><br><span class="line">&lt;QuerySet [&lt;Dept: 运维1部&gt;, &lt;Dept: 研发3部&gt;]&gt;</span><br></pre></td></tr></table></figure><p>高级查询。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt;</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; Emp.objects.filter(dept__no=10) <span class="comment"># 根据部门编号查询该部门的员工</span></span></span><br><span class="line">&lt;QuerySet [&lt;Emp: 乔峰&gt;, &lt;Emp: 张无忌&gt;, &lt;Emp: 张三丰&gt;]&gt;</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt;</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; Emp.objects.filter(dept__name__contains=<span class="string">'销售'</span>) <span class="comment"># 查询名字包含“销售”的部门的员工</span></span></span><br><span class="line">&lt;QuerySet [&lt;Emp: 黄蓉&gt;]&gt;</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt;</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; Dept.objects.get(pk=10).emp_set.all() <span class="comment"># 通过部门反查部门所有的员工</span></span></span><br><span class="line">&lt;QuerySet [&lt;Emp: 乔峰&gt;, &lt;Emp: 张无忌&gt;, &lt;Emp: 张三丰&gt;]&gt;</span><br></pre></td></tr></table></figure><blockquote><p>说明1：由于员工与部门之间存在多对一外键关联，所以也能通过部门反向查询该部门的员工（从一对多关系中“一”的一方查询“多”的一方），反向查询属性默认的名字是<code>类名小写_set</code>（如上面例子中的<code>emp_set</code>），当然也可以在创建模型时通过<code>ForeingKey</code>的<code>related_name</code>属性指定反向查询属性的名字。如果不希望执行反向查询可以将<code>related_name</code>属性设置为<code>&#39;+&#39;</code>或以<code>&#39;+&#39;</code>开头的字符串。</p><p>说明2：查询多个对象的时候返回的是QuerySet对象，QuerySet使用了惰性查询，即在创建QuerySet对象的过程中不涉及任何数据库活动，等真正用到对象时（求值QuerySet）才向数据库发送SQL语句并获取对应的结果，这一点在实际开发中需要引起注意！</p><p>说明3：可以在QuerySet上使用<code>update()</code>方法一次更新多个对象。</p></blockquote><h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt;</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; Dept.objects.get(pk=40).delete()</span></span><br><span class="line">(1, &#123;'hrs.Dept': 1&#125;)</span><br></pre></td></tr></table></figure><h3 id="Django模型最佳实践"><a href="#Django模型最佳实践" class="headerlink" title="Django模型最佳实践"></a>Django模型最佳实践</h3><ol><li>正确的模型命名和关系字段命名。</li><li>设置适当的<code>related_name</code>属性。</li><li>用<code>OneToOneField</code>代替<code>ForeignKeyField(unique=True)</code>。</li><li>通过“迁移操作”（migrate）来添加模型。</li><li>用NoSQL来应对需要降低范式级别的场景。</li><li>如果布尔类型可以为空要使用<code>NullBooleanField</code>。</li><li>在模型中放置业务逻辑。</li><li>用<code>&lt;ModelName&gt;.DoesNotExists</code>取代<code>ObjectDoesNotExists</code>。</li><li>在数据库中不要出现无效数据。</li><li>不要对<code>QuerySet</code>调用<code>len()</code>函数。</li><li>将<code>QuerySet</code>的<code>exists()</code>方法的返回值用于<code>if</code>条件。</li><li>用<code>DecimalField</code>来存储货币相关数据而不是<code>FloatField</code>。</li><li>定义<code>__str__</code>方法。</li><li>不要将数据文件放在同一个目录中。</li></ol><blockquote><p>说明：以上内容来自于STEELKIWI网站的<a href="https://steelkiwi.com/blog/best-practices-working-django-models-python/" target="_blank" rel="noopener"><em>Best Practice working with Django models in Python</em></a>，有兴趣的小伙伴可以阅读原文。</p></blockquote><h3 id="模型定义参考"><a href="#模型定义参考" class="headerlink" title="模型定义参考"></a>模型定义参考</h3><h4 id="字段"><a href="#字段" class="headerlink" title="字段"></a>字段</h4><p>对字段名称的限制</p><ul><li>字段名不能是Python的保留字，否则会导致语法错误</li><li>字段名不能有多个连续下划线，否则影响ORM查询操作</li></ul><p>Django模型字段类</p><table><thead><tr><th>字段类</th><th>说明</th></tr></thead><tbody><tr><td>AutoField</td><td>自增ID字段</td></tr><tr><td>BigIntegerField</td><td>64位有符号整数</td></tr><tr><td>BinaryField</td><td>存储二进制数据的字段，对应Python的bytes类型</td></tr><tr><td>BooleanField</td><td>存储True或False</td></tr><tr><td>CharField</td><td>长度较小的字符串</td></tr><tr><td>DateField</td><td>存储日期，有auto_now和auto_now_add属性</td></tr><tr><td>DateTimeField</td><td>存储日期和日期，两个附加属性同上</td></tr><tr><td>DecimalField</td><td>存储固定精度小数，有max_digits（有效位数）和decimal_places（小数点后面）两个必要的参数</td></tr><tr><td>DurationField</td><td>存储时间跨度</td></tr><tr><td>EmailField</td><td>与CharField相同，可以用EmailValidator验证</td></tr><tr><td>FileField</td><td>文件上传字段</td></tr><tr><td>FloatField</td><td>存储浮点数</td></tr><tr><td>ImageField</td><td>其他同FileFiled，要验证上传的是不是有效图像</td></tr><tr><td>IntegerField</td><td>存储32位有符号整数。</td></tr><tr><td>GenericIPAddressField</td><td>存储IPv4或IPv6地址</td></tr><tr><td>NullBooleanField</td><td>存储True、False或null值</td></tr><tr><td>PositiveIntegerField</td><td>存储无符号整数（只能存储正数）</td></tr><tr><td>SlugField</td><td>存储slug（简短标注）</td></tr><tr><td>SmallIntegerField</td><td>存储16位有符号整数</td></tr><tr><td>TextField</td><td>存储数据量较大的文本</td></tr><tr><td>TimeField</td><td>存储时间</td></tr><tr><td>URLField</td><td>存储URL的CharField</td></tr><tr><td>UUIDField</td><td>存储全局唯一标识符</td></tr></tbody></table><h4 id="字段属性"><a href="#字段属性" class="headerlink" title="字段属性"></a>字段属性</h4><p>通用字段属性</p><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>null</td><td>数据库中对应的字段是否允许为NULL，默认为False</td></tr><tr><td>blank</td><td>后台模型管理验证数据时，是否允许为NULL，默认为False</td></tr><tr><td>choices</td><td>设定字段的选项，各元组中的第一个值是设置在模型上的值，第二值是人类可读的值</td></tr><tr><td>db_column</td><td>字段对应到数据库表中的列名，未指定时直接使用字段的名称</td></tr><tr><td>db_index</td><td>设置为True时将在该字段创建索引</td></tr><tr><td>db_tablespace</td><td>为有索引的字段设置使用的表空间，默认为DEFAULT_INDEX_TABLESPACE</td></tr><tr><td>default</td><td>字段的默认值</td></tr><tr><td>editable</td><td>字段在后台模型管理或ModelForm中是否显示，默认为True</td></tr><tr><td>error_messages</td><td>设定字段抛出异常时的默认消息的字典，其中的键包括null、blank、invalid、invalid_choice、unique和unique_for_date</td></tr><tr><td>help_text</td><td>表单小组件旁边显示的额外的帮助文本。</td></tr><tr><td>primary_key</td><td>将字段指定为模型的主键，未指定时会自动添加AutoField用于主键，只读。</td></tr><tr><td>unique</td><td>设置为True时，表中字段的值必须是唯一的</td></tr><tr><td>verbose_name</td><td>字段在后台模型管理显示的名称，未指定时使用字段的名称</td></tr></tbody></table><p>ForeignKey属性</p><ol><li>limit_choices_to：值是一个Q对象或返回一个Q对象，用于限制后台显示哪些对象。</li><li>related_name：用于获取关联对象的关联管理器对象（反向查询），如果不允许反向，该属性应该被设置为<code>&#39;+&#39;</code>，或者以<code>&#39;+&#39;</code>结尾。</li><li>to_field：指定关联的字段，默认关联对象的主键字段。</li><li>db_constraint：是否为外键创建约束，默认值为True。</li><li>on_delete：外键关联的对象被删除时对应的动作，可取的值包括django.db.models中定义的：<ul><li>CASCADE：级联删除。</li><li>PROTECT：抛出ProtectedError异常，阻止删除引用的对象。</li><li>SET_NULL：把外键设置为null，当null属性被设置为True时才能这么做。</li><li>SET_DEFAULT：把外键设置为默认值，提供了默认值才能这么做。</li></ul></li></ol><p>ManyToManyField属性</p><ol><li>symmetrical：是否建立对称的多对多关系。</li><li>through：指定维持多对多关系的中间表的Django模型。</li><li>throughfields：定义了中间模型时可以指定建立多对多关系的字段。</li><li>db_table：指定维持多对多关系的中间表的表名。</li></ol><h4 id="模型元数据选项"><a href="#模型元数据选项" class="headerlink" title="模型元数据选项"></a>模型元数据选项</h4><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>abstract</td><td>设置为True时模型是抽象父类</td></tr><tr><td>app_label</td><td>如果定义模型的应用不在INSTALLED_APPS中可以用该属性指定</td></tr><tr><td>db_table</td><td>模型使用的数据表名称</td></tr><tr><td>db_tablespace</td><td>模型使用的数据表空间</td></tr><tr><td>default_related_name</td><td>关联对象回指这个模型时默认使用的名称，默认为<model_name>_set</model_name></td></tr><tr><td>get_latest_by</td><td>模型中可排序字段的名称。</td></tr><tr><td>managed</td><td>设置为True时，Django在迁移中创建数据表并在执行flush管理命令时把表移除</td></tr><tr><td>order_with_respect_to</td><td>标记对象为可排序的</td></tr><tr><td>ordering</td><td>对象的默认排序</td></tr><tr><td>permissions</td><td>创建对象时写入权限表的额外权限</td></tr><tr><td>default_permissions</td><td>默认为<code>(&#39;add&#39;, &#39;change&#39;, &#39;delete&#39;)</code></td></tr><tr><td>unique_together</td><td>设定组合在一起时必须独一无二的字段名</td></tr><tr><td>index_together</td><td>设定一起建立索引的多个字段名</td></tr><tr><td>verbose_name</td><td>为对象设定人类可读的名称</td></tr><tr><td>verbose_name_plural</td><td>设定对象的复数名称</td></tr></tbody></table><h3 id="查询参考"><a href="#查询参考" class="headerlink" title="查询参考"></a>查询参考</h3><p>按字段查找可以用的条件：</p><ol><li>exact / iexact：精确匹配/忽略大小写的精确匹配查询</li><li>contains / icontains / startswith / istartswith / endswith / iendswith：基于<code>like</code>的模糊查询</li><li>in：集合运算</li><li>gt / gte / lt / lte：大于/大于等于/小于/小于等于关系运算</li><li>range：指定范围查询（SQL中的<code>between…and…</code>）</li><li>year / month / day / week_day / hour / minute / second：查询时间日期</li><li>isnull：查询空值（True）或非空值（False）</li><li>search：基于全文索引的全文检索</li><li>regex / iregex：基于正则表达式的模糊匹配查询</li></ol><p>Q对象（用于执行复杂查询）的使用：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt;</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; from django.db.models import Q</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; Emp.objects.filter(</span></span><br><span class="line">...     Q(name__startswith='张'),</span><br><span class="line">...     Q(sal__gte=5000) | Q(comm__gte=1000)</span><br><span class="line">... ) # 查询名字以“张”开头 工资大于等于5000或补贴大于等于1000的员工</span><br><span class="line">&lt;QuerySet [&lt;Emp: 张三丰&gt;]&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文档使用Django 2.x，Django是一个基于MVC架构的Web框架，MVC架构要追求的是模型和视图的解耦合，而其中的模型说得更直白一些就是数据，所以通常也被称作数据模型。在实际的项目中，数据模型通常通过数据库实现持久化操作，而关系型数据库在很长一段时间都是持久化的
      
    
    </summary>
    
      <category term="Django" scheme="http://gavinliu4011.github.io/categories/Django/"/>
    
    
      <category term="Django" scheme="http://gavinliu4011.github.io/tags/Django/"/>
    
  </entry>
  
  <entry>
    <title>Django(一)</title>
    <link href="http://gavinliu4011.github.io/post/e8c9ba97.html"/>
    <id>http://gavinliu4011.github.io/post/e8c9ba97.html</id>
    <published>2017-10-29T14:41:37.000Z</published>
    <updated>2017-10-29T06:41:50.755Z</updated>
    
    <content type="html"><![CDATA[<p>编写自己的第一个Django应用                                                                                                                                           </p><blockquote><p>创建项目</p></blockquote><ul><li>Windows环境下</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">### Windows环境下</span></span><br><span class="line"><span class="comment"># 创建根目录也就是你项目的容器</span></span><br><span class="line">$ mkdir mysite</span><br><span class="line"><span class="comment"># 切换到根目录</span></span><br><span class="line">$ <span class="built_in">cd</span> mysite/</span><br><span class="line"><span class="comment"># 建虚拟环境</span></span><br><span class="line">$ python -m venv venv</span><br><span class="line"><span class="comment"># 进入Scripts目录</span></span><br><span class="line">$ <span class="built_in">cd</span> venv</span><br><span class="line">$ <span class="built_in">cd</span> Scripts</span><br><span class="line"><span class="comment"># 激活环境</span></span><br><span class="line">$ activate</span><br><span class="line"><span class="comment"># 在虚拟环境下安装django依赖库</span></span><br><span class="line">(venv)$ pip install django</span><br><span class="line"><span class="comment"># 查看django版本</span></span><br><span class="line">(venv)$ django-admin --version</span><br><span class="line"><span class="comment"># 切换到根目录</span></span><br><span class="line">(venv)$ <span class="built_in">cd</span> ../..</span><br><span class="line"><span class="comment"># 创建项目</span></span><br><span class="line">(venv)$ django-admin startproject mysite .</span><br></pre></td></tr></table></figure><ul><li>Linux和macOS 环境</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## Linux和macOS 环境</span></span><br><span class="line"><span class="comment"># 创建项目文件夹</span></span><br><span class="line">$ mkdir mysite</span><br><span class="line"><span class="comment"># 切换到项目目录</span></span><br><span class="line">$ <span class="built_in">cd</span> mysite/</span><br><span class="line"><span class="comment"># 使用venv模块创建虚拟环境，目录名venv</span></span><br><span class="line">$ python3 -m venv venv</span><br><span class="line"><span class="comment"># 激活虚拟环境</span></span><br><span class="line">$ <span class="built_in">source</span> venv/bin/activate</span><br><span class="line"><span class="comment"># 更新pip到最新版本</span></span><br><span class="line">(venv)$ python -m pip install --upgrade pip</span><br><span class="line"><span class="comment"># 使用pip安装django</span></span><br><span class="line">(venv)$ pip install django</span><br><span class="line"><span class="comment"># 通过安装django时安装的脚本工具django-admin检查django版本</span></span><br><span class="line">(venv)$ django-admin --version</span><br><span class="line"><span class="comment"># 开启新项目</span></span><br><span class="line">(venv)$ django-admin startproject mysite .</span><br></pre></td></tr></table></figure><p>好了到现在为止,我们已经创建好了自己的一个Django项目,让我们看看 <a href="https://docs.djangoproject.com/zh-hans/2.0/ref/django-admin/#django-admin-startproject" target="_blank" rel="noopener">startproject</a> 创建了些什么:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysite/</span><br><span class="line">    manage.py</span><br><span class="line">    mysite/</span><br><span class="line">        __init__.py</span><br><span class="line">        settings.py</span><br><span class="line">        urls.py</span><br><span class="line">        wsgi.py</span><br></pre></td></tr></table></figure><p>下面我们简单的介绍上面每个文件是什么有什么作用</p><ul><li><code>manage.py</code>:用各种方式管理 Django 项目的命令行工具</li><li><code>__init__.py</code>:一个空文件，告诉 Python 这个目录应该被认为是一个 Python 包</li><li><code>settings.py</code>:整个Django 项目的配置文件</li><li><code>urls.py</code>:就像是地图,负责把URL模式映射到应用程序</li><li><code>wsgi.py</code>:用于项目部署</li></ul><blockquote><p>启动服务器</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(venv)$ python manage.py runserver</span><br></pre></td></tr></table></figure><p>你刚刚启动的是 Django 自带的用于开发的简易服务器，它是一个用纯 Python 写的轻量级的 Web 服务器。</p><p>现在我们用浏览器访问以下<a href="https://127.0.0.1:8000/" target="_blank" rel="noopener">https://127.0.0.1:8000/</a>，如果看到了小火箭那么恭喜你已经成功访问项目</p><p>Django默认端口是8000，如果你想更换服务器的监听端口，那么请运行<code>python manage.py runserver 8080</code>,如果你想在本地访问你服务器上的项目那么你需要执行<code>python manage.py runserver 0:8000</code>,<code>python manage.py runserver 0.0.0.0:8000</code>,这里的<strong>0</strong>相当于<strong>0.0.0.0</strong></p><blockquote><p>创建应用</p></blockquote><p>一个项目下我们可以有多个应用,现在我们来创建自己的第一个应用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(venv)$ python manage.py startapp hrs</span><br></pre></td></tr></table></figure><p>下面我们来看看<code>startapp</code>命令创建了些什么:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">hrs/</span><br><span class="line">    __init__.py</span><br><span class="line">    admin.py</span><br><span class="line">    apps.py</span><br><span class="line">    migrations/</span><br><span class="line">        __init__.py</span><br><span class="line">    models.py</span><br><span class="line">    tests.py</span><br><span class="line">    views.py</span><br></pre></td></tr></table></figure><ul><li><code>__init__.py</code>: 一个空文件,告诉Python这个目录应该被认为是一个包</li><li><code>admin.py</code>: 可以用来注册模型,让Django自动创建管理界面</li><li><code>apps.py</code>: 当前应用的配置</li><li><code>migrations</code>: 存放与模型有关的数据库信息<ul><li><code>__init__.py</code>: 也是一个空文件,告诉Python这个目录应该被认为是一个包</li></ul></li><li><code>models.py</code>:存放应用的数据模型,即实体类及其之间的关系(MVC/MVT中的M)</li><li><code>tests.py</code>: 测试应用的各种测试函数</li><li><code>views.py</code>: 处理请求并返回响应的函数(MVC中的C,MVT中的V)</li></ul><blockquote><p>创建一个视图</p></blockquote><p>hrs/views.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.http <span class="keyword">import</span> HttpResponse</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">home</span><span class="params">(request)</span>:</span>    </span><br><span class="line"><span class="keyword">return</span> HttpResponse(<span class="string">'&lt;h1&gt;Hello, Django!&lt;/h1&gt;'</span>)</span><br></pre></td></tr></table></figure><p>完成后,到项目目录,修改该目录下的urls.py文件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.contrib <span class="keyword">import</span> admin</span><br><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path</span><br><span class="line"><span class="keyword">from</span> hrs <span class="keyword">import</span> views</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">'hrs/'</span>, views.home),</span><br><span class="line">    path(<span class="string">'admin/'</span>, admin.site.urls),</span><br><span class="line">]</span><br></pre></td></tr></table></figure><blockquote><p>注意:我们还可以为应用单独建立一个urls.py文件来映射请求的URL,如下面:</p></blockquote><p>在hrs引用下创建一个urls.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path</span><br><span class="line"><span class="keyword">from</span> hrs <span class="keyword">import</span> views</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">''</span>, views.home, name=<span class="string">'index'</span>),</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>那么相应的我们在项目的urls.py文件中应当做出改变:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.contrib <span class="keyword">import</span> admin</span><br><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path, include</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">'hrs/'</span>, include(<span class="string">'hrs.urls'</span>)),</span><br><span class="line">    path(<span class="string">'admin/'</span>, admin.site.urls),</span><br><span class="line">]</span><br></pre></td></tr></table></figure><blockquote><p>使用视图模板</p></blockquote><p>在manage.py所在的同级目录下创建一个templates文件夹</p><p>接下来便是创建一个个模板页面,在这里我创建一个index.html模板页面</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;&#123; greeting &#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123; current_time &#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line">    今天为你推荐&#123;&#123; num &#125;&#125;种水果:</span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">        &#123;% for fruit in fruits %&#125;</span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span>&#123;&#123; fruit &#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        &#123;% endfor %&#125;</span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>要使用模板我们要改相应的配置,切换到配置文件目录找到setting.py文件</p><p>我们需要修改<code>TEMPLATES</code>的配置,代码如下所示:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">TEMPLATES = [</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">'BACKEND'</span>: <span class="string">'django.template.backends.django.DjangoTemplates'</span>,</span><br><span class="line">        <span class="string">'DIRS'</span>: [os.path.join(BASE_DIR, <span class="string">'templates'</span>)],  <span class="comment"># 将DIRS路径配置成模板页面所在的路径</span></span><br><span class="line">        <span class="string">'APP_DIRS'</span>: <span class="keyword">True</span>,</span><br><span class="line">        <span class="string">'OPTIONS'</span>: &#123;</span><br><span class="line">            <span class="string">'context_processors'</span>: [</span><br><span class="line">                <span class="string">'django.template.context_processors.debug'</span>,</span><br><span class="line">                <span class="string">'django.template.context_processors.request'</span>,</span><br><span class="line">                <span class="string">'django.contrib.auth.context_processors.auth'</span>,</span><br><span class="line">                <span class="string">'django.contrib.messages.context_processors.messages'</span>,</span><br><span class="line">            ],</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>要渲染模板我们需要在views.py中传递参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> randrange</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> render</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">home</span><span class="params">(req)</span>:</span></span><br><span class="line">    fruit = [<span class="string">'大苹果'</span>, <span class="string">'水晶葡萄'</span>, <span class="string">'大西瓜'</span>, <span class="string">'石榴'</span>, <span class="string">'桃子'</span>, <span class="string">'李子'</span>, <span class="string">'梨子'</span>]</span><br><span class="line">    len_f = randrange(<span class="number">1</span>, len(fruit))</span><br><span class="line">    fruits = set()</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> range(len_f):</span><br><span class="line">        index = randrange(<span class="number">0</span>, len(fruit))</span><br><span class="line">        fruits.add(fruit[index])</span><br><span class="line"></span><br><span class="line">    ctx = &#123;</span><br><span class="line">        <span class="string">'greeting'</span>: <span class="string">'你好,世界'</span>,</span><br><span class="line">        <span class="string">'current_time'</span>: datetime.now,</span><br><span class="line">        <span class="string">'num'</span>: len(fruits),</span><br><span class="line">        <span class="string">'fruits'</span>: fruits,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> render(req, <span class="string">'index.html'</span>, ctx)</span><br></pre></td></tr></table></figure><p>到这里我们完成了一个简单的Django项目,现在我们将项目重新运行查看一下结果</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(venv)$ python manage.py runserver 0:8000</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;编写自己的第一个Django应用                                                                                                                         
      
    
    </summary>
    
      <category term="Django" scheme="http://gavinliu4011.github.io/categories/Django/"/>
    
    
      <category term="Django" scheme="http://gavinliu4011.github.io/tags/Django/"/>
    
  </entry>
  
  <entry>
    <title>Python3.x 连接MySQL数据库</title>
    <link href="http://gavinliu4011.github.io/post/64b3833f.html"/>
    <id>http://gavinliu4011.github.io/post/64b3833f.html</id>
    <published>2017-10-12T09:29:05.000Z</published>
    <updated>2017-10-12T01:29:22.908Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Python3-x-连接MySQL数据库"><a href="#Python3-x-连接MySQL数据库" class="headerlink" title="Python3.x 连接MySQL数据库"></a>Python3.x 连接MySQL数据库</h3><p>由于 MySQLdb 模块还不支持 Python3.x，所以 Python3.x 如果想连接MySQL需要安装 pymysql 模块。</p><p>pymysql 模块可以通过 pip 安装<code>pip install PyMySQL</code></p><blockquote><p>用pymysql连接数据库</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">conn = pymysql.connect(host=<span class="string">'localhost'</span>,</span><br><span class="line">                           port=<span class="number">3306</span>,</span><br><span class="line">                           user=<span class="string">'root'</span>,</span><br><span class="line">                           password=<span class="string">'root'</span>,</span><br><span class="line">                           db=<span class="string">'hrs'</span>,</span><br><span class="line">                           charset=<span class="string">'utf8'</span>,</span><br><span class="line">                           autocommit=<span class="keyword">False</span>  <span class="comment"># 默认不自动提交</span></span><br><span class="line">                           )</span><br></pre></td></tr></table></figure><ul><li><p>常用参数说明:</p><p>​<code>host</code>:主机IP</p><p>​<code>port</code>:端口号</p><p>​<code>user</code>:mysql登录用户名</p><p>​<code>password</code>:mysql登录密码</p><p>​<code>db</code>:数据库名称</p><p>​<code>charset</code>:连接数据库采用的字符编码</p><p><code>autocommit</code>:默认值是False,DML(数据操纵语言)不会自动提交,如果为True则会自动提交</p><p><code>cursorclass</code>:pymysql.cursors.DictCursor - 设置游标的类型,查询返回的结果是以字典的方式</p></li><li><p>测试是否连接成功</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(conn)</span><br><span class="line">$ &lt;pymysql.connections.Connection object at <span class="number">0x05656EB0</span>&gt;</span><br></pre></td></tr></table></figure></li></ul><p>如果运行上面的语句不报错,并且看到了输出到控制台的值,那么我们则用pymysql连接上了MySQL数据库.</p><blockquote><p>方法介绍</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">connection对象常用的方法</span><br><span class="line">cursor()        使用该连接创建并返回游标</span><br><span class="line">commit()        提交当前事务</span><br><span class="line">rollback()      回滚当前事务</span><br><span class="line">close()         关闭连接</span><br><span class="line"></span><br><span class="line">cursor对象常用的方法和属性</span><br><span class="line">execute(sql)    执行一个数据库的查询命令</span><br><span class="line">fetchone()      取得结果集的下一行</span><br><span class="line">fetchmany(size) 获取结果集的下几行</span><br><span class="line">fetchall()      获取结果集中的所有行</span><br><span class="line">rowcount      返回数据条数或影响行数</span><br><span class="line">close()         关闭游标对象</span><br></pre></td></tr></table></figure><p>在介绍上面方法使用前再看看连接数据库的代码块,其中有一个很重要的参数<strong>db</strong> (数据库名称),所以我们应当在连接数据库之前，先创建一个数据库，方便测试 pymysql 的功能</p><blockquote><p>使用Python实现增删改查和事务处理</p></blockquote><p>首先我们在上面说的<code>hrs</code>数据库中创建一张部门表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建部门表</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> tbdept</span><br><span class="line">(</span><br><span class="line">dno <span class="built_in">int</span>,<span class="comment">-- 部门编号</span></span><br><span class="line">dname <span class="built_in">varchar</span>(<span class="number">10</span>) <span class="keyword">not</span> <span class="literal">null</span>,  <span class="comment">-- 部门名称</span></span><br><span class="line">dloc <span class="built_in">varchar</span>(<span class="number">20</span>) <span class="keyword">not</span> <span class="literal">null</span>,  <span class="comment">-- 部门所在地</span></span><br><span class="line">primary <span class="keyword">key</span> (dno)</span><br><span class="line">);</span><br><span class="line"><span class="comment">-- 添加部门记录</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tbdept <span class="keyword">values</span> </span><br><span class="line">(<span class="number">10</span>, <span class="string">'会计部'</span>, <span class="string">'北京'</span>),</span><br><span class="line">(<span class="number">20</span>, <span class="string">'研发部'</span>, <span class="string">'成都'</span>),</span><br><span class="line">(<span class="number">30</span>, <span class="string">'销售部'</span>, <span class="string">'重庆'</span>),</span><br><span class="line">(<span class="number">40</span>, <span class="string">'运维部'</span>, <span class="string">'深圳'</span>);</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_conn</span><span class="params">()</span>:</span></span><br><span class="line">    config = &#123;</span><br><span class="line">        <span class="string">'host'</span>: <span class="string">'localhost'</span>,</span><br><span class="line">        <span class="string">'port'</span>: <span class="number">3306</span>,</span><br><span class="line">        <span class="string">'user'</span>: <span class="string">'root'</span>,</span><br><span class="line">        <span class="string">'password'</span>: <span class="string">'root'</span>,</span><br><span class="line">        <span class="string">'db'</span>: <span class="string">'hrs'</span>,</span><br><span class="line">        <span class="string">'charset'</span>: <span class="string">'utf8'</span>,</span><br><span class="line">        <span class="string">'autocommit'</span>: <span class="keyword">False</span>,  <span class="comment"># 默认不自动提交</span></span><br><span class="line">        <span class="string">'cursorclass'</span>: pymysql.cursors.DictCursor  <span class="comment"># 设置游标的类型,查询返回的结果是以字典的方式</span></span><br><span class="line">    &#125;</span><br><span class="line">    conn = pymysql.connect(**config)</span><br><span class="line">    <span class="keyword">return</span> conn</span><br></pre></td></tr></table></figure><ul><li><p>下面我们先来看看添加的操作:</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insert</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    插入</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="comment"># Connection(连接) / Cursor(游标)</span></span><br><span class="line">    conn = get_conn()</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># 创建Cursor对象,cursor支持上下文语法,可以放在with中</span></span><br><span class="line">        <span class="keyword">with</span> conn.cursor() <span class="keyword">as</span> cursor:</span><br><span class="line">            <span class="comment"># 向数据库发出sql语句</span></span><br><span class="line">            dno = input(<span class="string">'部门编号:'</span>)</span><br><span class="line">            dname = input(<span class="string">'部门名称:'</span>)</span><br><span class="line">            dloc = input(<span class="string">'部门地址:'</span>)</span><br><span class="line">            <span class="comment"># 如果使用字符串格式化的方式来组装SQL语句</span></span><br><span class="line">            <span class="comment"># 最大的风险是用被SQL注射攻击</span></span><br><span class="line">            <span class="comment"># sql = "insert into tbdept values (%d, '%s', '%s')" % (dno, dname, dloc)</span></span><br><span class="line">            <span class="comment"># result = cursor.execute(sql)</span></span><br><span class="line">            <span class="comment"># result = cursor.execute('insert into tbdept values (%s, %s, %s)', (dno, dname, dloc))</span></span><br><span class="line">            <span class="comment"># 这个方式传参是以字典的方式,但是要注意的是在占位的时候用%(name)s</span></span><br><span class="line">            result = cursor.execute(</span><br><span class="line">                <span class="string">'insert into tbdept values (%(dno)s, %(dname)s, %(dloc)s)'</span>,</span><br><span class="line">                &#123;<span class="string">'dno'</span>: dno, <span class="string">'dname'</span>: dname, <span class="string">'dloc'</span>: dloc&#125;</span><br><span class="line">            )</span><br><span class="line">            <span class="comment"># print('成功插入', cursor.rowcount, '条数据') # 这里cursor.rowcount是获取到受影响的行</span></span><br><span class="line">            print(<span class="string">'成功插入'</span>, result, <span class="string">'条数据'</span>)</span><br><span class="line">            conn.commit()</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        conn.close()</span><br></pre></td></tr></table></figure></li><li><p>修改操作</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">update</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    修改</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    conn = get_conn()</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">with</span> conn.cursor() <span class="keyword">as</span> cursor:</span><br><span class="line">            dno = input(<span class="string">'部门编号:'</span>)</span><br><span class="line">            dname = input(<span class="string">'部门名称:'</span>)</span><br><span class="line">            <span class="comment"># 这个方式传参是以字典的方式,但是要注意的是在占位的时候用%(name)s</span></span><br><span class="line">            result = cursor.execute(</span><br><span class="line">                <span class="string">'update tbdept set dname=%(dname)s where dno=%(dno)s'</span>,</span><br><span class="line">                &#123;<span class="string">'dno'</span>: dno, <span class="string">'dname'</span>: dname&#125;</span><br><span class="line">            )</span><br><span class="line">            <span class="comment"># print('成功插入', cursor.rowcount, '条数据') # 这里cursor.rowcount是获取到受影响的行</span></span><br><span class="line">            print(<span class="string">'成功修改'</span>, result, <span class="string">'条数据'</span>)</span><br><span class="line">            conn.commit()</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        conn.close()</span><br></pre></td></tr></table></figure></li><li><p>删除操作</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span><span class="params">(dno)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    根据编号删除</span></span><br><span class="line"><span class="string">    :param dno: 编号</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    conn = get_conn()</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">with</span> conn.cursor() <span class="keyword">as</span> cursor:</span><br><span class="line">            <span class="comment"># 向数据库发出sql语句</span></span><br><span class="line">            <span class="comment"># execute方法中占位后传参除了元组和字典外,还可以是列表</span></span><br><span class="line">            result = cursor.execute(<span class="string">'delete from tbdept where dno=%s'</span>, [dno])</span><br><span class="line">            <span class="comment"># 如果事务中的所有操作全部成功了最后手动提交</span></span><br><span class="line">            conn.commit()</span><br><span class="line">            print(<span class="string">'删除成功'</span> <span class="keyword">if</span> result == <span class="number">1</span> <span class="keyword">else</span> <span class="string">'删除失败'</span>)</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        print(e)</span><br><span class="line">        <span class="comment"># 如果事务操作有任何一个操作发生异常,那么就会回滚事务</span></span><br><span class="line">        conn.rollback()</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        conn.close()</span><br></pre></td></tr></table></figure></li><li><p>查询操作</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">select</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    查询</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    conn = get_conn()</span><br><span class="line">    print(conn)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># 创建Cursor对象</span></span><br><span class="line">        <span class="keyword">with</span> conn.cursor() <span class="keyword">as</span> cursor:</span><br><span class="line">            <span class="comment"># 向数据库发出sql语句</span></span><br><span class="line">            cursor.execute(<span class="string">'select dno, dname, dloc from tbdept'</span>)</span><br><span class="line">            result = cursor.fetchone()</span><br><span class="line">            <span class="comment"># 程序中最好不要使用fetchall(),如果库中数据量很大,那么脑补一下会有什么样的结果呢</span></span><br><span class="line">            <span class="keyword">while</span> result:</span><br><span class="line">                print(result)</span><br><span class="line">                <span class="comment"># 取出部门名称</span></span><br><span class="line">                <span class="comment"># 在这里我上面连接数据时,使用了cursorclass参数,查询时返回的结果是以字典的方式</span></span><br><span class="line">                print(result[<span class="string">'dname'</span>])</span><br><span class="line">                result = cursor.fetchone()</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        conn.close()</span><br></pre></td></tr></table></figure></li></ul><p>到现在我们已经简单的介绍了用pymysql完成了对数据库的CURD操作</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Python3-x-连接MySQL数据库&quot;&gt;&lt;a href=&quot;#Python3-x-连接MySQL数据库&quot; class=&quot;headerlink&quot; title=&quot;Python3.x 连接MySQL数据库&quot;&gt;&lt;/a&gt;Python3.x 连接MySQL数据库&lt;/h3&gt;&lt;
      
    
    </summary>
    
      <category term="Python" scheme="http://gavinliu4011.github.io/categories/Python/"/>
    
    
      <category term="Python" scheme="http://gavinliu4011.github.io/tags/Python/"/>
    
      <category term="pymysql" scheme="http://gavinliu4011.github.io/tags/pymysql/"/>
    
      <category term="MySQL" scheme="http://gavinliu4011.github.io/tags/MySQL/"/>
    
  </entry>
  
</feed>
