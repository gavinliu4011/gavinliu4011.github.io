{"meta":{"title":"刘泰丞的个人博客","subtitle":"刘泰丞的个人博客","description":"刘泰丞的个人网站，记录生活的瞬间，分享学习的心得，感悟生活，留住感动","author":"GavinLiu","url":"http://gavinliu4011.github.io"},"pages":[],"posts":[{"title":"Django(一)","slug":"django","date":"2018-05-21T08:54:26.000Z","updated":"2018-05-24T03:08:32.335Z","comments":false,"path":"2018/05/21/django/","link":"","permalink":"http://gavinliu4011.github.io/2018/05/21/django/","excerpt":"","text":"编写自己的第一个Django应用 创建项目 Windows环境下 1234567891011121314151617181920### Windows环境下# 创建根目录也就是你项目的容器$ mkdir mysite# 切换到根目录$ cd mysite/# 建虚拟环境$ python -m venv venv# 进入Scripts目录$ cd venv$ cd Scripts# 激活环境$ activate# 在虚拟环境下安装django依赖库(venv)$ pip install django# 查看django版本(venv)$ django-admin --version# 切换到根目录(venv)$ cd ../..# 创建项目(venv)$ django-admin startproject mysite . Linux和macOS 环境 1234567891011121314151617## Linux和macOS 环境# 创建项目文件夹$ mkdir mysite# 切换到项目目录$ cd mysite/# 使用venv模块创建虚拟环境，目录名venv$ python3 -m venv venv# 激活虚拟环境$ source venv/bin/activate# 更新pip到最新版本(venv)$ python -m pip install --upgrade pip# 使用pip安装django(venv)$ pip install django# 通过安装django时安装的脚本工具django-admin检查django版本(venv)$ django-admin --version# 开启新项目(venv)$ django-admin startproject mysite . 好了到现在为止,我们已经创建好了自己的一个Django项目,让我们看看 startproject 创建了些什么: 1234567mysite/ manage.py mysite/ __init__.py settings.py urls.py wsgi.py 下面我们简单的介绍上面每个文件是什么有什么作用 manage.py:用各种方式管理 Django 项目的命令行工具 __init__.py:一个空文件，告诉 Python 这个目录应该被认为是一个 Python 包 settings.py:整个Django 项目的配置文件 urls.py:就像是地图,负责把URL模式映射到应用程序 wsgi.py:用于项目部署 启动服务器 1(venv)$ python manage.py runserver 你刚刚启动的是 Django 自带的用于开发的简易服务器，它是一个用纯 Python 写的轻量级的 Web 服务器。 现在我们用浏览器访问以下https://127.0.0.1:8000/，如果看到了小火箭那么恭喜你已经成功访问项目 Django默认端口是8000，如果你想更换服务器的监听端口，那么请运行python manage.py runserver 8080,如果你想在本地访问你服务器上的项目那么你需要执行python manage.py runserver 0:8000,python manage.py runserver 0.0.0.0:8000,这里的0相当于0.0.0.0 创建应用 一个项目下我们可以有多个应用,现在我们来创建自己的第一个应用 1(venv)$ python manage.py startapp hrs 下面我们来看看startapp命令创建了些什么: 123456789hrs/ __init__.py admin.py apps.py migrations/ __init__.py models.py tests.py views.py __init__.py: 一个空文件,告诉Python这个目录应该被认为是一个包 admin.py: 可以用来注册模型,让Django自动创建管理界面 apps.py: 当前应用的配置 migrations: 存放与模型有关的数据库信息 __init__.py: 也是一个空文件,告诉Python这个目录应该被认为是一个包 models.py:存放应用的数据模型,即实体类及其之间的关系(MVC/MVT中的M) tests.py: 测试应用的各种测试函数 views.py: 处理请求并返回响应的函数(MVC中的C,MVT中的V) 创建一个视图 hrs/views.py 123from django.http import HttpResponsedef home(request): return HttpResponse('&lt;h1&gt;Hello, Django!&lt;/h1&gt;') 完成后,到项目目录,修改该目录下的urls.py文件 12345678from django.contrib import adminfrom django.urls import pathfrom hrs import viewsurlpatterns = [ path('hrs/', views.home), path('admin/', admin.site.urls),] 注意:我们还可以为应用单独建立一个urls.py文件来映射请求的URL,如下面: 在hrs引用下创建一个urls.py 123456from django.urls import pathfrom hrs import viewsurlpatterns = [ path('', views.home, name='index'),] 那么相应的我们在项目的urls.py文件中应当做出改变: 1234567from django.contrib import adminfrom django.urls import path, includeurlpatterns = [ path('hrs/', include('hrs.urls')), path('admin/', admin.site.urls),] 使用视图模板 在manage.py所在的同级目录下创建一个templates文件夹 接下来便是创建一个个模板页面,在这里我创建一个index.html模板页面 12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;首页&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;&#123;&#123; greeting &#125;&#125;&lt;/h1&gt; &lt;h2&gt;&#123;&#123; current_time &#125;&#125;&lt;/h2&gt; &lt;hr&gt; 今天为你推荐&#123;&#123; num &#125;&#125;种水果: &lt;ul&gt; &#123;% for fruit in fruits %&#125; &lt;li&gt;&#123;&#123; fruit &#125;&#125;&lt;/li&gt; &#123;% endfor %&#125; &lt;/ul&gt;&lt;/body&gt;&lt;/html&gt; 要使用模板我们要改相应的配置,切换到配置文件目录找到setting.py文件 我们需要修改TEMPLATES的配置,代码如下所示: 123456789101112131415TEMPLATES = [ &#123; 'BACKEND': 'django.template.backends.django.DjangoTemplates', 'DIRS': [os.path.join(BASE_DIR, 'templates')], # 将DIRS路径配置成模板页面所在的路径 'APP_DIRS': True, 'OPTIONS': &#123; 'context_processors': [ 'django.template.context_processors.debug', 'django.template.context_processors.request', 'django.contrib.auth.context_processors.auth', 'django.contrib.messages.context_processors.messages', ], &#125;, &#125;,] 要渲染模板我们需要在views.py中传递参数 12345678910111213141516171819202122from datetime import datetimefrom random import randrangefrom django.shortcuts import renderdef home(req): fruit = ['大苹果', '水晶葡萄', '大西瓜', '石榴', '桃子', '李子', '梨子'] len_f = randrange(1, len(fruit)) fruits = set() for _ in range(len_f): index = randrange(0, len(fruit)) fruits.add(fruit[index]) ctx = &#123; 'greeting': '你好,世界', 'current_time': datetime.now, 'num': len(fruits), 'fruits': fruits, &#125; return render(req, 'index.html', ctx) 到这里我们完成了一个简单的Django项目,现在我们将项目重新运行查看一下结果 1(venv)$ python manage.py runserver 0:8000","categories":[{"name":"Django","slug":"Django","permalink":"http://gavinliu4011.github.io/categories/Django/"}],"tags":[{"name":"Django","slug":"Django","permalink":"http://gavinliu4011.github.io/tags/Django/"}],"keywords":[{"name":"Django","slug":"Django","permalink":"http://gavinliu4011.github.io/categories/Django/"}]},{"title":"用Python操作Redis","slug":"redis","date":"2018-05-17T19:43:48.000Z","updated":"2018-05-25T12:53:33.206Z","comments":false,"path":"2018/05/18/redis/","link":"","permalink":"http://gavinliu4011.github.io/2018/05/18/redis/","excerpt":"","text":"Redis安装和使用Window 下安装下载地址：https://github.com/MSOpenTech/redis/releases。 Redis 支持 32 位和 64 位。这个需要根据你系统平台的实际情况选择，这里我们下载 Redis-x64-xxx.zip压缩包到 C 盘，解压后，将文件夹重新命名为 redis。 打开一个 cmd 窗口 使用cd命令切换目录到 C:\\redis 运行 redis-server.exe redis.windows.conf 。 如果想方便的话，可以把 redis 的路径加到系统的环境变量里，这样就省得再输路径了，后面的那个 redis.windows.conf 可以省略，如果省略，会启用默认的。输入之后，会显示如下界面： 这时候另启一个cmd窗口，原来的不要关闭，不然就无法访问服务端了。 切换到redis目录下运行 redis-cli.exe -h 127.0.0.1 -p 6379 。 设置键值对 set myKey abc 取出键值对 get myKey Linux 下安装下载地址：http://redis.io/download，下载最新稳定版本。 本文档使用3.2.11,下载并安装: 1234$ wget http://download.redis.io/releases/redis-3.2.11.tar.gz$ tar -xvf redis-3.2.11.tar.gz$ cd redis-3.2.11$ make &amp;&amp; make install 安装完成后,我们先改一下redis.conf的配置: 123456789$ cp redis.conf ../myredis.conf # 将文件redis.conf复制到上以及文件夹下并命名为myredis.conf$ cd ..$ vim myredis.conf# redis.conf是一个默认的配置文件。我们可以根据需要使用自己的配置文件。# 建议修改以下地方:# 找到bind这个地方并修改成[bind 本机内网地址]# 再找到requirepass这个地方,这里是修改redis的密码# 完成上述操作后保存退出$ redis-server myredis.conf 启动redis服务进程后，就可以使用测试客户端程序redis-cli和redis服务交互了,如: 12345$ redis-cli -h host -p port$ auth [password] # 这里输入的密码就是你上面设置的密码,如果没有则跳过此步骤redis 127.0.0.1:6379&gt; pingPONG$ redis-cli -h host -p port -a password # 这个命令也能登录 用Python连接Redis当前在本地我已经安装了 Redis 并运行在 9736 端口，密码设置为 123456 用下面例子连接Redis进行测试: 123456789101112131415161718import redisdef main(): config = &#123; 'host': 'localhost', 'port': 9736, 'db': 0, 'password': '123456' &#125; client = redis.Redis(**config) if client.ping(): client.set('name', 'gavinliu') print(client.get('name'))if __name__ == '__main__': main() 在这里我们使用redis.Redis传入参数连接本地Redis服务,传入的四个参数分别为Redis的地址、运行端口、使用的数据库、密码，我们这里使用的Redis其实是继承了StrictRedis，所以在默认情况下不传这四个参数时，参数值会有默认值分别为localhost、6379、0、None。 上面运行的结果： 1b'gavinliu' 在Python中使用Redis其实很方便，Redis的命令(命令详细情况可以参照Redis命令参考)在Python中都能找到相应的方法，这里引用崔庆才老师对Redis总结介绍一下Key(键)、String(字符串)、Hash(哈希表)、List(列表)、Set(集合)、SortedSet(有序集合) Key(键) 方法 作用 参数说明 示例 示例说明 示例结果 exists(name) 判断一个key是否存在 name: key名 redis.exists(‘name’) 是否存在name这个key True delete(name) 删除一个key name: key名 redis.delete(‘name’) 删除name这个key 1 type(name) 判断key类型 name: key名 redis.type(‘name’) 判断name这个key类型 b’string’ keys(pattern) 获取所有符合规则的key pattern: 匹配规则 redis.keys(‘n*’) 获取所有以n开头的key [b’name’] randomkey() 获取随机的一个key randomkey() 获取随机的一个key b’name’ rename(src, dst) 将key重命名 src: 原key名 dst: 新key名 redis.rename(‘name’, ‘nickname’) 将name重命名为nickname True dbsize() 获取当前数据库中key的数目 dbsize() 获取当前数据库中key的数目 100 expire(name, time) 设定key的过期时间，单位秒 name: key名 time: 秒数 redis.expire(‘name’, 2) 将name这key的过期时间设置2秒 True ttl(name) 获取key的过期时间，单位秒，-1为永久不过期 name: key名 redis.ttl(‘name’) 获取name这key的过期时间 -1 move(name, db) 将key移动到其他数据库 name: key名 db: 数据库代号 move(‘name’, 2) 将name移动到2号数据库 True flushdb() 删除当前选择数据库中的所有key flushdb() 删除当前选择数据库中的所有key True flushall() 删除所有数据库中的所有key flushall() 删除所有数据库中的所有key True String(字符串) 方法 作用 参数说明 示例 示例说明 示例结果 set(name, value) 给数据库中key为name的string赋予值value name: key名 value: 值 redis.set(‘name’, ‘Bob’) 给name这个key的value赋值为Bob True get(name) 返回数据库中key为name的string的value name: key名 redis.get(‘name’) 返回name这个key的value b’Bob’ getset(name, value) 给数据库中key为name的string赋予值value并返回上次的value name: key名 value: 新值 redis.getset(‘name’, ‘Mike’) 赋值name为Mike并得到上次的value b’Bob’ mget(keys, *args) 返回多个key对应的value keys: key的列表 redis.mget([‘name’, ‘nickname’]) 返回name和nickname的value [b’Mike’, b’Miker’] setnx(name, value) 如果key不存在才设置value name: key名 redis.setnx(‘newname’, ‘James’) 如果newname这key不存在则设置值为James 第一次运行True，第二次False setex(name, time, value) 设置可以对应的值为string类型的value，并指定此键值对应的有效期 name: key名 time: 有效期 value: 值 redis.setex(‘name’, 1, ‘James’) 将name这key的值设为James，有效期1秒 True setrange(name, offset, value) 设置指定key的value值的子字符串 name: key名 offset: 偏移量 value: 值 redis.set(‘name’, ‘Hello’) redis.setrange(‘name’, 6, ‘World’) 设置name为Hello字符串，并在index为6的位置补World 11，修改后的字符串长度 mset(mapping) 批量赋值 mapping: 字典 redis.mset({‘name1’: ‘Durant’, ‘name2’: ‘James’}) 将name1设为Durant，name2设为James True msetnx(mapping) key均不存在时才批量赋值 mapping: 字典 redis.msetnx({‘name3’: ‘Smith’, ‘name4’: ‘Curry’}) 在name3和name4均不存在的情况下才设置二者值 True incr(name, amount=1) key为name的value增值操作，默认1，key不存在则被创建并设为amount name: key名 amount:增长的值 redis.incr(‘age’, 1) age对应的值增1，若不存在则会创建并设置为1 1，即修改后的值 decr(name, amount=1) key为name的value减值操作，默认1，key不存在则被创建并设置为-amount name: key名 amount:减少的值 redis.decr(‘age’, 1) age对应的值减1，若不存在则会创建并设置为-1 -1，即修改后的值 append(key, value) key为name的string的值附加value key: key名 redis.append(‘nickname’, ‘OK’) 向key为nickname的值后追加OK 13，即修改后的字符串长度 substr(name, start, end=-1) 返回key为name的string的value的子串 name: key名 start: 起始索引 end: 终止索引，默认-1截取到末尾 redis.substr(‘name’, 1, 4) 返回key为name的值的字符串，截取索引为1-4的字符 b’ello’ getrange(key, start, end) 获取key的value值从start到end的子字符串 key: key名 start: 起始索引 end: 终止索引 redis.getrange(‘name’, 1, 4) 返回key为name的值的字符串，截取索引为1-4的字符 b’ello’ Hash(哈希表) Hash，即哈希。Redis 还提供了哈希表的数据结构，我们可以用name指定一个哈希表的名称，然后表内存储了各个键值对，用法总结如下： 方法 作用 参数说明 示例 示例说明 示例结果 hset(name, key, value) 向key为name的hash中添加映射 name: key名 key: 映射键名 value: 映射键值 hset(‘price’, ‘cake’, 5) 向key为price的hash中添加映射关系，cake的值为5 1，即添加的映射个数 hsetnx(name, key, value) 向key为name的hash中添加映射，如果映射键名不存在 name: key名 key: 映射键名 value: 映射键值 hsetnx(‘price’, ‘book’, 6) 向key为price的hash中添加映射关系，book的值为6 1，即添加的映射个数 hget(name, key) 返回key为name的hash中field对应的value name: key名 key: 映射键名 redis.hget(‘price’, ‘cake’) 获取key为price的hash中键名为cake的value 5 hmget(name, keys, *args) 返回key为name的hash中各个键对应的value name: key名 keys: 映射键名列表 redis.hmget(‘price’, [‘apple’, ‘orange’]) 获取key为price的hash中apple和orange的值 [b’3’, b’7’] hmset(name, mapping) 向key为name的hash中批量添加映射 name: key名 mapping: 映射字典 redis.hmset(‘price’, {‘banana’: 2, ‘pear’: 6}) 向key为price的hash中批量添加映射 True hincrby(name, key, amount=1) 将key为name的hash中映射的value增加amount name: key名 key: 映射键名 amount: 增长量 redis.hincrby(‘price’, ‘apple’, 3) key为price的hash中apple的值增加3 6，修改后的值 hexists(name, key) key为namehash中是否存在键名为key的映射 name: key名 key: 映射键名 redis.hexists(‘price’, ‘banana’) key为price的hash中banana的值是否存在 True hdel(name, *keys) key为namehash中删除键名为key的映射 name: key名 key: 映射键名 redis.hdel(‘price’, ‘banana’) 从key为price的hash中删除键名为banana的映射 True hlen(name) 从key为name的hash中获取映射个数 name: key名 redis.hlen(‘price’) 从key为price的hash中获取映射个数 6 hkeys(name) 从key为name的hash中获取所有映射键名 name: key名 redis.hkeys(‘price’) 从key为price的hash中获取所有映射键名 [b’cake’, b’book’, b’banana’, b’pear’] hvals(name) 从key为name的hash中获取所有映射键值 name: key名 redis.hvals(‘price’) 从key为price的hash中获取所有映射键值 [b’5’, b’6’, b’2’, b’6’] hgetall(name) 从key为name的hash中获取所有映射键值对 name: key名 redis.hgetall(‘price’) 从key为price的hash中获取所有映射键值对 {b’cake’: b’5’, b’book’: b’6’, b’orange’: b’7’, b’pear’: b’6’} List(列表) Redis 还提供了列表存储，列表内的元素可以重复，而且可以从两端存储 方法 作用 参数说明 示例 示例说明 示例结果 rpush(name, *values) 在key为name的list尾添加值为value的元素，可以传多个 name: key名 values: 值 redis.rpush(‘list’, 1, 2, 3) 给list这个key的list尾添加1、2、3 3，list大小 lpush(name, *values) 在key为name的list头添加值为value的元素，可以传多个 name: key名 values: 值 redis.lpush(‘list’, 0) 给list这个key的list头添加0 4，list大小 llen(name) 返回key为name的list的长度 name: key名 redis.llen(‘list’) 返回key为list的列表的长度 4 lrange(name, start, end) 返回key为name的list中start至end之间的元素 name: key名 start: 起始索引 end: 终止索引 redis.lrange(‘list’, 1, 3) 返回起始为1终止为3的索引范围对应的list [b&#39;3&#39;, b&#39;2&#39;, b&#39;1&#39;] ltrim(name, start, end) 截取key为name的list，保留索引为start到end的内容 name:key名 start: 起始索引 end: 终止索引 ltrim(‘list’, 1, 3) 保留key为list的索引为1到3的元素 True lindex(name, index) 返回key为name的list中index位置的元素 name: key名 index: 索引 redis.lindex(‘list’, 1) 返回key为list的列表index为1的元素 b’2’ lset(name, index, value) 给key为name的list中index位置的元素赋值，越界则报错 name: key名 index: 索引位置 value: 值 redis.lset(‘list’, 1, 5) 将key为list的list索引1位置赋值为5 True lrem(name, count, value) 删除count个key的list中值为value的元素 name: key名 count: 删除个数 value: 值 redis.lrem(‘list’, 2, 3) 将key为list的列表删除2个3 1，即删除的个数 lpop(name) 返回并删除key为name的list中的首元素 name: key名 redis.lpop(‘list’) 返回并删除名为list的list第一个元素 b’5’ rpop(name) 返回并删除key为name的list中的尾元素 name: key名 redis.rpop(‘list’) 返回并删除名为list的list最后一个元素 b’2’ blpop(keys, timeout=0) 返回并删除名称为在keys中的list中的首元素，如果list为空，则会一直阻塞等待 keys: key列表 timeout: 超时等待时间，0为一直等待 redis.blpop(‘list’) 返回并删除名为list的list的第一个元素 [b’5’] brpop(keys, timeout=0) 返回并删除key为name的list中的尾元素，如果list为空，则会一直阻塞等待 keys: key列表 timeout: 超时等待时间，0为一直等待 redis.brpop(‘list’) 返回并删除名为list的list的最后一个元素 [b’2’] rpoplpush(src, dst) 返回并删除名称为src的list的尾元素，并将该元素添加到名称为dst的list的头部 src: 源list的key dst: 目标list的key redis.rpoplpush(‘list’, ‘list2’) 将key为list的list尾元素删除并返回并将其添加到key为list2的list头部 b’2’ Set(集合) Redis 还提供了集合存储，集合中的元素都是不重复的 方法 作用 参数说明 示例 示例说明 示例结果 sadd(name, *values) 向key为name的set中添加元素 name: key名 values: 值，可为多个 redis.sadd(‘tags’, ‘Book’, ‘Tea’, ‘Coffee’) 向key为tags的set中添加Book、Tea、Coffee三个内容 3，即插入的数据个数 srem(name, *values) 从key为name的set中删除元素 name: key名 values: 值，可为多个 redis.srem(‘tags’, ‘Book’) 从key为tags的set中删除Book 1，即删除的数据个数 spop(name) 随机返回并删除key为name的set中一个元素 name: key名 redis.spop(‘tags’) 从key为tags的set中随机删除并返回该元素 b’Tea’ smove(src, dst, value) 从src对应的set中移除元素并添加到dst对应的set中 src: 源set dst: 目标set value: 元素值 redis.smove(‘tags’, ‘tags2’, ‘Coffee’) 从key为tags的set中删除元素Coffee并添加到key为tags2的set True scard(name) 返回key为name的set的元素个数 name: key名 redis.scard(‘tags’) 获取key为tags的set中元素个数 3 sismember(name, value) 测试member是否是key为name的set的元素 name:key值 redis.sismember(‘tags’, ‘Book’) 判断Book是否为key为tags的set元素 True sinter(keys, *args) 返回所有给定key的set的交集 keys: key列表 redis.sinter([‘tags’, ‘tags2’]) 返回key为tags的set和key为tags2的set的交集 {b’Coffee’} sinterstore(dest, keys, *args) 求交集并将交集保存到dest的集合 dest:结果集合 keys:key列表 redis.sinterstore(‘inttag’, [‘tags’, ‘tags2’]) 求key为tags的set和key为tags2的set的交集并保存为inttag 1 sunion(keys, *args) 返回所有给定key的set的并集 keys: key列表 redis.sunion([‘tags’, ‘tags2’]) 返回key为tags的set和key为tags2的set的并集 {b’Coffee’, b’Book’, b’Pen’} sunionstore(dest, keys, *args) 求并集并将并集保存到dest的集合 dest:结果集合 keys:key列表 redis.sunionstore(‘inttag’, [‘tags’, ‘tags2’]) 求key为tags的set和key为tags2的set的并集并保存为inttag 3 sdiff(keys, *args) 返回所有给定key的set的差集 keys: key列表 redis.sdiff([‘tags’, ‘tags2’]) 返回key为tags的set和key为tags2的set的差集 {b’Book’, b’Pen’} sdiffstore(dest, keys, *args) 求差集并将差集保存到dest的集合 dest:结果集合 keys:key列表 redis.sdiffstore(‘inttag’, [‘tags’, ‘tags2’]) 求key为tags的set和key为tags2的set的差集并保存为inttag 3 smembers(name) 返回key为name的set的所有元素 name: key名 redis.smembers(‘tags’) 返回key为tags的set的所有元素 {b’Pen’, b’Book’, b’Coffee’} srandmember(name) 随机返回key为name的set的一个元素，但不删除元素 name: key值 redis.srandmember(‘tags’) 随机返回key为tags的set的一个元素 SortedSet(有序集合) 有序集合，它相比集合多了一个分数字段，利用它我们可以对集合中的数据进行排序 方法 作用 参数说明 示例 示例说明 示例结果 zadd(name, *args, **kwargs) 向key为name的zset中添加元素member，score用于排序。如果该元素存在，则更新其顺序 name: key名 args: 可变参数 redis.zadd(‘grade’, 100, ‘Bob’, 98, ‘Mike’) 向key为grade的zset中添加Bob，score为100，添加Mike，score为98 2，即添加的元素个数 zrem(name, *values) 删除key为name的zset中的元素 name: key名 values: 元素 redis.zrem(‘grade’, ‘Mike’) 从key为grade的zset中删除Mike 1，即删除的元素个数 zincrby(name, value, amount=1) 如果在key为name的zset中已经存在元素value，则该元素的score增加amount，否则向该集合中添加该元素，其score的值为amount name: key名 value: 元素 amount: 增长的score值 redis.zincrby(‘grade’, ‘Bob’, -2) key为grade的zset中Bob的score减2 98.0，即修改后的值 zrank(name, value) 返回key为name的zset中元素的排名（按score从小到大排序）即下标 name: key名 value: 元素值 redis.zrank(‘grade’, ‘Amy’) 得到key为grade的zset中Amy的排名 1 zrevrank(name, value) 返回key为name的zset中元素的倒数排名（按score从大到小排序）即下标 name: key名 value: 元素值 redis.zrevrank(‘grade’, ‘Amy’) 得到key为grade的zset中Amy的倒数排名 2 zrevrange(name, start, end, withscores=False) 返回key为name的zset（按score从大到小排序）中的index从start到end的所有元素 name: key值 start: 开始索引 end: 结束索引 withscores: 是否带score redis.zrevrange(‘grade’, 0, 3) 返回key为grade的zset前四名元素 [b’Bob’, b’Mike’, b’Amy’, b’James’] zrangebyscore(name, min, max, start=None, num=None, withscores=False) 返回key为name的zset中score在给定区间的元素 name:key名 min: 最低score max:最高score start: 起始索引 num: 个数 withscores: 是否带score redis.zrangeby score(‘grade’, 80, 95) 返回key为grade的zset中score在80和95之间的元素 [b’Amy’, b’James’] zcount(name, min, max) 返回key为name的zset中score在给定区间的数量 name:key名 min: 最低score max: 最高score redis.zcount(‘grade’, 80, 95) 返回key为grade的zset中score在80到95的元素个数 2 zcard(name) 返回key为name的zset的元素个数 name: key名 redis.zcard(‘grade’) 获取key为grade的zset中元素个数 3 zremrangebyrank(name, min, max) 删除key为name的zset中排名在给定区间的元素 name:key名 min: 最低位次 max: 最高位次 redis.zremran gebyrank(‘grade’, 0, 0) 删除key为grade的zset中排名第一的元素 1，即删除的元素个数 zremrangebyscore(name, min, max) 删除key为name的zset中score在给定区间的元素 name:key名 min: 最低score max:最高score redis.zremran gebyscore (‘grade’, 80, 90) 删除score在80到90之间的元素 1，即删除的元素个数 注意：上面代码中由于展示显示不完全，本人做了相应的处理，原本是一个方法名的可能方法名中间会出现空格 以上便是用Python操作Redis的总结了，在后面的项目中会常用到Redis操作，所以我们还是需要掌握一些常用操作。","categories":[],"tags":[],"keywords":[]},{"title":"Python3.x 连接MySQL数据库","slug":"pymysql","date":"2018-05-17T17:19:56.000Z","updated":"2018-05-17T10:01:12.161Z","comments":true,"path":"2018/05/18/pymysql/","link":"","permalink":"http://gavinliu4011.github.io/2018/05/18/pymysql/","excerpt":"","text":"Python3.x 连接MySQL数据库由于 MySQLdb 模块还不支持 Python3.x，所以 Python3.x 如果想连接MySQL需要安装 pymysql 模块。 pymysql 模块可以通过 pip 安装pip install PyMySQL 用pymysql连接数据库 12345678conn = pymysql.connect(host='localhost', port=3306, user='root', password='root', db='hrs', charset='utf8', autocommit=False # 默认不自动提交 ) 常用参数说明: ​host:主机IP ​port:端口号 ​user:mysql登录用户名 ​password:mysql登录密码 ​db:数据库名称 ​charset:连接数据库采用的字符编码 autocommit:默认值是False,DML(数据操纵语言)不会自动提交,如果为True则会自动提交 cursorclass:pymysql.cursors.DictCursor - 设置游标的类型,查询返回的结果是以字典的方式 测试是否连接成功 12print(conn)$ &lt;pymysql.connections.Connection object at 0x05656EB0&gt; 如果运行上面的语句不报错,并且看到了输出到控制台的值,那么我们则用pymysql连接上了MySQL数据库. 方法介绍 12345678910111213connection对象常用的方法cursor() 使用该连接创建并返回游标commit() 提交当前事务rollback() 回滚当前事务close() 关闭连接cursor对象常用的方法和属性execute(sql) 执行一个数据库的查询命令fetchone() 取得结果集的下一行fetchmany(size) 获取结果集的下几行fetchall() 获取结果集中的所有行rowcount 返回数据条数或影响行数close() 关闭游标对象 在介绍上面方法使用前再看看连接数据库的代码块,其中有一个很重要的参数db (数据库名称),所以我们应当在连接数据库之前，先创建一个数据库，方便测试 pymysql 的功能 使用Python实现增删改查和事务处理 首先我们在上面说的hrs数据库中创建一张部门表 1234567891011121314-- 创建部门表create table tbdept(dno int, -- 部门编号dname varchar(10) not null, -- 部门名称dloc varchar(20) not null, -- 部门所在地primary key (dno));-- 添加部门记录insert into tbdept values (10, '会计部', '北京'),(20, '研发部', '成都'),(30, '销售部', '重庆'),(40, '运维部', '深圳'); 12345678910111213def get_conn(): config = &#123; 'host': 'localhost', 'port': 3306, 'user': 'root', 'password': 'root', 'db': 'hrs', 'charset': 'utf8', 'autocommit': False, # 默认不自动提交 'cursorclass': pymysql.cursors.DictCursor # 设置游标的类型,查询返回的结果是以字典的方式 &#125; conn = pymysql.connect(**config) return conn 下面我们先来看看添加的操作: 12345678910111213141516171819202122232425262728def insert(): \"\"\" 插入 \"\"\" # Connection(连接) / Cursor(游标) conn = get_conn() try: # 创建Cursor对象,cursor支持上下文语法,可以放在with中 with conn.cursor() as cursor: # 向数据库发出sql语句 dno = input('部门编号:') dname = input('部门名称:') dloc = input('部门地址:') # 如果使用字符串格式化的方式来组装SQL语句 # 最大的风险是用被SQL注射攻击 # sql = \"insert into tbdept values (%d, '%s', '%s')\" % (dno, dname, dloc) # result = cursor.execute(sql) # result = cursor.execute('insert into tbdept values (%s, %s, %s)', (dno, dname, dloc)) # 这个方式传参是以字典的方式,但是要注意的是在占位的时候用%(name)s result = cursor.execute( 'insert into tbdept values (%(dno)s, %(dname)s, %(dloc)s)', &#123;'dno': dno, 'dname': dname, 'dloc': dloc&#125; ) # print('成功插入', cursor.rowcount, '条数据') # 这里cursor.rowcount是获取到受影响的行 print('成功插入', result, '条数据') conn.commit() finally: conn.close() 修改操作 12345678910111213141516171819def update(): \"\"\" 修改 \"\"\" conn = get_conn() try: with conn.cursor() as cursor: dno = input('部门编号:') dname = input('部门名称:') # 这个方式传参是以字典的方式,但是要注意的是在占位的时候用%(name)s result = cursor.execute( 'update tbdept set dname=%(dname)s where dno=%(dno)s', &#123;'dno': dno, 'dname': dname&#125; ) # print('成功插入', cursor.rowcount, '条数据') # 这里cursor.rowcount是获取到受影响的行 print('成功修改', result, '条数据') conn.commit() finally: conn.close() 删除操作 1234567891011121314151617181920def delete(dno): \"\"\" 根据编号删除 :param dno: 编号 \"\"\" conn = get_conn() try: with conn.cursor() as cursor: # 向数据库发出sql语句 # execute方法中占位后传参除了元组和字典外,还可以是列表 result = cursor.execute('delete from tbdept where dno=%s', [dno]) # 如果事务中的所有操作全部成功了最后手动提交 conn.commit() print('删除成功' if result == 1 else '删除失败') except Exception as e: print(e) # 如果事务操作有任何一个操作发生异常,那么就会回滚事务 conn.rollback() finally: conn.close() 查询操作 123456789101112131415161718192021def select(): \"\"\" 查询 \"\"\" conn = get_conn() print(conn) try: # 创建Cursor对象 with conn.cursor() as cursor: # 向数据库发出sql语句 cursor.execute('select dno, dname, dloc from tbdept') result = cursor.fetchone() # 程序中最好不要使用fetchall(),如果库中数据量很大,那么脑补一下会有什么样的结果呢 while result: print(result) # 取出部门名称 # 在这里我上面连接数据时,使用了cursorclass参数,查询时返回的结果是以字典的方式 print(result['dname']) result = cursor.fetchone() finally: conn.close() 到现在我们已经简单的介绍了用pymysql完成了对数据库的CURD操作 源码地址为: https://coding.net/u/gavinliu4011/p/study-python/git/tree/master/mypymysql 或者 https://gitee.com/gavinliu4011/study-python/tree/master/mypymysql","categories":[{"name":"Python","slug":"Python","permalink":"http://gavinliu4011.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://gavinliu4011.github.io/tags/Python/"},{"name":"pymysql","slug":"pymysql","permalink":"http://gavinliu4011.github.io/tags/pymysql/"},{"name":"MySQL","slug":"MySQL","permalink":"http://gavinliu4011.github.io/tags/MySQL/"}],"keywords":[{"name":"Python","slug":"Python","permalink":"http://gavinliu4011.github.io/categories/Python/"}]},{"title":"Shell常用命令","slug":"shell","date":"2018-05-15T08:43:10.000Z","updated":"2018-05-17T11:34:02.127Z","comments":true,"path":"2018/05/15/shell/","link":"","permalink":"http://gavinliu4011.github.io/2018/05/15/shell/","excerpt":"","text":"shell的基本常用命令 指令 常用操作 指令 操作 pwd 当前路径 cd 更改目录 不加参数 进入主目录 ls 当前目录内容 ls -a 查看隐藏文件 ls -l 文件详情 ls -ld 目录本身信息 mkdir 新建文件夹 rm 删除文件 rm -rf dir/ 删除文件夹 cp file1 file2 复制文件 cp -r dir1 dir2 复制文件夹 mv file .. 移动文件到上一级 mv file dir/ 移动到dir目录 mv file1 file2 替换文件 mv dir1 dir2 替换文件夹 touch a.text 创建文件 &gt;a.text 创建文件 touch .file.text 创建隐藏文件 [cat / less / more] file 查看文件 file a.txt 查看文件类型 man xx 打开xx指令的手册 /x 查找某参数 n 查找下一处 table 可以补全路径名 echo 打印 date 显示时间 cal 显示日历 解压缩 指令 操作 unzip 解压 zip -r 压缩 file.zip dir 压缩后的名称 压缩对象 tar zxvf 解压.tar.gz tar zcvf 压缩文件 tar jxvf 解压tar.bz2 tar jcvf 解压tar.bz2 重定向 指令 操作 丨 管道线 &lt; 标准输入重定向 &gt; 把输出流保存到文件中 重定向前把文件清空 &gt;&gt; 把输出流保存到文件中 不清空文件 cat file1 &gt;file 把file1中的内容写入file中 cat file1 &gt;&gt;file 把file1中的内容写入file内容后 ls shit 2 &gt;out.txt 标准错误输出 权限 用户在自己的主目录有写权限，在其它目录没有。 指令 操作 su - 更改用户为root sudo 超级用户 chmod +x +r +w 添加执行/读/写权限 chmod 777 添加全部权限 进程 指令 操作 ps -[ef丨aux] 丨grep 应用名称 查看进程 kill [-9] pid 结束某个程序 搜索 指令 操作 find file -type f 搜索文件 find dir/ -type d 搜索目录 概念 概念 解释 绝对路径 以 / 开头的路径 相对路径 相对于当前工作路径 ./当前工作目录 ../上一级目录 通配符 例如 *","categories":[{"name":"Linux","slug":"Linux","permalink":"http://gavinliu4011.github.io/categories/Linux/"}],"tags":[{"name":"Shell","slug":"Shell","permalink":"http://gavinliu4011.github.io/tags/Shell/"}],"keywords":[{"name":"Linux","slug":"Linux","permalink":"http://gavinliu4011.github.io/categories/Linux/"}]},{"title":"Linux环境下Git安装与使用","slug":"Linux环境下Git安装与使用","date":"2018-05-14T20:38:20.000Z","updated":"2018-05-14T13:08:02.713Z","comments":true,"path":"2018/05/15/Linux环境下Git安装与使用/","link":"","permalink":"http://gavinliu4011.github.io/2018/05/15/Linux环境下Git安装与使用/","excerpt":"","text":"Linux环境下Git安装和使用 Linux环境下Git安装与使用 安装 官网下载并解压 123[root@VM_0_11_centos ~]# wget https://mirrors.edge.kernel.org/pub/software/scm/git/git-2.17.0.tar.gz[root@VM_0_11_centos ~]# tar -xvf git-2.17.0.tar.gz[root@VM_0_11_centos ~]# cd git-2.17.0 移除旧版本 1[root@VM_0_11_centos ~]# yum remove git 安装依赖库 12[root@VM_0_11_centos ~]# yum install libcurl-devel[root@VM_0_11_centos ~]# yum install autoconf automake libtool 执行 1234567[root@VM_0_11_centos ~]# make configureGIT_VERSION = 2.17.0 GEN configure[root@VM_0_11_centos ~]# ./configure --prefix=/usr/local/git --with-iconv =/usr/local/lib（建议优先尝试后者）或者./configure --prefix=/usr/local/git --with-iconv --with-curl --with-expat=/usr/local/lib（如果没有安装libiconv请自行安装）[root@VM_0_11_centos git-2.17.0]# make &amp;&amp; make install 配置环境变量 1234[root@VM_0_11_centos git-2.17.0]# vim ~/.bash_profile在文件末尾追加上下面命令:PATH=$PATH:/usr/local/git/binexport PATH 重新加载环境变量 1[root@VM_0_11_centos git-2.17.0]# source ~/.bash_profile 查看git版本 1[root@VM_0_11_centos git-2.17.0]# git --version 使用 在本地建立本地仓库 123[root@VM_0_11_centos ~]# mkdir test[root@VM_0_11_centos test]# cd test[root@VM_0_11_centos test]# git init 把文件纳入版本控制(加入暂存区) 12[root@VM_0_11_centos test]# git add &lt;filename&gt; # 将修改后的文件加入暂存区[root@VM_0_11_centos test]# git add . # add后跟.是将当前文件夹下面的所有文件及文件夹都加入暂存区 提交到仓库(-m 后是描述) 1[root@VM_0_11_centos test]# git commit -m '本次提交文件的相关描述信息' 如果提交报错,看否是缺少user.name、user.email,可执行下面的命令解决: 12[root@VM_0_11_centos test]# git config --global user.name 'your-name'[root@VM_0_11_centos test]# git config --global user.email 'your-email' 查看放入暂存区的文件 1[root@VM_0_11_centos test]# git status 查看版本 1[root@VM_0_11_centos test]# git log 回滚到某个版本 1[root@VM_0_11_centos test]# git reset --hard 版本号 显示版本包括历史版本 12[root@VM_0_11_centos test]# git reflog[root@VM_0_11_centos test]# git reflog --pretty=oneline # 单行显示 把暂存区的内容全撤回来(可以在本地做修改,然后再次add进暂存区做提交) 1[root@VM_0_11_centos test]# git checkout -- [可跟上文件名] 添加远端仓库 1[root@VM_0_11_centos test]# git remote add origin https://git.coding.net/gavinliu/test.git 将本地仓库和远端仓库同步 1[root@VM_0_11_centos test]# git push -u origin master 创建分支 1[root@VM_0_11_centos test]# git branch [分支名] 查看所有分支 1[root@VM_0_11_centos test]# git branch 切换分支 1[root@VM_0_11_centos test]# git checkout [分支名] 删除文件 1[root@VM_0_11_centos test]# git rm [filename] 合并分支 1[root@VM_0_11_centos test]# git merge [分支名] 克隆项目到本地 1[root@VM_0_11_centos ~]# git clone https://git.coding.net/jackfrued/HelloGit.git 推送到服务器,origin是原始名字,master是分支 1[root@VM_0_11_centos test]# git push origin master 拉取服务器代码 1[root@VM_0_11_centos test]# git pull ​","categories":[{"name":"Git","slug":"Git","permalink":"http://gavinliu4011.github.io/categories/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://gavinliu4011.github.io/tags/Git/"}],"keywords":[{"name":"Git","slug":"Git","permalink":"http://gavinliu4011.github.io/categories/Git/"}]},{"title":"Python3基础之函数","slug":"Python3基础之函数","date":"2018-05-14T20:35:29.000Z","updated":"2018-05-14T12:35:57.584Z","comments":true,"path":"2018/05/15/Python3基础之函数/","link":"","permalink":"http://gavinliu4011.github.io/2018/05/15/Python3基础之函数/","excerpt":"","text":"Python3基础之函数 三元运算符补充 123456# 三元运算符(或者三目运算)# 格式# 结果 = 值1 if 条件 else 值2result = True if 1&gt;2 else False# 如果条件成立则返回'值1',否则返回'值2' 函数的定义 12345678910111213141516171819在开始之前我们先上一段代码:while True： if cpu利用率 &gt; 90%: # 发送邮件提醒 连接邮箱服务器 发送邮件 关闭连接 if 硬盘使用空间 &gt; 90%: # 发送邮件提醒 连接邮箱服务器 发送邮件 关闭连接 if 内存占用 &gt; 80%: # 发送邮件提醒 连接邮箱服务器 发送邮件 关闭连接 不知道大家是否注意到以上代码有很多重复的代码,要写出高质量的代码首先要解决的就是重复代码的问题。我们可以将上面的’发送邮件提醒’功能封装成一个函数,当满足条件时调用函数即可。所以某些具有特殊功能的代码块, 将这些特定的代码块给他分封装起来,这个封装起来的代码块就是函数。 1234567891011121314151617181920212223242526# 定义函数函数的定义主要有如下要点： 1.def：表示函数的关键字 2.函数名：函数的名称，日后根据函数名调用函数（函数的命名规则和变量的命名规则一致） 3.函数体：函数中进行一系列的逻辑计算，如：发送邮件 4.参数：为函数体提供数据 5.返回值：当函数执行完毕后，可以给调用者返回数据。下面我们重构一下上面发送邮件的代码：def send(): 发送邮件的代码... if success: #发送成功 return True else: return False while True: # 每次执行发送邮件函数，都会将返回值自动赋值给result # 之后，可以根据result来写日志，或重发等操作 # 在这儿根据函数名'send'来调用函数 result = send() if result == False: 记录日志，短信发送失败... 匿名函数 123456789对于简单的函数，也存在一种简便的表示方式，即：lambda表达式# 普通方式def sum(arg): return arg + 5print(sum(5))# 匿名函数lambda_sum = lambda x, y: x + yprint(lambda_sum(5, 5)) 函数的运用 1234567891011121314151617181920212223242526272829# 递归调用,遍历文件夹目录import osdef get_all_dir(path, str=\"|--\"): \"\"\" 实现目录的遍历 :param path: 遍历目录的路径 :param str: 样式 :return: \"\"\" # 返回一个指定文件夹(目录)包含文件和文件夹(目录),并且返回一个列表,但是不包含.和..,他一般按照英文首字母排序 fill_all = os.listdir(path) # print(fillAll) for filename in fill_all: # 一定不能少了全路径的拼接 file_path = os.path.join(path, filename) # print(filePath) # 判断filePath是否是目录 if os.path.isdir(file_path): print(str + '文件夹' + filename) # filePath是目录 get_all_dir(file_path, \"\\t\" + str) else: # filePath不是目录,即是文件 print(str + '文件:' + filename)get_all_dir('../gavinliu_study')","categories":[{"name":"Python基础","slug":"Python基础","permalink":"http://gavinliu4011.github.io/categories/Python基础/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://gavinliu4011.github.io/tags/Python/"},{"name":"函数","slug":"函数","permalink":"http://gavinliu4011.github.io/tags/函数/"}],"keywords":[{"name":"Python基础","slug":"Python基础","permalink":"http://gavinliu4011.github.io/categories/Python基础/"}]},{"title":"Python3基础之分支结构和循环结构","slug":"Python3基础之分支结构和循环结构","date":"2018-05-14T20:12:46.000Z","updated":"2018-05-14T12:26:41.296Z","comments":true,"path":"2018/05/15/Python3基础之分支结构和循环结构/","link":"","permalink":"http://gavinliu4011.github.io/2018/05/15/Python3基础之分支结构和循环结构/","excerpt":"","text":"在Python中，要构造分支结构可以使用if、elif和else关键字。所谓关键字就是有特殊含义的单词，像if和else就是专门用于构造分支结构的关键字，很显然你不能够使用它作为变量名（事实上，用作其他的标识符也是不可以） 在程序中我们需要重复的执行某条或某些指令，例如比如在我们的程序中要实现每隔1秒中在屏幕上打印一个”hello, world”这样的字符串并持续一个小时，我们肯定不能够将print(&#39;hello, world&#39;)这句代码写上3600遍。当然你可能已经注意到了，刚才的描述中其实是重复的动作 Python3基础之分支结构和循环结构 分支结构 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273第一种: if结构格式: if 表达式: 语句块执行流程:程序遇到if结构时,判断表达式的真假,如果为真,则执行语句块,否则结束if结构 表达式为假的情况: 0 '' None False [] () &#123;&#125;num1 = 78num2 = 45tmp = 0if num1 &gt; num2: tmp = num1 num1 = num2 num2 = tmp print(num1, num2)第二种: if-else结构格式: if 表达式: 语句块1 else: 语句块2执行流程:程序执行到if结构,判断表达式的真假,如果为真,则执行语句块1,如果为假,则执行else中的语句块的内容# 判断一个年份是否是闰年year = int(input('请输入你要输入的年份:'))if ((year % 4 == 0) and (year % 100 != 0)) or (year % 400 == 0): print('是润年')else: print('不是闰年')第三种: if-elif-else格式: if 表达式1: 语句块1 elif 表达式2: 语句块2 elif 表达式3: 语句块3 else: 语句块n执行流程:程序执行到if语句,判断表达式1的真假,如果为真,则执行语句1,否则判断表达式2的真假,如果为真,则执行表达式2,一次类推,直到最后一个表达式为假,就执行else里边的语句块nimport random# 产生一个1-6的随机数num = random.randint(1, 6)# print(num)if num == 1: print('这个随机数乘以1后是%d' % (num * 1))elif num == 2: print('这个随机数乘以2后是%d' % (num * 2))elif num == 3: print('这个随机数乘以3后是%d' % (num * 3))elif num == 4: print('这个随机数乘以4后是%d' % (num * 4))elif num == 5: print('这个随机数乘以5后是%d' % (num * 5))else: print('这个随机数乘以本身后是%d' % (num * num)) 第四种: 嵌套if 表达式1: if 表达式2: 语句块1 else: 语句块2else: 语句块3name = 'xiaoming'password = '123456'user = input('请输入用户名')pwd = input('请输入密码')if user == name: if pwd == password: print('恭喜你,登录成功') else: print('用户名或者密码错误2')else: print('用户名或者密码错误1') 循环结构 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#for-in循环#如果明确的知道循环执行的次数或者是要对一个容器进行迭代，使用for-in循环\"\"\"用for循环实现1~100求和\"\"\"sum = 0for x in range(101): sum += xprint(sum)\"\"\"输入两个正整数计算最大公约数和最小公倍数\"\"\"num1 = int(input(\"请输入第一个整数:\"))num2 = int(input(\"请输入第二个整数:\"))# actual = Noneactual = min(num1, num2) # 取最小的整数# commonDivisorVal = Nonefor i in range(1, actual + 1): if (num1 % i == 0) and (num2 % i == 0): commonDivisorVal = iprint(\"%d和%d的最大公约数是%d\" % (num1, num2, commonDivisorVal))#while循环#如果要构造不知道具体循环次数的循环结构，推荐使用while循环，while循环通过一个能够产生或转换出bool值的表达式来控制循环，表达式的值为True循环继续，表达式的值为False循环结束。\"\"\"猜数字游戏计算机出一个1~100之间的随机数由人来猜计算机根据人猜的数字分别给出提示大一点/小一点/猜对了\"\"\"import randomanswer = random.randint(1, 100)counter = 0while True: counter += 1 number = int(input('请输入: ')) if number &lt; answer: print('大一点') elif number &gt; answer: print('小一点') else: print('恭喜你猜对了!') breakprint('你总共猜了%d次' % counter) 注意:上面的代码中使用了break关键字来提前终止循环，需要注意的是break只能终止它所在的那个循环，这一点在使用嵌套的循环结构需要注意。除了break之外，还有另一个是continue，它可以用来跳过本次循环直接进入下一轮循环。","categories":[{"name":"Python基础","slug":"Python基础","permalink":"http://gavinliu4011.github.io/categories/Python基础/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://gavinliu4011.github.io/tags/Python/"},{"name":"分支结构","slug":"分支结构","permalink":"http://gavinliu4011.github.io/tags/分支结构/"},{"name":"循环结构","slug":"循环结构","permalink":"http://gavinliu4011.github.io/tags/循环结构/"}],"keywords":[{"name":"Python基础","slug":"Python基础","permalink":"http://gavinliu4011.github.io/categories/Python基础/"}]},{"title":"Python3基础之字符串、列表、元组、字典、集合等相关操作","slug":"Python3基础之字符串、列表、元组、字典、集合等相关操作","date":"2018-05-14T19:54:42.000Z","updated":"2018-05-14T12:12:13.686Z","comments":true,"path":"2018/05/15/Python3基础之字符串、列表、元组、字典、集合等相关操作/","link":"","permalink":"http://gavinliu4011.github.io/2018/05/15/Python3基础之字符串、列表、元组、字典、集合等相关操作/","excerpt":"","text":"下面将一一介绍Python中的字符串、列表、元组、集合的相关操作 字符串、列表、元组、字典、集合等相关操作 字符串操作 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104字符串一般情况使用单引号或者双引号引起来规则: 单不能套单,单可以套双 双不能套双,双可以套单## 多行字符串# 方式二str3 = '3月25号我来到了美丽的成都,刚下飞机,'\\ '就碰到一个老外帅锅,结果他还跟我打招呼.但是我不会英语,好尴尬'# 方式一str4 = '''洁白的婚纱,手捧着鲜花 ,美丽的想通话.想起那年初夏,我为你牵挂.'''# 方式三str5 = \"\"\"洁白的婚纱,手捧着鲜花 ,美丽的想通话.想起那年初夏,我为你牵挂.\"\"\"print(str5)#--------------------------------------------------------------------------------##字符串的长度'''len(): 获取字符串的长度'''str1 = 'lhy'str1 = '刘海艳'str1 = '幸福像花儿一样'print(len(str1))总结: 无论是字符还是汉字,只要有一个,则长度就是几个#-------------------------------------------------------------------------------##提取某个字符'''提取字符串中的某一个字符方式:从左往右开始, 下标从0开始提取str[0] str[1] str[2] ..... str[n]从优往左开始, 下标从-1开始str[-1] str[-2] ..... str[-n]'''str1 = 'It is a dog'print(str1[0])print(str1[-2])# pytjon中的字符串一旦定义好之后,是不可以修改的str1[0] = 'i'print('str1 =', str1)#------------------------------------------------------------------------------##转义字符'''转义字符: 将原来的意义给他去掉 \\(这是反斜线) '''str1 = '我最喜欢的一首歌是\\'咱们结婚吧\\''str1 = 'you\\'re a good man'print(str1)'''系统里边有一些特殊的字符: \\t(制表符) \\n(换行符)'''print('你好\\\\t宝强哥,你的媳妇是马蓉吗?')print('你好\\\\n宋喆,你的情人是\\t马蓉\\n吗?')# 如果想将原来具有特殊含义的字符失去本身的意义,我们可以直接在整个字符串前边添加一个rprint(r'你好\\t宝强哥,你的媳妇是马蓉吗?')print(r'你好\\n宋喆,你的情人是马蓉吗?')#-------------------------------------------------------------------------------##字符串截取'''字符串截取:str1[开始下标:结束下标]: 从开始下标截取,到结束下标=结尾,.包含开始下标,但不包含结束下标str1[0:5] 提取是的结果你是zhousstr1[:3] 默认从下标0开始到结束的开区间str1[3:] 从指定的下标开始到结尾str1[-n:]: 从最后边提取n个str1[:]: 提取全部字符str1[::2] 根据下标每个n个提取一次str1[::-1] 将字符逆序排列'''#------------------------------------------------------------------------------##字符串的格式化%s: 给字符串站位%d: 给int类型站位%f: 给浮点类型站位, 默认保留6为小数 %.2f: 保留两位小数 %10.2f 共10位,保留两位小数,其他为使用空格补齐 %010.2f 共10位,保留两位小数,其他为使用0补齐%c: 打印一个字符%o: 将十进制转换成八进制%x: 将十进制转换成十六进制name = '宝强'age = 36like = 'green'print('他是&#123;&#125;,今年&#123;&#125;,他喜欢&#123;&#125;' .format(name, age, like))print('他是&#123;lala&#125;,今年&#123;wawa&#125;, 他喜欢&#123;heihei&#125;' .format(wawa=age, heihei=like, lala=name))#--------------------------------------------------------------------------------##字符串比较大小[规则:]从第一个字符开始比较,将字符转换成ascii值进行比较如果小于则返回True,否则返回False 列表操作 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113'''列表: 格式: 列表名 = [元素1, 元素2,,...]'''# append()往列表后边追加一个元素list1 = [1, 2, 3, 4]list1.append(100)# print(list1)list1.append([200, 400, 600])# print(list1)# 在末尾一次性追加另外一个列表中的多个值list2 = [3, 4, 5]list2.extend([200, 300, 400])# print(list2)'''insert():在指定下标出添加一个元素,原来位置处的元素往后移动@参数一: 列表的下标@参数二: 列表中下标所对应的值'''list3 = [5, 6, 7]list3.insert(1, 250)# print(list3)'''pop():将列表中指定下标的元素删除, 如果默认不传递参数,则删除的是最后一个元素@参数一: [可有可无] 列表对应的下标'''list4 = [3, 4, 5, 6, 7, 8]list4.pop()list4.pop()# print(list4)list4.pop(1)# print(list4)'''remove():移除列表中指定的元素@参数一: 列表中的元素'''list5 = [3, 4, 5, 6, 7]list5.remove(3)# print(list5)'''clear():清除列表中所有的元素'''list6 = [1, 3, 4]list6.clear()# print(list6)'''index():获取列表元素锁对应的下标@参数一: 列表中的某一个元素返回值: 列表中元素所对应的下标'''list7 = [1, 2, 3, 4, 5, 6]index1 = list7.index(3)# print(index1)# 获取列表的长度list8 = [1, 2, 3, 4, 5]# print(len(list8))list9 = [1, 3, 4, 6, 7]# print(max(list9))list10 = [1, 3, 4, 6, 7]# print(min(list9))'''count(): 计算列表中元素出现的次数'''list11 = [1, 3, 4, 3, 3, 3, 3, 6, 7]# print(list11.count(3))'''reverse():将列表进行倒序排列'''list12 = [1, 2, 3, 4, 5, 10, 7, 8, 9]list12.reverse()# print(list12)'''sort():将列表中的元素进行升序排列'''list13 = [1, 100, 78, 23, 65, 43]list13.sort()# print(list13)'''引用传递: 在列表中,如果修改一个列表的元素,那么对应的另外一个列表的元素也改变'''list14 = [2, 3, 4]list15 = list14list15[1] = 200# print(list14)# print(list15)# id():查看内存的地址# print(id(list14))# print(id(list15))'''值传递在列表中修改一个元素的值时,对应的另外一个列表中的值是不发生改变的'''list16 = [1, 2, 3, 4]list17 = list16.copy()list17[1] = 250print(list16)print(list17)print(id(list16))print(id(list17)) 元组操作 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104'''元组:也是一种有序集合特点:1.跟列表非常相似: list1 = [] tuple1 = ()2.一旦定义好之后不能修改3.使用小括号括起一个集合'''# 创建一个空元祖tuple1 = ()# print(tuple1)# print(type(tuple1))tuple2 = (23, 3.14, 'aaa', None, True)# print(tuple2)tuple3 = (4, )#tupletuple3 = (4)#int# print(tuple3)# print(type(tuple3))# 访问元祖的元素tuple4 = (2, 3, 4, 5, 6)# print(tuple4[0])# print(tuple4[1])# 元祖在访问的时候一定不能溢出(越界),直接报错# print(tuple4[5])# 获取元祖中最后一个元素# print(tuple4[-1])# print(tuple4[-2])# 一定不能越界# print(tuple4[-6])tuple5 = (1, 2, 3, 4, [12, 34, 45])# print(tuple5)# tuple5[0] = 150#直接报错, 元祖定义好之后是不能修改的# print(tuple5)# print(tuple5[-1][-2])# print(tuple5[4][1])# 删除元祖的用法跟删除变量的用法一致tuple6 = (2, 3, 5, 6)del tuple6# print(tuple6)# 元祖进行操作tuple7 = (3, 4, 5)tuple8 = (6, 7, 8)# 将两个元祖合并成一个新的元祖tuple9 = tuple7 + tuple8# print(tuple9)# print(tuple7, tuple8)# 将元祖重复n次,最后返回一个新的元祖tuple10 = (3, 4, 5)# print(tuple10 * 10)# 判断一个元素是否在一个元祖中,如果在返回True,否则返回Falsetuple11 = (3, 5, 7)# print(4 in tuple11)# 元祖的截取# 格式: 元祖名[开始下标:结束下标]tuple12 = (1, 2, 3, 4, 5, 6, 7, 8, 9,10)# print(tuple12[1:5])# print(tuple12[3:])# print(tuple12[:6])# 将元祖进行逆序排列# print(tuple12[::-1])# 二维元祖:tuple13 = ((2, 3, 4), (5, 6, 7))# print(tuple13[1][1])# 元祖的方法# 求一个元祖的长度tuple14 = (2, 3, 4, 5)# print(len(tuple14))# print(max(tuple14))# print(min(tuple14))# 对列表进行遍历# for i in [1, 2, 3, 4, 5]:# print(i)# 对元祖进行遍历# for x in (3, 4, 5, 6, 7):# print(x)# 将列表转换成元祖list11 = [3, 5, 6, 8]tuple15 = tuple(list11)# print(tuple15)# 将元祖转换成列表tuple16 = (4, 6, 8, 9)list12 = list(tuple16)# print(list12)list13 = range(0, 10)print(type(list13))# range(): 从开始值开始,但不包含结束值[0, 10)# for i in range(0, 10):# print(i) 字典操作 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162'''dict(字典): 在字典里边一般存放的是键值对的形式.键1 = 值1 key = value键1 : 值1写法: &#123;键1:值1, 键2:值2, 键3:值3&#125;例子:dict1 = &#123;'name': '刘海艳', 'age': 17, 'sex': 'girl'&#125;注意事项:1.在字典中键(key)的值必须是唯一2.在字典中可以存放多个键值对3.在字典中键(key)必须是不可变类型 字符串 整数都可以作为键(key)4.list和tuple都是有序集合, 而dictsahib无序集合'''# 必须保证字典中的key是唯一的dict1 = &#123;'yelei': 100, 'xiaoming' : 99, 'jianfei': 59, 'zhouying': 110&#125;# print(dict1)# 元素的访问# 获取的方式: 字典名[key]# print(dict1['xiaoming'])# print(dict1.get('yelei'))# print('yelei' in dict1)ret = dict1.get('lhy')# if ret == None:# print('没有')# else:# print('有')dict2 = &#123;'user': '大黄', 'sex': '男', 'age': 30, 'height': 150 &#125;# 添加元素dict2['lover'] = '小白'# 一个key只能对应一个valuedict2['lover'] = '小绿'# 修改dict2['lover'] = '小花'# 删除dict2.pop('sex')# 直接报错,因为他是无需集合# dict2.pop()# print(dict2)# 遍历# for x in dict2:# print(x, dict2[x])# 获取字典所有的value和key# print(dict2.values())# print(dict2.keys())# for i in dict2.values():# print(i)## for i in dict2.keys():# print(i)# for k,v in dict2.items():# print(k, v)#for k,v in enumerate(dict2):# print(k, v) 集合操作 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162'''set(集合):类似于dict, 也是无序的,以key-value新的形势存在,但是没有value作用: 是对list,tuple,dict进行去重的, 求交集.并集1.set是无序2.set集合是不可改变的'''# set1 = set([1, 2, 3, 5, 3, 2])# print(set1)# print(type(set1))# set2 = set((1, 2, 3, 5, 3, 2, 4, 5))# print(set2)# print(type(set2))# set3 = set(&#123;3, 4, 5,5, 6, 3, 7&#125;)# print(set3)# print(type(set3))# 添加set4 = set([3, 3, 4, 5, 7, 2, 1, 2])set4.add(8)# set4.add(3)#可以添加重复的值,但是没效果# 总结:list和dict是可改变的, 而tuple是不可改变# set4.add([10, 9])#直接报错,不能添加list# set4.add((10, 9))# set4.add(&#123;'a':1&#125;)#直接报错,不能添加字典## print(set4)# 修改set5 = set([1, 2, 3, 4, 5])# 将list dict tuple 等等整个插入进去# set5.update([6, 7, 8])# set5.update(&#123;9, 10&#125;)# set5.update((11, 56))# print(set5)# 删除# set6= set([3, 4, 5, 6, 7])# set6.remove(4)# print(set6)# 遍历set7 = set([1, 2, 3, 4, 6])set7 = set(['aaa', 'bbb', 'ccc'])set7 = set((1, 2, 3, 2, 4, 2, 3))# 在set集合中,没有value,即使有value也遍历不出来set7 = set(&#123;'name':'小花', 'age': 18&#125;)# for i in set7:# print(i, end = ',')# &amp; | - ^set8 = set([1, 2, 3, 4])set9 = set([3, 2, 4, 5])set10 = set8 &amp; set9set11 = set8 | set9set12 = set8 - set9set13 = set8 ^ set9print(set10)print(set11)print(set12)print(set13)","categories":[{"name":"Python基础","slug":"Python基础","permalink":"http://gavinliu4011.github.io/categories/Python基础/"}],"tags":[{"name":"字符串","slug":"字符串","permalink":"http://gavinliu4011.github.io/tags/字符串/"},{"name":"列表","slug":"列表","permalink":"http://gavinliu4011.github.io/tags/列表/"},{"name":"元组","slug":"元组","permalink":"http://gavinliu4011.github.io/tags/元组/"},{"name":"字典","slug":"字典","permalink":"http://gavinliu4011.github.io/tags/字典/"},{"name":"集合","slug":"集合","permalink":"http://gavinliu4011.github.io/tags/集合/"}],"keywords":[{"name":"Python基础","slug":"Python基础","permalink":"http://gavinliu4011.github.io/categories/Python基础/"}]},{"title":"Hexo","slug":"hexo","date":"2018-05-14T13:20:36.000Z","updated":"2018-05-21T10:19:37.821Z","comments":true,"path":"2018/05/14/hexo/","link":"","permalink":"http://gavinliu4011.github.io/2018/05/14/hexo/","excerpt":"","text":"使用hexo搭建一个博客，并托管在github pages上的简易教程。 什么是Hexo? Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 安装前提 安装 Hexo 相当简单。然而在安装前，您必须检查电脑中是否已安装下列应用程序： Node.js Git 如果您的电脑中已经安装上述必备程序，那么恭喜您！接下来只需要使用 npm 即可完成 Hexo 的安装。 1$ npm install -g hexo-cli 如果有环境问题,请参考Hexo文档 如何使用Hexo搭建Github Pages博客 创建仓库 首先我们需要在Github创建一个账号,然后我们登录进去创建仓库 仓库名称必须为 username.github.io (注：username为你在github的用户名) 如果报错就是仓库已经存在。 仓库创建成功后，github会给你该仓库的https和ssh地址，复制ssh地址作为备用 建站 上面的操作完成后,我们就可以进行建站操作了,可以参照Hexo建站文档,也可以运行下面的命令 123$ hexo init &lt;folder&gt;$ cd &lt;folder&gt;$ npm install 上面操作完成后我们建站就成功了,现在我们可以看看自己的博客是什么样子了。在命令行运行下面这条的命令： 1$ npm install hexo-server --save server安装成功后，启动server便可以把博客跑起来： 1$ hexo server 现在默认是在本地运行,运行hexo server成功后会出现一个http://localhost:4000/地址 部署 到现在我们自己的博客就已经搭建起来,现在我们修改项目的部署信息 在博客的根目录下可以找到_config.yml文件,在文件最后可以找到deploy信息,现做如下配置 1234deploy: type: git repository: git@github.com:&#123;username&#125;/&#123;username&#125;.github.io.git # 这个地址就是github创建仓库后的shh地址 branch: master 以上配置好后,我们再配置一下SSH key,关于SSH key的生成和配置，github有详细的帮助文档可以参考。这里做简单介绍： 完成以上操作就完成了SSH key的配置。 有了这些配置后便可以提交部署到Github Pages,执行下面的命令: 1$ hexo clean # 删除database和public文件夹,因为执行了hexo server 成功后再执行下面的命令 12$ hexo generate # 生成新的部署所需要的文件$ hexo deploy 在执行了hexo deploy命令后可能会出现报错ERROR Deployer not found : github,这个需要再安装hexo-deployer-git 1$ npm install hexo-deployer-git --save 完成后再次执行hexo deploy命令,待命令执行成功后我们就成功部署了自己的博客,直接访问https://your-github-username.github.io/这样就可以看到默认主题的博客了","categories":[{"name":"Hexo","slug":"Hexo","permalink":"http://gavinliu4011.github.io/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://gavinliu4011.github.io/tags/Hexo/"}],"keywords":[{"name":"Hexo","slug":"Hexo","permalink":"http://gavinliu4011.github.io/categories/Hexo/"}]},{"title":"Python3基础之基本数据类型、变量和运算符","slug":"Python3基础之基本数据类型、变量和运算符","date":"2018-05-14T11:36:53.908Z","updated":"2018-05-14T11:48:19.385Z","comments":true,"path":"2018/05/14/Python3基础之基本数据类型、变量和运算符/","link":"","permalink":"http://gavinliu4011.github.io/2018/05/14/Python3基础之基本数据类型、变量和运算符/","excerpt":"","text":"Python3基础之基本数据类型、变量和运算符 基本数据类型 123456789101112131415在Python中，能够直接处理的数据类型有以下几种： 1）整型:Python可以处理任意大小的整数，当然包括负整数 如：100 -100 计算机由于使用二进制，所以Python支持二进制（0b100）、八进制(0o100)和十六进制(0xff00)表示 2)浮点数:浮点数也就是小数，之所以称为浮点数，是因为按照科学记数法表示时，一个浮点数的小数点位置是可变的 如: 123.456 但是对于很大或很小的浮点数，就必须用科学计数法表示，把10用e替代，1.23x10^9就是1.23e9 3)字符串型:字符串是以单引号或双引号括起来的任意文本 如: 'hello world' 或者 \"hello world\" 4)布尔型:布尔值和布尔代数的表示完全一致，一个布尔值只有True、False两种值，要么是True，要么是False，在Python中，可以直接用True、False表示布尔值（请注意大小写） 如: True False 3 &gt; 2 2 &lt; 5)空类型:空类型是Python里一个特殊的值，用None表示。None不能理解为0，因为0是有意义的，而None是一个特殊的空值。(请注意不要与其它语言中的null混淆)在Python中还支持复数、列表、字典、元组、集合等数据类型，之后会一一说明。 变量 12345678910111213141516171819什么是变量 在计算机程序中，变量不仅可以是数字，还可以是任意数据类型。变量是一种存储数据的载体，其值可以被读取和修改。变量命名 a.只能有数字,字母,下划线组成 b.不能以数字开始 c.不要跟关键字和系统保留字冲突 `关键字: ['False', 'None', 'True', 'and', 'as', 'assert', 'async', 'await', 'break', 'class', 'continue', 'def', 'del', 'elif', 'else', 'except', 'finally', 'for', 'from', 'global', 'if', 'import', 'in', 'is', 'lambda', 'nonlocal', 'not', 'or', 'pass', 'raise', 'return', 'try', 'while', 'with', 'yield'] d. 严格区分大小写 e. 见名之意 f. 遵循驼峰原则: UserName userName user_name变量的实用和作用 a = 100 b = -100 c = 3.1415926 d = True e = False f = None 作用是将不同的数据类型存到内存中 运算符 Python支持多种运算符，下表大致按照优先级从高到低的顺序列出了所有的运算符，我们会陆续使用到它们。说明:此片段引用原文https://blog.csdn.net/jackfrued/article/details/79392196","categories":[{"name":"Python基础","slug":"Python基础","permalink":"http://gavinliu4011.github.io/categories/Python基础/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://gavinliu4011.github.io/tags/Python/"},{"name":"数据类型","slug":"数据类型","permalink":"http://gavinliu4011.github.io/tags/数据类型/"},{"name":"变量","slug":"变量","permalink":"http://gavinliu4011.github.io/tags/变量/"},{"name":"运算符","slug":"运算符","permalink":"http://gavinliu4011.github.io/tags/运算符/"}],"keywords":[{"name":"Python基础","slug":"Python基础","permalink":"http://gavinliu4011.github.io/categories/Python基础/"}]},{"title":"Python之禅","slug":"Python之禅","date":"2018-05-14T11:32:16.938Z","updated":"2018-05-14T10:16:51.109Z","comments":true,"path":"2018/05/14/Python之禅/","link":"","permalink":"http://gavinliu4011.github.io/2018/05/14/Python之禅/","excerpt":"","text":"用过 Python的人，基本上都知道在交互式解释器中输入 import this 就会显示 Tim Peters 的 The Zen of Python，但它那偈语般的语句有点令人费解，所以我想分享一下我对它的体会，顺带给出我的翻译。 Python之禅1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253Beautiful is better than ugly. 优美胜于丑陋（Python 以编写优美的代码为目标）Explicit is better than implicit. 明了胜于晦涩（优美的代码应当是明了的，命名规范，风格相似）Simple is better than complex. 简洁胜于复杂（优美的代码应当是简洁的，不要有复杂的内部实现）Complex is better than complicated. 复杂胜于凌乱（如果复杂不可避免，那代码间也不能有难懂的关系，要保持接口简洁）Flat is better than nested. 扁平胜于嵌套（优美的代码应当是扁平的，不能有太多的嵌套）Sparse is better than dense. 间隔胜于紧凑（优美的代码有适当的间隔，不要奢望一行代码解决问题）Readability counts. 可读性很重要（优美的代码是可读的）Special cases aren&apos;t special enough to break the rules. Although practicality beats purity.即便假借特例的实用性之名，也不可违背这些规则（这些规则至高无上）Errors should never pass silently. 不要包容所有错误Unless explicitly silenced. 除非你确定需要这样做（精准地捕获异常，不写 except:pass 风格的代码）In the face of ambiguity, refuse the temptation to guess. 当存在多种可能，不要尝试去猜测There should be one-- and preferably only one --obvious way to do it. 而是尽量找一种，最好是唯一一种明显的解决方案（如果不确定，就用穷举法）Although that way may not be obvious at first unless you&apos;re Dutch. 虽然这并不容易，因为你不是 Python 之父（这里的 Dutch 是指 Guido ）Now is better than never. 做也许好过不做Although never is often better than right now. 但不假思索就动手还不如不做If the implementation is hard to explain, it&apos;s a bad idea. If the implementation is easy to explain, it may be a good idea.如果你无法向人描述你的方案，那肯定不是一个好方案；反之亦然（方案测评标准）Namespaces are one honking great idea -- let&apos;s do more of those! 命名空间是一种绝妙的理念，我们应当多加利用（倡导与号召）","categories":[{"name":"Python","slug":"Python","permalink":"http://gavinliu4011.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://gavinliu4011.github.io/tags/Python/"}],"keywords":[{"name":"Python","slug":"Python","permalink":"http://gavinliu4011.github.io/categories/Python/"}]},{"title":"Linux环境下安装Python3.X","slug":"Linux环境下安装Python3-X","date":"2018-05-14T11:30:13.681Z","updated":"2018-05-14T11:34:53.240Z","comments":true,"path":"2018/05/14/Linux环境下安装Python3-X/","link":"","permalink":"http://gavinliu4011.github.io/2018/05/14/Linux环境下安装Python3-X/","excerpt":"","text":"Linux下大部分系统默认自带python2.x的版本，最常见的是python2.6或python2.7版本，默认的python被系统很多程序所依赖，比如centos下的yum就是python2写的，所以默认版本不要轻易删除，否则会有一些问题，如果需要使用最新的Python3那么我们可以编译安装源码包到独立目录，这和系统默认环境之间是没有任何影响的，python3和python2两个环境并存即可 Linux环境下安装Python3.X 1.下载Python源代码并解压缩到指定目录 123[root@iZwz95cxo3u633jbk49xrpZ ~]# wget https://www.python.org/ftp/python/3.6.5/Python-3.6.5.tar.xz[root@iZwz95cxo3u633jbk49xrpZ ~]# xz -d Python-3.6.5.tar.xz[root@iZwz95cxo3u633jbk49xrpZ ~]# tar -xvf Python-3.6.5.tar 2.安装依赖库,没有安装可能导致Python在最后安装失败 1[root@iZwz95cxo3u633jbk49xrpZ ~]# yum -y install zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel gdbm-devel db4-devel libpcap-devel xz-devel 3.进入Python源码目录进行配置和安装 12345[root@iZwz95cxo3u633jbk49xrpZ ~]# cd Python-3.6.5[root@iZwz95cxo3u633jbk49xrpZ ~]# ./configure --prefix=/usr/local/python36 --enable-optimizations# 待上面命令成功后[root@iZwz95cxo3u633jbk49xrpZ ~]# make &amp;&amp; make install#如果在中途遇见错误,解决错误信息再重新执行make &amp;&amp; make install即可 4.创建软链接 123[root@iZwz95cxo3u633jbk49xrpZ ~]# ln -s /usr/local/python36/bin/python3 /usr/bin/python3[root@iZwz95cxo3u633jbk49xrpZ ~]# ln -s /usr/local/python36/bin/pip3 /usr/bin/pip3[root@iZwz95cxo3u633jbk49xrpZ ~]# ln -s /usr/local/python36/bin/2to3 /usr/bin/2to3 123注意:要用ipython环境要先安装ipyton[root@iZwz95cxo3u633jbk49xrpZ ~]# pip3 install ipython[root@iZwz95cxo3u633jbk49xrpZ ~]# ln -s /usr/local/python36/bin/ipython3 /usr/bin/ipython3","categories":[{"name":"Python","slug":"Python","permalink":"http://gavinliu4011.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://gavinliu4011.github.io/tags/Python/"},{"name":"Linux","slug":"Linux","permalink":"http://gavinliu4011.github.io/tags/Linux/"}],"keywords":[{"name":"Python","slug":"Python","permalink":"http://gavinliu4011.github.io/categories/Python/"}]}]}