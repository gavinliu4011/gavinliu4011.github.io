{"meta":{"title":"刘泰丞的个人博客","subtitle":"刘泰丞的个人博客","description":"刘泰丞的个人网站，记录生活的瞬间，分享学习的心得，感悟生活，留住感动","author":"GavinLiu","url":"http://gavinliu4011.github.io"},"pages":[],"posts":[{"title":"Shell常用命令","slug":"shell","date":"2018-05-15T08:43:10.000Z","updated":"2018-05-15T00:43:26.077Z","comments":true,"path":"2018/05/15/shell/","link":"","permalink":"http://gavinliu4011.github.io/2018/05/15/shell/","excerpt":"","text":"shell的基本常用命令 指令 常用操作 指令 操作 pwd 当前路径 cd 更改目录 不加参数 进入主目录 ls 当前目录内容 ls -a 查看隐藏文件 ls -l 文件详情 ls -ld 目录本身信息 mkdir 新建文件夹 rm 删除文件 rm -rf dir/ 删除文件夹 cp file1 file2 复制文件 cp -r dir1 dir2 复制文件夹 mv file .. 移动文件到上一级 mv file dir/ 移动到dir目录 mv file1 file2 替换文件 mv dir1 dir2 替换文件夹 touch a.text 创建文件 &gt;a.text 创建文件 touch .file.text 创建隐藏文件 cat file 查看文件 less file 查看文件 file a.txt 查看文件类型 man xx 打开xx指令的手册 /x 查找某参数 n 查找下一处 table 可以补全路径名 echo 打印 date 显示时间 cal 显示日历 解压缩 指令 操作 unzip 解压 zip -r 压缩 file.zip dir 压缩后的名称 压缩对象 tar zxvf 解压.tar.gz tar zcvf 压缩文件 tar jxvf 解压tar.bz2 tar jcvf 解压tar.bz2 重定向 指令 操作 丨 管道线 &lt; 标准输入重定向 &gt; 把输出流保存到文件中 重定向前把文件清空 &gt;&gt; 把输出流保存到文件中 不清空文件 cat file1 &gt;file 把file1中的内容写入file中 cat file1 &gt;&gt;file 把file1中的内容写入file内容后 ls shit 2 &gt;out.txt 标准错误输出 权限 用户在自己的主目录有写权限，在其它目录没有。 指令 操作 su - 更改用户为root sudo 超级用户 chmod +x +r +w 添加执行/读/写权限 chmod 777 添加全部权限 进程 指令 操作 ps -[ef丨aux] \\丨grep 应用名称 查看进程 kill [-9] pid 结束某个程序 搜索 指令 操作 find file -type f 搜索文件 find dir/ -type d 搜索目录 概念 概念 解释 绝对路径 以 / 开头的路径 相对路径 相对于当前工作路径 ./当前工作目录 ../上一级目录 通配符 例如 *","categories":[{"name":"Linux","slug":"Linux","permalink":"http://gavinliu4011.github.io/categories/Linux/"}],"tags":[{"name":"Shell","slug":"Shell","permalink":"http://gavinliu4011.github.io/tags/Shell/"}],"keywords":[{"name":"Linux","slug":"Linux","permalink":"http://gavinliu4011.github.io/categories/Linux/"}]},{"title":"Linux环境下Git安装与使用","slug":"Linux环境下Git安装与使用","date":"2018-05-14T20:38:20.000Z","updated":"2018-05-14T13:08:02.713Z","comments":true,"path":"2018/05/15/Linux环境下Git安装与使用/","link":"","permalink":"http://gavinliu4011.github.io/2018/05/15/Linux环境下Git安装与使用/","excerpt":"","text":"Linux环境下Git安装和使用 Linux环境下Git安装与使用 安装 官网下载并解压 123[root@VM_0_11_centos ~]# wget https://mirrors.edge.kernel.org/pub/software/scm/git/git-2.17.0.tar.gz[root@VM_0_11_centos ~]# tar -xvf git-2.17.0.tar.gz[root@VM_0_11_centos ~]# cd git-2.17.0 移除旧版本 1[root@VM_0_11_centos ~]# yum remove git 安装依赖库 12[root@VM_0_11_centos ~]# yum install libcurl-devel[root@VM_0_11_centos ~]# yum install autoconf automake libtool 执行 1234567[root@VM_0_11_centos ~]# make configureGIT_VERSION = 2.17.0 GEN configure[root@VM_0_11_centos ~]# ./configure --prefix=/usr/local/git --with-iconv =/usr/local/lib（建议优先尝试后者）或者./configure --prefix=/usr/local/git --with-iconv --with-curl --with-expat=/usr/local/lib（如果没有安装libiconv请自行安装）[root@VM_0_11_centos git-2.17.0]# make &amp;&amp; make install 配置环境变量 1234[root@VM_0_11_centos git-2.17.0]# vim ~/.bash_profile在文件末尾追加上下面命令:PATH=$PATH:/usr/local/git/binexport PATH 重新加载环境变量 1[root@VM_0_11_centos git-2.17.0]# source ~/.bash_profile 查看git版本 1[root@VM_0_11_centos git-2.17.0]# git --version 使用 在本地建立本地仓库 123[root@VM_0_11_centos ~]# mkdir test[root@VM_0_11_centos test]# cd test[root@VM_0_11_centos test]# git init 把文件纳入版本控制(加入暂存区) 12[root@VM_0_11_centos test]# git add &lt;filename&gt; # 将修改后的文件加入暂存区[root@VM_0_11_centos test]# git add . # add后跟.是将当前文件夹下面的所有文件及文件夹都加入暂存区 提交到仓库(-m 后是描述) 1[root@VM_0_11_centos test]# git commit -m '本次提交文件的相关描述信息' 如果提交报错,看否是缺少user.name、user.email,可执行下面的命令解决: 12[root@VM_0_11_centos test]# git config --global user.name 'your-name'[root@VM_0_11_centos test]# git config --global user.email 'your-email' 查看放入暂存区的文件 1[root@VM_0_11_centos test]# git status 查看版本 1[root@VM_0_11_centos test]# git log 回滚到某个版本 1[root@VM_0_11_centos test]# git reset --hard 版本号 显示版本包括历史版本 12[root@VM_0_11_centos test]# git reflog[root@VM_0_11_centos test]# git reflog --pretty=oneline # 单行显示 把暂存区的内容全撤回来(可以在本地做修改,然后再次add进暂存区做提交) 1[root@VM_0_11_centos test]# git checkout -- [可跟上文件名] 添加远端仓库 1[root@VM_0_11_centos test]# git remote add origin https://git.coding.net/gavinliu/test.git 将本地仓库和远端仓库同步 1[root@VM_0_11_centos test]# git push -u origin master 创建分支 1[root@VM_0_11_centos test]# git branch [分支名] 查看所有分支 1[root@VM_0_11_centos test]# git branch 切换分支 1[root@VM_0_11_centos test]# git checkout [分支名] 删除文件 1[root@VM_0_11_centos test]# git rm [filename] 合并分支 1[root@VM_0_11_centos test]# git merge [分支名] 克隆项目到本地 1[root@VM_0_11_centos ~]# git clone https://git.coding.net/jackfrued/HelloGit.git 推送到服务器,origin是原始名字,master是分支 1[root@VM_0_11_centos test]# git push origin master 拉取服务器代码 1[root@VM_0_11_centos test]# git pull ​","categories":[{"name":"Git","slug":"Git","permalink":"http://gavinliu4011.github.io/categories/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://gavinliu4011.github.io/tags/Git/"}],"keywords":[{"name":"Git","slug":"Git","permalink":"http://gavinliu4011.github.io/categories/Git/"}]},{"title":"Python3基础之函数","slug":"Python3基础之函数","date":"2018-05-14T20:35:29.000Z","updated":"2018-05-14T12:35:57.584Z","comments":true,"path":"2018/05/15/Python3基础之函数/","link":"","permalink":"http://gavinliu4011.github.io/2018/05/15/Python3基础之函数/","excerpt":"","text":"Python3基础之函数 三元运算符补充 123456# 三元运算符(或者三目运算)# 格式# 结果 = 值1 if 条件 else 值2result = True if 1&gt;2 else False# 如果条件成立则返回'值1',否则返回'值2' 函数的定义 12345678910111213141516171819在开始之前我们先上一段代码:while True： if cpu利用率 &gt; 90%: # 发送邮件提醒 连接邮箱服务器 发送邮件 关闭连接 if 硬盘使用空间 &gt; 90%: # 发送邮件提醒 连接邮箱服务器 发送邮件 关闭连接 if 内存占用 &gt; 80%: # 发送邮件提醒 连接邮箱服务器 发送邮件 关闭连接 不知道大家是否注意到以上代码有很多重复的代码,要写出高质量的代码首先要解决的就是重复代码的问题。我们可以将上面的’发送邮件提醒’功能封装成一个函数,当满足条件时调用函数即可。所以某些具有特殊功能的代码块, 将这些特定的代码块给他分封装起来,这个封装起来的代码块就是函数。 1234567891011121314151617181920212223242526# 定义函数函数的定义主要有如下要点： 1.def：表示函数的关键字 2.函数名：函数的名称，日后根据函数名调用函数（函数的命名规则和变量的命名规则一致） 3.函数体：函数中进行一系列的逻辑计算，如：发送邮件 4.参数：为函数体提供数据 5.返回值：当函数执行完毕后，可以给调用者返回数据。下面我们重构一下上面发送邮件的代码：def send(): 发送邮件的代码... if success: #发送成功 return True else: return False while True: # 每次执行发送邮件函数，都会将返回值自动赋值给result # 之后，可以根据result来写日志，或重发等操作 # 在这儿根据函数名'send'来调用函数 result = send() if result == False: 记录日志，短信发送失败... 匿名函数 123456789对于简单的函数，也存在一种简便的表示方式，即：lambda表达式# 普通方式def sum(arg): return arg + 5print(sum(5))# 匿名函数lambda_sum = lambda x, y: x + yprint(lambda_sum(5, 5)) 函数的运用 1234567891011121314151617181920212223242526272829# 递归调用,遍历文件夹目录import osdef get_all_dir(path, str=\"|--\"): \"\"\" 实现目录的遍历 :param path: 遍历目录的路径 :param str: 样式 :return: \"\"\" # 返回一个指定文件夹(目录)包含文件和文件夹(目录),并且返回一个列表,但是不包含.和..,他一般按照英文首字母排序 fill_all = os.listdir(path) # print(fillAll) for filename in fill_all: # 一定不能少了全路径的拼接 file_path = os.path.join(path, filename) # print(filePath) # 判断filePath是否是目录 if os.path.isdir(file_path): print(str + '文件夹' + filename) # filePath是目录 get_all_dir(file_path, \"\\t\" + str) else: # filePath不是目录,即是文件 print(str + '文件:' + filename)get_all_dir('../gavinliu_study')","categories":[{"name":"Python基础","slug":"Python基础","permalink":"http://gavinliu4011.github.io/categories/Python基础/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://gavinliu4011.github.io/tags/Python/"},{"name":"函数","slug":"函数","permalink":"http://gavinliu4011.github.io/tags/函数/"}],"keywords":[{"name":"Python基础","slug":"Python基础","permalink":"http://gavinliu4011.github.io/categories/Python基础/"}]},{"title":"Python3基础之分支结构和循环结构","slug":"Python3基础之分支结构和循环结构","date":"2018-05-14T20:12:46.000Z","updated":"2018-05-14T12:26:41.296Z","comments":true,"path":"2018/05/15/Python3基础之分支结构和循环结构/","link":"","permalink":"http://gavinliu4011.github.io/2018/05/15/Python3基础之分支结构和循环结构/","excerpt":"","text":"在Python中，要构造分支结构可以使用if、elif和else关键字。所谓关键字就是有特殊含义的单词，像if和else就是专门用于构造分支结构的关键字，很显然你不能够使用它作为变量名（事实上，用作其他的标识符也是不可以） 在程序中我们需要重复的执行某条或某些指令，例如比如在我们的程序中要实现每隔1秒中在屏幕上打印一个”hello, world”这样的字符串并持续一个小时，我们肯定不能够将print(&#39;hello, world&#39;)这句代码写上3600遍。当然你可能已经注意到了，刚才的描述中其实是重复的动作 Python3基础之分支结构和循环结构 分支结构 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273第一种: if结构格式: if 表达式: 语句块执行流程:程序遇到if结构时,判断表达式的真假,如果为真,则执行语句块,否则结束if结构 表达式为假的情况: 0 '' None False [] () &#123;&#125;num1 = 78num2 = 45tmp = 0if num1 &gt; num2: tmp = num1 num1 = num2 num2 = tmp print(num1, num2)第二种: if-else结构格式: if 表达式: 语句块1 else: 语句块2执行流程:程序执行到if结构,判断表达式的真假,如果为真,则执行语句块1,如果为假,则执行else中的语句块的内容# 判断一个年份是否是闰年year = int(input('请输入你要输入的年份:'))if ((year % 4 == 0) and (year % 100 != 0)) or (year % 400 == 0): print('是润年')else: print('不是闰年')第三种: if-elif-else格式: if 表达式1: 语句块1 elif 表达式2: 语句块2 elif 表达式3: 语句块3 else: 语句块n执行流程:程序执行到if语句,判断表达式1的真假,如果为真,则执行语句1,否则判断表达式2的真假,如果为真,则执行表达式2,一次类推,直到最后一个表达式为假,就执行else里边的语句块nimport random# 产生一个1-6的随机数num = random.randint(1, 6)# print(num)if num == 1: print('这个随机数乘以1后是%d' % (num * 1))elif num == 2: print('这个随机数乘以2后是%d' % (num * 2))elif num == 3: print('这个随机数乘以3后是%d' % (num * 3))elif num == 4: print('这个随机数乘以4后是%d' % (num * 4))elif num == 5: print('这个随机数乘以5后是%d' % (num * 5))else: print('这个随机数乘以本身后是%d' % (num * num)) 第四种: 嵌套if 表达式1: if 表达式2: 语句块1 else: 语句块2else: 语句块3name = 'xiaoming'password = '123456'user = input('请输入用户名')pwd = input('请输入密码')if user == name: if pwd == password: print('恭喜你,登录成功') else: print('用户名或者密码错误2')else: print('用户名或者密码错误1') 循环结构 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#for-in循环#如果明确的知道循环执行的次数或者是要对一个容器进行迭代，使用for-in循环\"\"\"用for循环实现1~100求和\"\"\"sum = 0for x in range(101): sum += xprint(sum)\"\"\"输入两个正整数计算最大公约数和最小公倍数\"\"\"num1 = int(input(\"请输入第一个整数:\"))num2 = int(input(\"请输入第二个整数:\"))# actual = Noneactual = min(num1, num2) # 取最小的整数# commonDivisorVal = Nonefor i in range(1, actual + 1): if (num1 % i == 0) and (num2 % i == 0): commonDivisorVal = iprint(\"%d和%d的最大公约数是%d\" % (num1, num2, commonDivisorVal))#while循环#如果要构造不知道具体循环次数的循环结构，推荐使用while循环，while循环通过一个能够产生或转换出bool值的表达式来控制循环，表达式的值为True循环继续，表达式的值为False循环结束。\"\"\"猜数字游戏计算机出一个1~100之间的随机数由人来猜计算机根据人猜的数字分别给出提示大一点/小一点/猜对了\"\"\"import randomanswer = random.randint(1, 100)counter = 0while True: counter += 1 number = int(input('请输入: ')) if number &lt; answer: print('大一点') elif number &gt; answer: print('小一点') else: print('恭喜你猜对了!') breakprint('你总共猜了%d次' % counter) 注意:上面的代码中使用了break关键字来提前终止循环，需要注意的是break只能终止它所在的那个循环，这一点在使用嵌套的循环结构需要注意。除了break之外，还有另一个是continue，它可以用来跳过本次循环直接进入下一轮循环。","categories":[{"name":"Python基础","slug":"Python基础","permalink":"http://gavinliu4011.github.io/categories/Python基础/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://gavinliu4011.github.io/tags/Python/"},{"name":"分支结构","slug":"分支结构","permalink":"http://gavinliu4011.github.io/tags/分支结构/"},{"name":"循环结构","slug":"循环结构","permalink":"http://gavinliu4011.github.io/tags/循环结构/"}],"keywords":[{"name":"Python基础","slug":"Python基础","permalink":"http://gavinliu4011.github.io/categories/Python基础/"}]},{"title":"Python3基础之字符串、列表、元组、字典、集合等相关操作","slug":"Python3基础之字符串、列表、元组、字典、集合等相关操作","date":"2018-05-14T19:54:42.000Z","updated":"2018-05-14T12:12:13.686Z","comments":true,"path":"2018/05/15/Python3基础之字符串、列表、元组、字典、集合等相关操作/","link":"","permalink":"http://gavinliu4011.github.io/2018/05/15/Python3基础之字符串、列表、元组、字典、集合等相关操作/","excerpt":"","text":"下面将一一介绍Python中的字符串、列表、元组、集合的相关操作 字符串、列表、元组、字典、集合等相关操作 字符串操作 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104字符串一般情况使用单引号或者双引号引起来规则: 单不能套单,单可以套双 双不能套双,双可以套单## 多行字符串# 方式二str3 = '3月25号我来到了美丽的成都,刚下飞机,'\\ '就碰到一个老外帅锅,结果他还跟我打招呼.但是我不会英语,好尴尬'# 方式一str4 = '''洁白的婚纱,手捧着鲜花 ,美丽的想通话.想起那年初夏,我为你牵挂.'''# 方式三str5 = \"\"\"洁白的婚纱,手捧着鲜花 ,美丽的想通话.想起那年初夏,我为你牵挂.\"\"\"print(str5)#--------------------------------------------------------------------------------##字符串的长度'''len(): 获取字符串的长度'''str1 = 'lhy'str1 = '刘海艳'str1 = '幸福像花儿一样'print(len(str1))总结: 无论是字符还是汉字,只要有一个,则长度就是几个#-------------------------------------------------------------------------------##提取某个字符'''提取字符串中的某一个字符方式:从左往右开始, 下标从0开始提取str[0] str[1] str[2] ..... str[n]从优往左开始, 下标从-1开始str[-1] str[-2] ..... str[-n]'''str1 = 'It is a dog'print(str1[0])print(str1[-2])# pytjon中的字符串一旦定义好之后,是不可以修改的str1[0] = 'i'print('str1 =', str1)#------------------------------------------------------------------------------##转义字符'''转义字符: 将原来的意义给他去掉 \\(这是反斜线) '''str1 = '我最喜欢的一首歌是\\'咱们结婚吧\\''str1 = 'you\\'re a good man'print(str1)'''系统里边有一些特殊的字符: \\t(制表符) \\n(换行符)'''print('你好\\\\t宝强哥,你的媳妇是马蓉吗?')print('你好\\\\n宋喆,你的情人是\\t马蓉\\n吗?')# 如果想将原来具有特殊含义的字符失去本身的意义,我们可以直接在整个字符串前边添加一个rprint(r'你好\\t宝强哥,你的媳妇是马蓉吗?')print(r'你好\\n宋喆,你的情人是马蓉吗?')#-------------------------------------------------------------------------------##字符串截取'''字符串截取:str1[开始下标:结束下标]: 从开始下标截取,到结束下标=结尾,.包含开始下标,但不包含结束下标str1[0:5] 提取是的结果你是zhousstr1[:3] 默认从下标0开始到结束的开区间str1[3:] 从指定的下标开始到结尾str1[-n:]: 从最后边提取n个str1[:]: 提取全部字符str1[::2] 根据下标每个n个提取一次str1[::-1] 将字符逆序排列'''#------------------------------------------------------------------------------##字符串的格式化%s: 给字符串站位%d: 给int类型站位%f: 给浮点类型站位, 默认保留6为小数 %.2f: 保留两位小数 %10.2f 共10位,保留两位小数,其他为使用空格补齐 %010.2f 共10位,保留两位小数,其他为使用0补齐%c: 打印一个字符%o: 将十进制转换成八进制%x: 将十进制转换成十六进制name = '宝强'age = 36like = 'green'print('他是&#123;&#125;,今年&#123;&#125;,他喜欢&#123;&#125;' .format(name, age, like))print('他是&#123;lala&#125;,今年&#123;wawa&#125;, 他喜欢&#123;heihei&#125;' .format(wawa=age, heihei=like, lala=name))#--------------------------------------------------------------------------------##字符串比较大小[规则:]从第一个字符开始比较,将字符转换成ascii值进行比较如果小于则返回True,否则返回False 列表操作 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113'''列表: 格式: 列表名 = [元素1, 元素2,,...]'''# append()往列表后边追加一个元素list1 = [1, 2, 3, 4]list1.append(100)# print(list1)list1.append([200, 400, 600])# print(list1)# 在末尾一次性追加另外一个列表中的多个值list2 = [3, 4, 5]list2.extend([200, 300, 400])# print(list2)'''insert():在指定下标出添加一个元素,原来位置处的元素往后移动@参数一: 列表的下标@参数二: 列表中下标所对应的值'''list3 = [5, 6, 7]list3.insert(1, 250)# print(list3)'''pop():将列表中指定下标的元素删除, 如果默认不传递参数,则删除的是最后一个元素@参数一: [可有可无] 列表对应的下标'''list4 = [3, 4, 5, 6, 7, 8]list4.pop()list4.pop()# print(list4)list4.pop(1)# print(list4)'''remove():移除列表中指定的元素@参数一: 列表中的元素'''list5 = [3, 4, 5, 6, 7]list5.remove(3)# print(list5)'''clear():清除列表中所有的元素'''list6 = [1, 3, 4]list6.clear()# print(list6)'''index():获取列表元素锁对应的下标@参数一: 列表中的某一个元素返回值: 列表中元素所对应的下标'''list7 = [1, 2, 3, 4, 5, 6]index1 = list7.index(3)# print(index1)# 获取列表的长度list8 = [1, 2, 3, 4, 5]# print(len(list8))list9 = [1, 3, 4, 6, 7]# print(max(list9))list10 = [1, 3, 4, 6, 7]# print(min(list9))'''count(): 计算列表中元素出现的次数'''list11 = [1, 3, 4, 3, 3, 3, 3, 6, 7]# print(list11.count(3))'''reverse():将列表进行倒序排列'''list12 = [1, 2, 3, 4, 5, 10, 7, 8, 9]list12.reverse()# print(list12)'''sort():将列表中的元素进行升序排列'''list13 = [1, 100, 78, 23, 65, 43]list13.sort()# print(list13)'''引用传递: 在列表中,如果修改一个列表的元素,那么对应的另外一个列表的元素也改变'''list14 = [2, 3, 4]list15 = list14list15[1] = 200# print(list14)# print(list15)# id():查看内存的地址# print(id(list14))# print(id(list15))'''值传递在列表中修改一个元素的值时,对应的另外一个列表中的值是不发生改变的'''list16 = [1, 2, 3, 4]list17 = list16.copy()list17[1] = 250print(list16)print(list17)print(id(list16))print(id(list17)) 元组操作 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104'''元组:也是一种有序集合特点:1.跟列表非常相似: list1 = [] tuple1 = ()2.一旦定义好之后不能修改3.使用小括号括起一个集合'''# 创建一个空元祖tuple1 = ()# print(tuple1)# print(type(tuple1))tuple2 = (23, 3.14, 'aaa', None, True)# print(tuple2)tuple3 = (4, )#tupletuple3 = (4)#int# print(tuple3)# print(type(tuple3))# 访问元祖的元素tuple4 = (2, 3, 4, 5, 6)# print(tuple4[0])# print(tuple4[1])# 元祖在访问的时候一定不能溢出(越界),直接报错# print(tuple4[5])# 获取元祖中最后一个元素# print(tuple4[-1])# print(tuple4[-2])# 一定不能越界# print(tuple4[-6])tuple5 = (1, 2, 3, 4, [12, 34, 45])# print(tuple5)# tuple5[0] = 150#直接报错, 元祖定义好之后是不能修改的# print(tuple5)# print(tuple5[-1][-2])# print(tuple5[4][1])# 删除元祖的用法跟删除变量的用法一致tuple6 = (2, 3, 5, 6)del tuple6# print(tuple6)# 元祖进行操作tuple7 = (3, 4, 5)tuple8 = (6, 7, 8)# 将两个元祖合并成一个新的元祖tuple9 = tuple7 + tuple8# print(tuple9)# print(tuple7, tuple8)# 将元祖重复n次,最后返回一个新的元祖tuple10 = (3, 4, 5)# print(tuple10 * 10)# 判断一个元素是否在一个元祖中,如果在返回True,否则返回Falsetuple11 = (3, 5, 7)# print(4 in tuple11)# 元祖的截取# 格式: 元祖名[开始下标:结束下标]tuple12 = (1, 2, 3, 4, 5, 6, 7, 8, 9,10)# print(tuple12[1:5])# print(tuple12[3:])# print(tuple12[:6])# 将元祖进行逆序排列# print(tuple12[::-1])# 二维元祖:tuple13 = ((2, 3, 4), (5, 6, 7))# print(tuple13[1][1])# 元祖的方法# 求一个元祖的长度tuple14 = (2, 3, 4, 5)# print(len(tuple14))# print(max(tuple14))# print(min(tuple14))# 对列表进行遍历# for i in [1, 2, 3, 4, 5]:# print(i)# 对元祖进行遍历# for x in (3, 4, 5, 6, 7):# print(x)# 将列表转换成元祖list11 = [3, 5, 6, 8]tuple15 = tuple(list11)# print(tuple15)# 将元祖转换成列表tuple16 = (4, 6, 8, 9)list12 = list(tuple16)# print(list12)list13 = range(0, 10)print(type(list13))# range(): 从开始值开始,但不包含结束值[0, 10)# for i in range(0, 10):# print(i) 字典操作 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162'''dict(字典): 在字典里边一般存放的是键值对的形式.键1 = 值1 key = value键1 : 值1写法: &#123;键1:值1, 键2:值2, 键3:值3&#125;例子:dict1 = &#123;'name': '刘海艳', 'age': 17, 'sex': 'girl'&#125;注意事项:1.在字典中键(key)的值必须是唯一2.在字典中可以存放多个键值对3.在字典中键(key)必须是不可变类型 字符串 整数都可以作为键(key)4.list和tuple都是有序集合, 而dictsahib无序集合'''# 必须保证字典中的key是唯一的dict1 = &#123;'yelei': 100, 'xiaoming' : 99, 'jianfei': 59, 'zhouying': 110&#125;# print(dict1)# 元素的访问# 获取的方式: 字典名[key]# print(dict1['xiaoming'])# print(dict1.get('yelei'))# print('yelei' in dict1)ret = dict1.get('lhy')# if ret == None:# print('没有')# else:# print('有')dict2 = &#123;'user': '大黄', 'sex': '男', 'age': 30, 'height': 150 &#125;# 添加元素dict2['lover'] = '小白'# 一个key只能对应一个valuedict2['lover'] = '小绿'# 修改dict2['lover'] = '小花'# 删除dict2.pop('sex')# 直接报错,因为他是无需集合# dict2.pop()# print(dict2)# 遍历# for x in dict2:# print(x, dict2[x])# 获取字典所有的value和key# print(dict2.values())# print(dict2.keys())# for i in dict2.values():# print(i)## for i in dict2.keys():# print(i)# for k,v in dict2.items():# print(k, v)#for k,v in enumerate(dict2):# print(k, v) 集合操作 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162'''set(集合):类似于dict, 也是无序的,以key-value新的形势存在,但是没有value作用: 是对list,tuple,dict进行去重的, 求交集.并集1.set是无序2.set集合是不可改变的'''# set1 = set([1, 2, 3, 5, 3, 2])# print(set1)# print(type(set1))# set2 = set((1, 2, 3, 5, 3, 2, 4, 5))# print(set2)# print(type(set2))# set3 = set(&#123;3, 4, 5,5, 6, 3, 7&#125;)# print(set3)# print(type(set3))# 添加set4 = set([3, 3, 4, 5, 7, 2, 1, 2])set4.add(8)# set4.add(3)#可以添加重复的值,但是没效果# 总结:list和dict是可改变的, 而tuple是不可改变# set4.add([10, 9])#直接报错,不能添加list# set4.add((10, 9))# set4.add(&#123;'a':1&#125;)#直接报错,不能添加字典## print(set4)# 修改set5 = set([1, 2, 3, 4, 5])# 将list dict tuple 等等整个插入进去# set5.update([6, 7, 8])# set5.update(&#123;9, 10&#125;)# set5.update((11, 56))# print(set5)# 删除# set6= set([3, 4, 5, 6, 7])# set6.remove(4)# print(set6)# 遍历set7 = set([1, 2, 3, 4, 6])set7 = set(['aaa', 'bbb', 'ccc'])set7 = set((1, 2, 3, 2, 4, 2, 3))# 在set集合中,没有value,即使有value也遍历不出来set7 = set(&#123;'name':'小花', 'age': 18&#125;)# for i in set7:# print(i, end = ',')# &amp; | - ^set8 = set([1, 2, 3, 4])set9 = set([3, 2, 4, 5])set10 = set8 &amp; set9set11 = set8 | set9set12 = set8 - set9set13 = set8 ^ set9print(set10)print(set11)print(set12)print(set13)","categories":[{"name":"Python基础","slug":"Python基础","permalink":"http://gavinliu4011.github.io/categories/Python基础/"}],"tags":[{"name":"字符串","slug":"字符串","permalink":"http://gavinliu4011.github.io/tags/字符串/"},{"name":"列表","slug":"列表","permalink":"http://gavinliu4011.github.io/tags/列表/"},{"name":"元组","slug":"元组","permalink":"http://gavinliu4011.github.io/tags/元组/"},{"name":"字典","slug":"字典","permalink":"http://gavinliu4011.github.io/tags/字典/"},{"name":"集合","slug":"集合","permalink":"http://gavinliu4011.github.io/tags/集合/"}],"keywords":[{"name":"Python基础","slug":"Python基础","permalink":"http://gavinliu4011.github.io/categories/Python基础/"}]},{"title":"Hexo","slug":"hexo","date":"2018-05-14T13:20:36.000Z","updated":"2018-05-15T01:15:46.650Z","comments":true,"path":"2018/05/14/hexo/","link":"","permalink":"http://gavinliu4011.github.io/2018/05/14/hexo/","excerpt":"","text":"使用hexo搭建一个博客，并托管在github pages上的简易教程。 什么是Hexo? Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 安装前提 安装 Hexo 相当简单。然而在安装前，您必须检查电脑中是否已安装下列应用程序： Node.js Git 如果您的电脑中已经安装上述必备程序，那么恭喜您！接下来只需要使用 npm 即可完成 Hexo 的安装。 1$ npm install -g hexo-cli 如果有环境问题,请参考Hexo文档 如何使用Hexo搭建Github Pages博客 创建仓库 首先我们需要在Github创建一个账号,然后我们登录进去创建仓库 仓库名称必须为 username.github.io (注：username为你在github的用户名) 如果报错就是仓库已经存在。 仓库创建成功后，github会给你该仓库的https和ssh地址，复制ssh地址作为备用 建站 上面的操作完成后,我们就可以进行建站操作了,可以参照Hexo建站文档,也可以运行下面的命令 123$ hexo init &lt;folder&gt;$ cd &lt;folder&gt;$ npm install 上面操作完成后我们建站就成功了,现在我们可以看看自己的博客是什么样子了。在命令行运行下面这条的命令： 1$ npm install hexo-server --save server安装成功后，启动server便可以把博客跑起来： 1$ hexo server 现在默认是在本地运行,运行hexo server成功后会出现一个http://localhost:4000/地址 部署 到现在我们自己的博客就已经搭建起来,现在我们修改项目的部署信息 在博客的根目录下可以找到_config.yml文件,在文件最后可以找到deploy信息,现做如下配置 1234deploy: type: git repository: git@github.com:&#123;username&#125;/&#123;username&#125;.github.io.git # 这个地址就是github创建仓库后的shh地址 branch: master 有了这些配置后便可以提交部署到Github Pages,执行下面的命令: 1$ hexo clean # 删除database和public文件夹,因为执行了hexo server 成功后再执行下面的命令 12$ hexo generate # 生成新的部署所需要的文件$ hexo deploy 在执行了hexo deploy命令后可能会出现报错ERROR Deployer not found : github,这个需要再安装hexo-deployer-git 1$ npm install hexo-deployer-git --save 完成后再次执行hexo deploy命令,待命令执行成功后我们就成功部署了自己的博客,直接访问https://your-github-username.github.io/这样就可以看到默认主题的博客了","categories":[{"name":"Hexo","slug":"Hexo","permalink":"http://gavinliu4011.github.io/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://gavinliu4011.github.io/tags/Hexo/"}],"keywords":[{"name":"Hexo","slug":"Hexo","permalink":"http://gavinliu4011.github.io/categories/Hexo/"}]},{"title":"Python3基础之基本数据类型、变量和运算符","slug":"Python3基础之基本数据类型、变量和运算符","date":"2018-05-14T11:36:53.908Z","updated":"2018-05-14T11:48:19.385Z","comments":true,"path":"2018/05/14/Python3基础之基本数据类型、变量和运算符/","link":"","permalink":"http://gavinliu4011.github.io/2018/05/14/Python3基础之基本数据类型、变量和运算符/","excerpt":"","text":"Python3基础之基本数据类型、变量和运算符 基本数据类型 123456789101112131415在Python中，能够直接处理的数据类型有以下几种： 1）整型:Python可以处理任意大小的整数，当然包括负整数 如：100 -100 计算机由于使用二进制，所以Python支持二进制（0b100）、八进制(0o100)和十六进制(0xff00)表示 2)浮点数:浮点数也就是小数，之所以称为浮点数，是因为按照科学记数法表示时，一个浮点数的小数点位置是可变的 如: 123.456 但是对于很大或很小的浮点数，就必须用科学计数法表示，把10用e替代，1.23x10^9就是1.23e9 3)字符串型:字符串是以单引号或双引号括起来的任意文本 如: 'hello world' 或者 \"hello world\" 4)布尔型:布尔值和布尔代数的表示完全一致，一个布尔值只有True、False两种值，要么是True，要么是False，在Python中，可以直接用True、False表示布尔值（请注意大小写） 如: True False 3 &gt; 2 2 &lt; 5)空类型:空类型是Python里一个特殊的值，用None表示。None不能理解为0，因为0是有意义的，而None是一个特殊的空值。(请注意不要与其它语言中的null混淆)在Python中还支持复数、列表、字典、元组、集合等数据类型，之后会一一说明。 变量 12345678910111213141516171819什么是变量 在计算机程序中，变量不仅可以是数字，还可以是任意数据类型。变量是一种存储数据的载体，其值可以被读取和修改。变量命名 a.只能有数字,字母,下划线组成 b.不能以数字开始 c.不要跟关键字和系统保留字冲突 `关键字: ['False', 'None', 'True', 'and', 'as', 'assert', 'async', 'await', 'break', 'class', 'continue', 'def', 'del', 'elif', 'else', 'except', 'finally', 'for', 'from', 'global', 'if', 'import', 'in', 'is', 'lambda', 'nonlocal', 'not', 'or', 'pass', 'raise', 'return', 'try', 'while', 'with', 'yield'] d. 严格区分大小写 e. 见名之意 f. 遵循驼峰原则: UserName userName user_name变量的实用和作用 a = 100 b = -100 c = 3.1415926 d = True e = False f = None 作用是将不同的数据类型存到内存中 运算符 Python支持多种运算符，下表大致按照优先级从高到低的顺序列出了所有的运算符，我们会陆续使用到它们。说明:此片段引用原文https://blog.csdn.net/jackfrued/article/details/79392196","categories":[{"name":"Python基础","slug":"Python基础","permalink":"http://gavinliu4011.github.io/categories/Python基础/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://gavinliu4011.github.io/tags/Python/"},{"name":"数据类型","slug":"数据类型","permalink":"http://gavinliu4011.github.io/tags/数据类型/"},{"name":"变量","slug":"变量","permalink":"http://gavinliu4011.github.io/tags/变量/"},{"name":"运算符","slug":"运算符","permalink":"http://gavinliu4011.github.io/tags/运算符/"}],"keywords":[{"name":"Python基础","slug":"Python基础","permalink":"http://gavinliu4011.github.io/categories/Python基础/"}]},{"title":"Python之禅","slug":"Python之禅","date":"2018-05-14T11:32:16.938Z","updated":"2018-05-14T10:16:51.109Z","comments":true,"path":"2018/05/14/Python之禅/","link":"","permalink":"http://gavinliu4011.github.io/2018/05/14/Python之禅/","excerpt":"","text":"用过 Python的人，基本上都知道在交互式解释器中输入 import this 就会显示 Tim Peters 的 The Zen of Python，但它那偈语般的语句有点令人费解，所以我想分享一下我对它的体会，顺带给出我的翻译。 Python之禅1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253Beautiful is better than ugly. 优美胜于丑陋（Python 以编写优美的代码为目标）Explicit is better than implicit. 明了胜于晦涩（优美的代码应当是明了的，命名规范，风格相似）Simple is better than complex. 简洁胜于复杂（优美的代码应当是简洁的，不要有复杂的内部实现）Complex is better than complicated. 复杂胜于凌乱（如果复杂不可避免，那代码间也不能有难懂的关系，要保持接口简洁）Flat is better than nested. 扁平胜于嵌套（优美的代码应当是扁平的，不能有太多的嵌套）Sparse is better than dense. 间隔胜于紧凑（优美的代码有适当的间隔，不要奢望一行代码解决问题）Readability counts. 可读性很重要（优美的代码是可读的）Special cases aren&apos;t special enough to break the rules. Although practicality beats purity.即便假借特例的实用性之名，也不可违背这些规则（这些规则至高无上）Errors should never pass silently. 不要包容所有错误Unless explicitly silenced. 除非你确定需要这样做（精准地捕获异常，不写 except:pass 风格的代码）In the face of ambiguity, refuse the temptation to guess. 当存在多种可能，不要尝试去猜测There should be one-- and preferably only one --obvious way to do it. 而是尽量找一种，最好是唯一一种明显的解决方案（如果不确定，就用穷举法）Although that way may not be obvious at first unless you&apos;re Dutch. 虽然这并不容易，因为你不是 Python 之父（这里的 Dutch 是指 Guido ）Now is better than never. 做也许好过不做Although never is often better than right now. 但不假思索就动手还不如不做If the implementation is hard to explain, it&apos;s a bad idea. If the implementation is easy to explain, it may be a good idea.如果你无法向人描述你的方案，那肯定不是一个好方案；反之亦然（方案测评标准）Namespaces are one honking great idea -- let&apos;s do more of those! 命名空间是一种绝妙的理念，我们应当多加利用（倡导与号召）","categories":[{"name":"Python","slug":"Python","permalink":"http://gavinliu4011.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://gavinliu4011.github.io/tags/Python/"}],"keywords":[{"name":"Python","slug":"Python","permalink":"http://gavinliu4011.github.io/categories/Python/"}]},{"title":"Linux环境下安装Python3.X","slug":"Linux环境下安装Python3-X","date":"2018-05-14T11:30:13.681Z","updated":"2018-05-14T11:34:53.240Z","comments":true,"path":"2018/05/14/Linux环境下安装Python3-X/","link":"","permalink":"http://gavinliu4011.github.io/2018/05/14/Linux环境下安装Python3-X/","excerpt":"","text":"Linux下大部分系统默认自带python2.x的版本，最常见的是python2.6或python2.7版本，默认的python被系统很多程序所依赖，比如centos下的yum就是python2写的，所以默认版本不要轻易删除，否则会有一些问题，如果需要使用最新的Python3那么我们可以编译安装源码包到独立目录，这和系统默认环境之间是没有任何影响的，python3和python2两个环境并存即可 Linux环境下安装Python3.X 1.下载Python源代码并解压缩到指定目录 123[root@iZwz95cxo3u633jbk49xrpZ ~]# wget https://www.python.org/ftp/python/3.6.5/Python-3.6.5.tar.xz[root@iZwz95cxo3u633jbk49xrpZ ~]# xz -d Python-3.6.5.tar.xz[root@iZwz95cxo3u633jbk49xrpZ ~]# tar -xvf Python-3.6.5.tar 2.安装依赖库,没有安装可能导致Python在最后安装失败 1[root@iZwz95cxo3u633jbk49xrpZ ~]# yum -y install zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel gdbm-devel db4-devel libpcap-devel xz-devel 3.进入Python源码目录进行配置和安装 12345[root@iZwz95cxo3u633jbk49xrpZ ~]# cd Python-3.6.5[root@iZwz95cxo3u633jbk49xrpZ ~]# ./configure --prefix=/usr/local/python36 --enable-optimizations# 待上面命令成功后[root@iZwz95cxo3u633jbk49xrpZ ~]# make &amp;&amp; make install#如果在中途遇见错误,解决错误信息再重新执行make &amp;&amp; make install即可 4.创建软链接 123[root@iZwz95cxo3u633jbk49xrpZ ~]# ln -s /usr/local/python36/bin/python3 /usr/bin/python3[root@iZwz95cxo3u633jbk49xrpZ ~]# ln -s /usr/local/python36/bin/pip3 /usr/bin/pip3[root@iZwz95cxo3u633jbk49xrpZ ~]# ln -s /usr/local/python36/bin/2to3 /usr/bin/2to3 123注意:要用ipython环境要先安装ipyton[root@iZwz95cxo3u633jbk49xrpZ ~]# pip3 install ipython[root@iZwz95cxo3u633jbk49xrpZ ~]# ln -s /usr/local/python36/bin/ipython3 /usr/bin/ipython3","categories":[{"name":"Python","slug":"Python","permalink":"http://gavinliu4011.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://gavinliu4011.github.io/tags/Python/"},{"name":"Linux","slug":"Linux","permalink":"http://gavinliu4011.github.io/tags/Linux/"}],"keywords":[{"name":"Python","slug":"Python","permalink":"http://gavinliu4011.github.io/categories/Python/"}]}]}